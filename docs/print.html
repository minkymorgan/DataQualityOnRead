<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Quality on Read</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A practical guide to mask-based data profiling with bytefreq and dataradar">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Data Quality on Read</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/minkymorgan/DataQualityOnRead" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="data-quality-on-read" class="unnumbered"><a class="header" href="#data-quality-on-read">Data Quality on Read</a></h1>
<h2 id="a-practical-guide-to-mask-based-data-profiling" class="unnumbered"><a class="header" href="#a-practical-guide-to-mask-based-data-profiling">A Practical Guide to Mask-Based Data Profiling</a></h2>
<p> </p>
<p> </p>
<p> </p>
<p><strong>Andrew Morgan</strong></p>
<p> </p>
<p> </p>
<p><em>First Edition — 2026</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copyright" class="unnumbered"><a class="header" href="#copyright">Copyright</a></h1>
<p><strong>Data Quality on Read: A Practical Guide to Mask-Based Data Profiling</strong></p>
<p>© 2026 Andrew Morgan</p>
<p>This work is licensed under the <strong>Creative Commons Attribution 4.0 International License</strong> (CC BY 4.0).</p>
<p>You are free to:</p>
<ul>
<li><strong>Share</strong> — copy and redistribute the material in any medium or format</li>
<li><strong>Adapt</strong> — remix, transform, and build upon the material for any purpose, including commercially</li>
</ul>
<p>Under the following terms:</p>
<ul>
<li><strong>Attribution</strong> — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.</li>
</ul>
<p>Full license text: <a href="https://creativecommons.org/licenses/by/4.0/">creativecommons.org/licenses/by/4.0</a></p>
<hr />
<p><strong>Author:</strong> Andrew Morgan<br />
<strong>Publisher:</strong> Andrew Morgan<br />
<strong>First edition:</strong> 2026</p>
<p><strong>Tools:</strong> <a href="https://dataradar.co.uk">dataradar.co.uk</a> · <a href="https://github.com/minkymorgan/bytefreq">github.com/minkymorgan/bytefreq</a><br />
<strong>Source:</strong> <a href="https://github.com/minkymorgan/DataQualityOnRead">github.com/minkymorgan/DataQualityOnRead</a><br />
<strong>Contact:</strong> <a href="mailto:andrew@gamakon.ai">andrew@gamakon.ai</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreword" class="unnumbered"><a class="header" href="#foreword">Foreword</a></h1>
<p>Every organisation that works with data eventually discovers the same uncomfortable truth: the data is not what the documentation says it is. The specification describes an ideal. The file contains reality. The gap between them is where projects stall, budgets overrun, and decisions go wrong.</p>
<p>In nearly two decades of building data platforms — across financial services, government, telecoms, and open data — I have seen this gap consume more time, money, and goodwill than any other single problem in data engineering. Not because the problem is hard to understand, but because the tools for discovering it have historically been slow, expensive, and assumption-heavy. You needed to know what you were looking for before you could look for it.</p>
<p>Mask-based profiling inverts that assumption. It asks no questions about the data. It makes no assumptions about what the data should contain. It simply translates every value into its structural fingerprint and counts the results. The dominant patterns tell you what the data is. The rare patterns tell you what has gone wrong. The technique is mechanical, deterministic, and fast — and it works on any data, in any language, at any scale.</p>
<p>This book describes the technique, the architecture that surrounds it, and the open-source tools that implement it. It is written for practitioners: data engineers, analysts, and anyone who has ever opened a file and wondered what they were looking at. The ideas are simple. The implementation is straightforward. The impact, in my experience, is transformative.</p>
<p>I hope you find it useful.</p>
<p><em>Andrew Morgan</em>
<em>February 2026</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction" class="unnumbered"><a class="header" href="#introduction">Introduction</a></h1>
<p>In 2007, while working on a data migration for a financial services client, we received a file that was described as containing customer addresses. The specification said the fields were fixed-width, ASCII-encoded, with UK postcodes in column 47. When we loaded the file and profiled it, we discovered that column 47 contained a mixture of valid postcodes, phone numbers, the string "N/A" repeated 11,000 times, and — in one memorable case — what appeared to be someone's lunch order.</p>
<p>The specification was wrong. Or rather, the specification described what the data <em>should</em> look like, and the file contained what the data <em>actually</em> looked like. These are not the same thing, and the gap between them is where data quality lives.</p>
<p>This experience, repeated in various forms across financial services, telecoms, government, and open data projects over nearly two decades, led to the development of a simple but surprisingly powerful technique: <strong>mask-based data profiling</strong>. The idea is straightforward. Take every character in a data field and translate it to its character class — uppercase letters become <code>A</code>, lowercase become <code>a</code>, digits become <code>9</code>, and everything else (punctuation, spaces, symbols) stays as it is. The result is a structural fingerprint of the value, a <em>mask</em>, that strips away the content and reveals the shape of the data underneath.</p>
<p>When you profile a column by counting the frequency of each mask, patterns emerge immediately. The dominant masks tell you what the data is supposed to look like. The rare masks — the long tail — tell you where the problems are hiding. No regex, no schema, no assumptions about the data required. Just a mechanical translation that lets the structure speak for itself.</p>
<p>This book describes that technique, the architecture around it, and the tools that implement it. The technique itself is called <strong>Data Quality on Read</strong> (DQOR), a deliberate parallel to the "Schema on Read" principle that underpins modern data lake architectures. The core idea is the same in both cases: accept raw data as-is, defer processing until the moment of consumption, and never overwrite the original. In the schema case, you defer structural interpretation. In the quality case, you defer profiling, validation, and remediation. The benefits are the same: agility, provenance, and the ability to reprocess history when your understanding improves.</p>
<p>The tools are <strong>bytefreq</strong>, an open-source command-line profiler now implemented in Rust, and <strong>DataRadar</strong>, a browser-based profiling tool that runs entirely client-side using WebAssembly. Both implement DQOR from the ground up, and both are free to use.</p>
<p>The book is structured in three parts. Part I sets out the problem: why data quality is hard, and why the traditional approaches — schema validation, statistical profiling, regex-based checks — leave gaps that mask-based profiling can fill. Part II introduces the technique in detail: masks, grain levels, Unicode handling, population analysis, error codes, and treatment functions. Part III describes the architecture that ties it all together: the flat enhanced format (a trick borrowed from Hadoop-era feature stores), and the tools that implement it at different scales.</p>
<p>The intended audience is anyone who works with data they did not create: data engineers, analysts, scientists, and the growing number of people who find themselves responsible for data quality without having chosen it as a career. The technique is simple enough to prototype in a single line of <code>sed</code>, and powerful enough to run in production at enterprise scale. We will cover the full range.</p>
<h2 id="discovery-before-exploration"><a class="header" href="#discovery-before-exploration">Discovery Before Exploration</a></h2>
<p>Before you profile the values in a field, you need to know what fields exist and how populated they are. This sounds obvious. It is obvious. And yet the most common mistake in data quality work is to dive straight into field-level analysis — examining the values in a column — without first understanding the shape of the dataset as a whole. Structure discovery comes before content exploration. Always.</p>
<p>For tabular data — CSV files, fixed-width extracts, pipe-delimited feeds — this means counting non-null values per column. If a dataset has 55 columns but only 20 of them are more than 50% populated, that fact alone reshapes your entire profiling strategy. You do not need to know <em>what</em> is in the other 35 columns yet. You need to know they are mostly empty. That knowledge takes seconds to acquire and saves hours of misdirected effort.</p>
<p>For nested data — JSON, XML, hierarchical formats — the same principle applies, but the discovery step is different. You walk the structure to find every field path, then count how many records contain each path. A JSON feed might have 200 distinct field paths, but any given record might populate only 40 of them. A field that appears in 10% of records tells you something important before you have looked at a single value. A field that appears in 100% of records tells you something different. The population profile across all paths is the first thing you need, and the last thing most people think to check.</p>
<p>Think of it as a census before a survey. The census maps the territory: what exists, where it is, how much of it there is. The survey examines individual items in detail. Running the survey without the census means you do not know what you are missing, what you are over-sampling, or where your effort is best spent. The field population profile is the map. Profile without it and you are navigating blind.</p>
<p>This principle prevents wasted effort in both directions. Profiling a field that is 99% empty is rarely the best use of your time — you will generate a mask frequency table dominated by a single empty-value pattern and learn almost nothing. Conversely, discovering that a field described as "mandatory" in the specification is only 45% populated is itself a significant data quality finding — and you found it in the discovery phase, before spending any time on content analysis. Some of the most valuable insights come from the map, not from the territory it describes.</p>
<p>The worked examples in this book follow this principle explicitly. Each begins with a structure discovery phase — field counts, population rates, structural metadata — before moving to field-by-field mask analysis. This is not a stylistic choice. It is the method. Discovery before exploration, every time.</p>
<h2 id="data-quality-without-borders"><a class="header" href="#data-quality-without-borders">Data Quality Without Borders</a></h2>
<p>The world's largest generators and consumers of data are in the public sector. Central, regional, and local governments manage millions of data transfers across ministerial boundaries every day. This separation of concerns makes government the single largest environment where Data Quality on Read is most urgently needed.</p>
<p>The stakes are high. "Single view of citizen" systems help governments deliver better services and ensure people do not fall between the cracks. But building these views requires integrating data from systems that were never designed to talk to each other, encoded in formats nobody fully documented. And because the data is personally identifiable, access to view raw records is rightly restricted — making data quality work uniquely difficult. You need to understand structure and quality without seeing content. This is where mask-based profiling shines: a mask reveals the shape of the data without exposing whose data it is.</p>
<p>The 33 languages in DataRadar's first tier of localisation — from English and French to Amharic, Hausa, Swahili, Tamil, Nepali, and Chinese — cover approximately 5.5 billion citizens. Data quality tools have historically supported only English interfaces and Latin-script datasets. A civil servant in Addis Ababa profiling census data in Amharic, or a local government analyst in Lagos working with Hausa-language records, had no tools built for them. DataRadar and bytefreq are.</p>
<p>All citizens deserve effective government services, and data quality is a prerequisite for delivering them. Multilingual, privacy-first, zero-install tools that work across scripts, languages, and borders — that is the ambition.</p>
<h2 id="from-files-to-services"><a class="header" href="#from-files-to-services">From Files to Services</a></h2>
<p>The techniques in this book can profile a single file in seconds. But the real prize is bigger than files.</p>
<p>Consider a government department that receives data from dozens of external collectors — local councils, NHS trusts, schools, partner agencies — and publishes onward to downstream consumers. How does a Chief Data Officer know whether the department is producing good quality data? How does a CTO assure the service, not just individual datasets?</p>
<p>The answer is to treat data quality profiling as <strong>infrastructure</strong>, not as a one-off activity. The building blocks described in this book — mask-based profiling, the flat enhanced format, population analysis, assertion rules — are designed to assemble into a monitoring architecture that can assure an entire data service.</p>
<p>The pattern has two sides.</p>
<p><strong>Exit checks</strong> run at the point of production. Before a department publishes a data feed, the profiling engine runs against the output and generates a quality report — mask distributions, population rates, character encoding composition, assertion rule results. This report is stored as a timestamped fact record. Over weeks and months, a timeseries builds up: a continuous measurement of what the department is actually shipping.</p>
<p><strong>Entrance checks</strong> run at the point of consumption. When a downstream system receives a data feed, the same profiling engine runs against the input. The entrance report is compared against the expected baseline (derived from the exit checks or from an agreed specification). Deviations are flagged. New masks appearing, population rates dropping, encoding shifts — all are detected automatically, before the data enters the consumer's pipeline.</p>
<p>Between these two checkpoints, something powerful emerges: <strong>line of sight</strong>. When a downstream system encounters a quality issue, the entrance check report traces it back to the feed. The feed's exit check report traces it back to the collector. The timeseries shows when the problem started. Connected to lineage tools that track data flow across systems, this creates an automated root cause analysis — not "something is wrong somewhere" but "this specific field in this specific feed from this specific collector started producing a new mask pattern on this date, and the downstream impact is quantifiable."</p>
<p>That quantification matters. When you can say "Department X's data collection issues caused 2,000 downstream failures last quarter, costing an estimated £Y million in rework, delayed decisions, and incorrect outputs," the conversation changes. Quality stops being an abstract concern and becomes a line item. The timeseries is the measuring stick that makes consistent performance conversations possible — not blame, but evidence.</p>
<p>This reframes the purpose of data quality. The traditional question is: "Is this data fit for purpose?" — meaning, can the immediate consumer use it? The better question is: <strong>"Is this data fit for the journey?"</strong> Data rarely has one consumer. A dataset collected by a local council may pass through a regional aggregator, a central government platform, a statistical publication pipeline, and a public API before reaching its final consumers. Quality at the point of collection is not enough if the data degrades, is misinterpreted, or hits structural incompatibilities at any stage of that journey. Fit for the journey means the data carries enough structural metadata — masks, population profiles, assertion results — to be understood and validated at every stage, by every hand it passes through.</p>
<p>The profiling reports described in this book — both the DQ mask frequency tables and the CP character profiling reports — are the raw telemetry for this monitoring architecture. They are structured, machine-readable, and designed to be stored and queried as fact tables. The technical implementation — time-partitioned directories, DuckDB queries, KPI dashboards — is covered in the Quality Monitoring chapter in Part III.</p>
<p>The tools in Part III are the building blocks. The architecture they enable is a data quality assurance service: continuous, measurable, and accountable.</p>
<p>Let's begin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-data-quality-still-breaks-things"><a class="header" href="#why-data-quality-still-breaks-things">Why Data Quality Still Breaks Things</a></h1>
<p>There is a widely cited statistic that poor data quality costs organisations between 15 and 25 percent of revenue. The number has been repeated so often that it has become background noise, the kind of thing people nod at in presentations and then promptly ignore when scoping their next project. The reason it persists, despite everyone knowing about it, is structural: most data quality problems are invisible until they cause a failure downstream, and by then the cost of remediation is orders of magnitude higher than the cost of early detection.</p>
<p>Consider a simple example. A retail company receives a daily feed of product catalogue updates from a supplier. The feed is a CSV file, delivered via SFTP, containing product codes, descriptions, prices, and stock levels. The specification says prices are in GBP, formatted as decimal numbers with two decimal places. For six months the feed arrives on time, the prices parse correctly, and everyone is happy. Then one Monday the supplier's system is upgraded, and the price field starts arriving with a currency symbol prefix — <code>£12.99</code> instead of <code>12.99</code>. The downstream pricing engine, which casts the field to a numeric type, throws a parse error. The product catalogue goes stale. Customer-facing prices are wrong for four hours until someone notices and writes a hotfix.</p>
<p>The fix takes ten minutes. The investigation takes two hours. The post-incident review takes half a day. The customer complaints take a week to resolve. The root cause was a single character in a single field, and the total cost — in engineering time, reputational damage, and operational disruption — was wildly disproportionate to the simplicity of the underlying issue.</p>
<p>This pattern repeats across every industry that depends on data received from sources it does not control. The specific failures vary — date formats flip between <code>DD/MM/YYYY</code> and <code>MM/DD/YYYY</code>, encoding shifts from UTF-8 to Latin-1, a column that was always numeric starts containing the string <code>NULL</code> instead of an actual null — but the shape of the problem is always the same. Data that was assumed to be clean turns out not to be, and the assumption is only tested at the point of failure.</p>
<h2 id="the-read-problem"><a class="header" href="#the-read-problem">The Read Problem</a></h2>
<p>Most data quality tooling is designed around the assumption that you control the data pipeline end to end. Schema validation at the point of entry, constraint enforcement in the database, type checking in the application layer — these are all "quality on write" techniques, and they work well when you are the author of the data. The difficulty arises when you are the <em>reader</em> rather than the writer.</p>
<p>In modern data architectures, the proportion of data that arrives from sources you do not control is substantial and growing. Third-party feeds, partner integrations, open data portals, scraped web content, legacy system exports, IoT sensor streams, and API responses from services maintained by other teams — all of these represent data that was created according to someone else's assumptions, documented (if at all) according to someone else's standards, and delivered with whatever level of quality the source system happened to produce that day.</p>
<p>You cannot fix the source. In many cases you cannot even influence it. What you can do is understand what you have received, quickly and cheaply, before you attempt to use it. That understanding — structural, not semantic — is the domain of Data Quality on Read.</p>
<h2 id="what-goes-wrong"><a class="header" href="#what-goes-wrong">What Goes Wrong</a></h2>
<p>In working with data platforms across financial services, telecoms, government, and open data projects, we have seen the same categories of data quality failure appear repeatedly. They are worth enumerating because they inform the design of the profiling techniques that follow.</p>
<p><strong>Format inconsistency</strong> is the most common. A date column contains values in three or four different formats — <code>2024-01-15</code>, <code>15/01/2024</code>, <code>Jan 15 2024</code>, and occasionally just <code>2024</code> — because the upstream system aggregated data from multiple sources without normalising it. A phone number column mixes UK mobile (<code>07700 900123</code>), international (<code>+44 7700 900123</code>), US (<code>(555) 123-4567</code>), and free-text entries like <code>"ask for Dave"</code>. Each of these is individually valid; the problem is that they coexist in the same column with no indicator of which format applies to which record.</p>
<p><strong>Encoding corruption</strong> is subtler and often goes undetected for longer. A file that was encoded in Latin-1 is read as UTF-8, producing garbled characters in names and addresses. A BOM marker at the start of a CSV causes the first column header to parse incorrectly. Control characters — tabs, carriage returns, null bytes — appear in fields that should contain only printable text, breaking downstream parsers that assumed simple delimited input.</p>
<p><strong>Structural drift</strong> happens when the shape of the data changes over time without corresponding updates to the documentation or the downstream systems that consume it. A new column is added to a feed, shifting all subsequent field positions. An optional field starts being populated where it was previously always empty, triggering unexpected code paths. A field that was always a single value starts containing comma-separated lists.</p>
<p><strong>Placeholder abuse</strong> is endemic. The strings <code>N/A</code>, <code>NULL</code>, <code>none</code>, <code>n/a</code>, <code>-</code>, <code>TBC</code>, <code>unknown</code>, <code>test</code>, and the empty string all appear in production data as substitutes for missing values, each encoded differently, each requiring different handling, and none of them matching the expected format of the field they occupy. In one government dataset we profiled, the placeholder <code>REDACTED</code> appeared in the postcode field of 3% of records, which was useful to know before attempting geocoding.</p>
<p><strong>Population shifts</strong> are the hardest to detect without profiling. The data looks structurally correct — all the fields parse, all the types are right — but the distribution has changed. A column that previously had 99.5% population now has 15% nulls because an upstream collection process was turned off. A field that used to contain 8 distinct values now contains 47, because a system migration expanded the code set without updating the documentation.</p>
<p>None of these problems are exotic. They are the ordinary, everyday reality of working with data that someone else created. The question is not whether they exist in your data — they almost certainly do — but whether you have a systematic way of finding them before they cause harm.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-limits-of-traditional-approaches"><a class="header" href="#the-limits-of-traditional-approaches">The Limits of Traditional Approaches</a></h1>
<p>Before introducing mask-based profiling, it is worth understanding why the existing approaches leave gaps. Not because they are bad — many of them are excellent at what they do — but because they share a common assumption that limits their applicability to the "quality on read" problem.</p>
<h2 id="schema-validation"><a class="header" href="#schema-validation">Schema Validation</a></h2>
<p>The most established approach to data quality is schema validation: define the expected types, formats, and constraints for each field, then reject or flag records that do not conform. This is the approach used by database constraints, JSON Schema, XML Schema (XSD), Avro, Protobuf, and a host of other technologies. It works well in systems where you control the schema and the data is produced by software that respects it.</p>
<p>The limitation is that schema validation requires you to know what the data should look like before you receive it. When you are exploring a new dataset — a third-party feed you have never seen before, an open data portal with sparse documentation, or a legacy system export where the specification was written ten years ago and has not been updated since — the schema is precisely the thing you are trying to discover. Validating against an assumed schema at this stage risks either rejecting valid data that does not match your assumptions, or accepting invalid data that happens to pass your checks by coincidence.</p>
<p>There is also the problem of data that is "technically valid" but semantically broken. A date field containing <code>0000-00-00</code> will pass a format check for <code>YYYY-MM-DD</code> but is clearly not a real date. A numeric field containing <code>999999</code> will pass a type check but may be a sentinel value meaning "not applicable." Schema validation catches structural violations but tells you nothing about whether the values themselves make sense.</p>
<h2 id="statistical-profiling"><a class="header" href="#statistical-profiling">Statistical Profiling</a></h2>
<p>Tools like Great Expectations, dbt tests, and pandas-profiling take a different approach: compute summary statistics for each column (null counts, min/max values, cardinality, distributions, standard deviations) and flag deviations from expected ranges. This is useful for ongoing monitoring of data pipelines where you have a baseline to compare against, and it catches population-level issues (sudden spikes in nulls, unexpected changes in cardinality) that schema validation misses.</p>
<p>The limitation is that aggregate statistics hide structural detail. A column with 99% valid email addresses and 1% phone numbers will report a cardinality, a null rate, and a string length distribution that all look reasonable. The phone numbers — wrong data in the wrong field — will not appear as outliers in any statistical measure because they are structurally similar to emails in terms of length and character composition. You need to see the <em>patterns</em> to spot the problem, and summary statistics do not show patterns.</p>
<p>Statistical methods also require a baseline: they tell you that something has changed, but not what the data looks like in the first place. For initial exploration of an unfamiliar dataset, they give you numbers without context.</p>
<h2 id="regex-based-validation"><a class="header" href="#regex-based-validation">Regex-Based Validation</a></h2>
<p>Regular expressions allow precise format validation: a UK postcode matches <code>[A-Z]{1,2}[0-9R][0-9A-Z]? [0-9][ABD-HJLNP-UW-Z]{2}</code>, an email matches a well-known (and notoriously complex) pattern, a date matches <code>\d{4}-\d{2}-\d{2}</code>. When you know exactly what formats to expect, regex validation is powerful and precise.</p>
<p>The limitation is combinatorial. Each expected format requires its own expression. A phone number column that contains UK mobiles, UK landlines, international numbers with country codes, and US-formatted numbers needs at least four regex patterns — and that is before you account for variations in spacing, punctuation, and prefix formatting. For every new format you discover, you write another regex. For every field in every dataset, you maintain a library of patterns. The approach does not scale to exploratory work where you do not yet know what formats exist.</p>
<p>More fundamentally, regex validation is a <em>confirmation</em> technique: it confirms that data matches a pattern you already know about. It does not help you <em>discover</em> what patterns exist in data you have never seen before. Discovery requires a different tool.</p>
<h2 id="what-they-all-share"><a class="header" href="#what-they-all-share">What They All Share</a></h2>
<p>All three approaches — schema validation, statistical profiling, and regex-based validation — share a common assumption: <strong>you already know what the data should look like</strong>. They are verification techniques, designed to confirm expectations. When those expectations are correct and the data is well-understood, they work beautifully.</p>
<p>The gap they leave is in <em>discovery</em>: the initial exploration of unfamiliar data, where you have no schema, no baseline statistics, and no library of expected formats. You need something that will show you what the data <em>does</em> look like, without requiring you to tell it what to look <em>for</em>. That is the role of mask-based profiling.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema-on-read-quality-on-read"><a class="header" href="#schema-on-read-quality-on-read">Schema on Read, Quality on Read</a></h1>
<p>The idea of deferring structural interpretation until the point of consumption is well established in data architecture. In the Hadoop era, it acquired a name — <strong>Schema on Read</strong> — and it changed how large-scale data platforms were designed. Rather than enforcing a rigid schema at the point of ingest (Schema on Write, the relational database approach), data lakes accept raw data in whatever format it arrives, store it cheaply, and apply structural interpretation only when a consumer reads the data for a specific purpose.</p>
<p>The benefits of Schema on Read are widely understood. Raw data is preserved in its original form, providing provenance and auditability. Multiple consumers can apply different schemas to the same underlying data, supporting different use cases without duplicating pipelines. When schemas change — and they always change — historical data does not need to be reprocessed, because the raw material is still there. The trade-off is that consumers bear the cost of interpretation, but in practice this cost is modest compared to the flexibility gained.</p>
<p><strong>Data Quality on Read</strong> (DQOR) applies exactly the same principle to data quality processing. Instead of cleansing, validating, enriching, and remediating data at the point of ingest — which requires perfect upfront knowledge of the data, slows pipeline velocity, and risks overwriting original values with incorrect corrections — DQOR defers all quality processing until the moment the data is actually consumed.</p>
<p>The core workflow is simple:</p>
<ol>
<li>Ingest raw data as fast as possible, preserving it exactly as received.</li>
<li>At read time, profile the data to discover its structural characteristics.</li>
<li>Generate quality metadata (masks, assertions, suggested treatments) alongside the raw values.</li>
<li>Let downstream consumers choose which treatments to apply — or to ignore them entirely and work with the original.</li>
</ol>
<p>The raw data is never overwritten. The quality metadata is never mandated. Consumers see both the original value and the profiler's assessment of it, and they make their own decisions about what to trust. This is a fundamental design choice: <strong>suggestions, never mandates</strong>.</p>
<h2 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h2>
<p>There are several practical reasons why deferring quality processing to read time is advantageous, particularly for data received from external sources.</p>
<p>First, it preserves the original data as an immutable audit trail. In regulated industries (financial services, healthcare, government), the ability to trace a derived value back to the exact bytes that were received from the source system is not a convenience — it is a compliance requirement. DQOR provides this by construction, because the raw data is never modified.</p>
<p>Second, it accommodates imperfect knowledge. When you first receive a new data feed, you rarely understand it fully. The documentation may be incomplete, the specification may be out of date, and the actual data may contain patterns that nobody anticipated. If you apply quality rules at ingest time based on incomplete understanding, you risk discarding or corrupting valid data. By deferring quality processing, you give yourself time to learn the data before committing to a treatment strategy — and when your understanding improves, you can reprocess the history without re-ingesting it.</p>
<p>Third, it supports multiple consumers with different quality requirements. A data science team exploring patterns in raw sensor data may want the original values, noise and all. A reporting team feeding a customer-facing dashboard may want aggressively cleaned and normalised data. A compliance team may want to see every record that was flagged as anomalous, with the raw value alongside the flag. DQOR supports all three from the same source, without separate pipelines.</p>
<p>Fourth, it decouples ingest velocity from quality processing. Data acquisition pipelines can focus on reliability and throughput — landing data on the platform as fast as the source can deliver it — without being slowed by the computational overhead of profiling, validation, and remediation. Quality processing happens later, on the consumer's schedule, using the consumer's compute budget. In streaming architectures, where latency matters, this decoupling is particularly valuable.</p>
<h2 id="the-parallel-with-feature-stores"><a class="header" href="#the-parallel-with-feature-stores">The Parallel With Feature Stores</a></h2>
<p>For anyone who has worked with machine learning feature stores, the DQOR pattern will feel familiar. A feature store holds pre-computed features alongside the raw data they were derived from, so that model-serving pipelines can retrieve prediction-ready inputs without recomputing them at request time. The raw data is never discarded; the features are additive layers that sit alongside it.</p>
<p>DQOR follows the same structural logic. The raw value is preserved. Quality metadata — masks, assertions, suggested treatments — are generated as additional columns that sit alongside the raw value in the same row. Downstream consumers select the columns they need. Adding a new quality check or a new treatment is just adding another column; it never touches the original data, and it never requires reprocessing existing outputs.</p>
<p>The enhanced output is a nested record format — each field in the original data becomes a JSON object containing the raw value, its masks, and any inferred rules. The <em>flat enhanced format</em> takes this a step further: a flattened key-value pair schema, sourced from nested data (e.g. <code>fieldname.raw</code>, <code>fieldname.HU</code>, <code>fieldname.Rules.is_numeric</code>). Quality metadata travels with the data it describes — no joins, no lookups, no separate tables. We will return to the specific implementation of this pattern in Chapter 9.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mask-based-profiling"><a class="header" href="#mask-based-profiling">Mask-Based Profiling</a></h1>
<p>A mask, in the context of data profiling, is a transformation function applied to a string that generalises the value into a structural fingerprint. The transformation replaces every character with a symbol representing its character class, while preserving punctuation and whitespace. When a column of data is summarised by counting the frequency of each resulting mask — a process commonly called <em>data profiling</em> — it reveals the structural patterns hiding inside the data, quickly and without assumptions.</p>
<p>The basic translation is as follows:</p>
<ul>
<li>Uppercase letters (<code>A</code>–<code>Z</code>) are replaced with <code>A</code></li>
<li>Lowercase letters (<code>a</code>–<code>z</code>) are replaced with <code>a</code></li>
<li>Digits (<code>0</code>–<code>9</code>) are replaced with <code>9</code></li>
<li>Everything else — punctuation, spaces, symbols — is left unchanged</li>
</ul>
<p>It seems like a very simple transformation at first glance. To see why it is useful, consider applying it to a column of data that is documented as containing domain names. We expect values like <code>nytimes.com</code>. Applying the mask, we get:</p>
<pre><code>   232  aaaa.aaa
   195  aaaaaaaaaa.aaa
   186  aaaaaa.aaa
   182  aaaaaaaa.aaa
   168  aaaaaaa.aaa
   167  aaaaaaaaaaaa.aaa
   167  aaaaa.aaa
   153  aaaaaaaaaaaaa.aaa
</code></pre>
<p>Very quickly, the mask reduces thousands of unique domain names down to a short list of structural patterns — all of which look like domain names, confirming our expectation. But what about the long tail? The rare masks that appear only a handful of times?</p>
<pre><code>     2  AAA Aa
     1  a.99a.a
     1  9a9a.a
</code></pre>
<p>There is a mask — <code>AAA Aa</code> — that does not contain a dot, which we would expect in any domain name. This immediately stands out as structurally different from the rest. When we use the mask to retrieve the original values, we find the text <code>BBC Monitoring</code> — not a domain name at all, but a general descriptor that someone has used in a field designed for domain names. In re-reading the GDELT documentation we discover that this is not an error but a known special case, meaning when we use this field we must handle it. Perhaps we include a correction rule to swap the string for the valid domain <code>www.monitor.bbc.co.uk</code>, which is the actual source.</p>
<p>A second example, from real UK Companies House data, shows what happens when a field contains data from the wrong column entirely. The <code>RegAddress.PostTown</code> field — the registered office town — produces dozens of masks at LU grain. The dominant patterns are all legitimate town names: <code>A</code> (single words like <code>READING</code>, 84.2%), <code>A A</code> (two words like <code>HEBDEN BRIDGE</code>, 6.3%), and several hyphenated or abbreviated forms. But in the long tail:</p>
<pre><code>Mask        Count   Example
A9 9A          14   EH47 8PG
9 A A          32   150 HOLYWOOD ROAD
9-9 A A        10   1-7 KING STREET
9A A            1   2ND FLOOR
9               2   20037
</code></pre>
<p>Postcodes in the town field. Street addresses in the town field. A US ZIP code. A floor number. The masks expose column misalignment that no town-name validation rule would detect — because <code>EH47 8PG</code> is a perfectly valid string, just in the wrong column. The mask <code>A9 9A</code> in a town field is diagnostic: towns do not have that structure, but postcodes do. (For the complete field-by-field analysis of this dataset, see the Worked Example: Profiling UK Companies House Data appendix.)</p>
<p>The idea we are introducing here is that a mask can be used as a <em>key</em> to retrieve records of a particular structural type from a particular field. Before we explore that idea further (it leads directly to the concept of masks as error codes, covered in Chapter 7), it is worth understanding the mechanics of the mask itself in more detail.</p>
<h2 id="why-masks-work"><a class="header" href="#why-masks-work">Why Masks Work</a></h2>
<p>The power of mask-based profiling comes from a simple mathematical property: the mask function is a <em>many-to-one</em> mapping that dramatically reduces cardinality while preserving structural information. A column of ten million customer names might contain two million unique values, but after masking it might contain only a few hundred unique patterns. A column of phone numbers with a million unique values might collapse to a dozen structural formats.</p>
<p>This cardinality reduction is what makes manual inspection feasible. No human can review two million unique names, but anyone can scan a frequency table of two hundred masks and immediately identify the dominant patterns and the outliers. The mask strips away the <em>content</em> (the specific name, the specific number) and reveals the <em>shape</em> (the format, the structure, the encoding).</p>
<p>Consider a customer name column:</p>
<div class="table-wrapper"><table><thead><tr><th>Original Value</th><th>Mask</th></tr></thead><tbody>
<tr><td><code>John Smith</code></td><td><code>Aaaa Aaaaa</code></td></tr>
<tr><td><code>JOHN SMITH</code></td><td><code>AAAA AAAAA</code></td></tr>
<tr><td><code>john smith</code></td><td><code>aaaa aaaaa</code></td></tr>
<tr><td><code>O'Brien</code></td><td><code>A'Aaaaa</code></td></tr>
<tr><td><code>Jean-Pierre</code></td><td><code>Aaaa-Aaaaaa</code></td></tr>
<tr><td><code>12345</code></td><td><code>99999</code></td></tr>
<tr><td><code>N/A</code></td><td><code>A/A</code></td></tr>
</tbody></table>
</div>
<p>From the masks alone, without looking at the values, we can see: most records are capitalised names (<code>Aaaa Aaaaa</code>), some are in all-caps or all-lowercase (normalisation candidates), some contain apostrophes or hyphens (legitimate but structurally distinct), one is numeric (almost certainly an error — a customer ID in a name field), and one is a placeholder. The mask gives us a <em>classification of structural types</em> in a single pass.</p>
<p>A worked example from the French lobbyist registry illustrates this vividly. The first name field (<code>dirigeants.prenom</code>) produces four masks at LU grain:</p>
<pre><code>Mask        Count   Example
Aa            697   Carole
Aa-Aa          50   Marc-Antoine
Aa Aa          11   Marie Christine
Aa_a            1   Ro!and
</code></pre>
<p>The first three are expected: simple names, hyphenated compounds (common in French), and space-separated compounds. The fourth is the standout: <code>Aa_a</code> — one record where <code>Ro!and</code> contains an exclamation mark where the letter <code>l</code> should be. The intended name is <code>Roland</code>, but a data entry error has replaced a letter with adjacent punctuation. No schema would catch this — the field is a valid string. No length check would catch it — six characters is reasonable. But the mask catches it instantly because <code>!</code> is punctuation, not a letter, and the structural pattern is fundamentally different from every other value in the field. (For the full analysis, see the Worked Example: Profiling the French Lobbyist Registry appendix.)</p>
<h2 id="prototyping-on-the-command-line"><a class="header" href="#prototyping-on-the-command-line">Prototyping on the Command Line</a></h2>
<p>One of the virtues of mask-based profiling is that it can be prototyped with standard Unix tools in a single line:</p>
<pre><code class="language-bash">cat data.csv | gawk -F"\t" '{print $4}' | \
  sed "s/[0-9]/9/g; s/[a-z]/a/g; s/[A-Z]/A/g" | \
  sort | uniq -c | sort -r -n | head -20
</code></pre>
<p>This extracts column 4 from a tab-delimited file, applies the A/a/9 mask using <code>sed</code>, sorts the results, counts unique masks, and displays the top 20 by frequency. It runs in seconds on files with millions of rows, and the output is immediately interpretable. We open-sourced a more fully-featured version of this profiler — called <strong>bytefreq</strong> (short for <em>byte frequencies</em>) — originally written in awk, and later rewritten in Rust. The awk version is available for readers who want to understand the mechanics; the Rust version is what you would use in production. Both are discussed in Chapter 10.</p>
<p>The ability to prototype the technique in a one-liner is important not because the one-liner is a production tool, but because it demonstrates that the underlying idea is genuinely simple. There is no machine learning, no complex configuration, no training data. It is a mechanical character-by-character translation followed by a frequency count. The power comes not from the complexity of the method but from the <em>interpretability of the output</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grain-scripts-and-character-classes"><a class="header" href="#grain-scripts-and-character-classes">Grain, Scripts, and Character Classes</a></h1>
<p>The basic A/a/9 mask described in the previous chapter works well for ASCII data and covers the majority of use cases in structured data profiling. But real-world data — particularly data sourced from open data portals, international organisations, and multilingual systems — contains characters that the simple ASCII mask cannot adequately describe. Accented characters, CJK ideographs, Arabic script, Devanagari, Cyrillic, Thai, Ethiopic, and increasingly emoji all appear in production datasets, and a profiler that treats them all as "other" is losing information.</p>
<p>This chapter introduces two extensions to the basic mask: <strong>grain levels</strong>, which control the resolution of the mask, and <strong>Unicode-aware character class translation</strong>, which extends masking across the full range of human writing systems.</p>
<h2 id="high-grain-and-low-grain"><a class="header" href="#high-grain-and-low-grain">High Grain and Low Grain</a></h2>
<p>A high grain mask preserves the exact length and position of every character in the original value. Every character maps individually, so <code>John Smith</code> becomes <code>Aaaa Aaaaa</code> and <code>Jane Doe</code> becomes <code>Aaaa Aaa</code>. These are two different masks, because the strings have different lengths.</p>
<p>A low grain mask collapses consecutive runs of the same character class into a single symbol. Under low grain masking, <code>John Smith</code> becomes <code>Aa Aa</code>, and <code>Jane Doe</code> also becomes <code>Aa Aa</code>. The two values now share the same mask, because at the low grain level they have the same structure: a capitalised word followed by a space followed by another capitalised word.</p>
<p>The distinction matters because the two grain levels serve different purposes.</p>
<p><strong>Low grain</strong> is the tool for discovery. When you first encounter an unfamiliar dataset and want to understand the structural families present in a column, low grain masking collapses millions of unique values into a handful of patterns. A name column that produces thousands of unique high grain masks (varying by name length) might produce only four or five low grain masks: <code>Aa Aa</code> (first name, last name), <code>Aa A. Aa</code> (with middle initial), <code>Aa</code> (single name), <code>9</code> (numeric — investigate), and <code>A/A</code> (placeholder). This immediate simplification makes the data comprehensible at a glance.</p>
<p>The effect is dramatic with non-Latin scripts. When profiling Japanese earthquake data from JMA, the hypocenter name field — containing kanji place names of varying length and composition — collapses entirely to a single mask at LU grain:</p>
<pre><code>Mask    Count   Example
a          78   福島県会津
a_a         1   (compound name with punctuation)
</code></pre>
<p>78 of 79 values produce the same mask: <code>a</code>. Every CJK ideograph is classified as a lowercase letter (Unicode category Lo), and low grain collapses consecutive characters of the same class. A four-character name and an eight-character name are structurally identical at this grain. That one exception — <code>a_a</code>, a name containing a punctuation separator — stands out immediately. At HU grain, these 78 records would produce dozens of distinct masks varying by character count. At LU grain, you see the structural family at a glance. (See the Worked Example: Profiling JMA Earthquake Data appendix for the full analysis.)</p>
<p><strong>High grain</strong> is the tool for precision. Once you have identified the structural families using low grain, you can drill into a specific family with high grain masking to see the exact formats. For a postcode column, low grain might tell you that most values match <code>AA9 9AA</code> (low grain: <code>A9 9A</code>). High grain will tell you that you have <code>AA99 9AA</code>, <code>A99 9AA</code>, <code>A9 9AA</code>, <code>AA9 9AA</code>, and <code>AA9A 9AA</code> — the five standard UK postcode formats — each with its own frequency, allowing you to verify completeness and detect anomalies.</p>
<p>A subtler example of when HU grain is needed comes from the French lobbyist registry. The title field (<code>dirigeants.civilite</code>) contains <code>M</code> (Monsieur) and <code>MME</code> (Madame). At LU grain, both collapse to <code>A</code> — a single mask covering all 760 values, suggesting perfect uniformity. At HU grain, <code>M</code> produces <code>A</code> and <code>MME</code> produces <code>AAA</code>, cleanly separating the two populations. The LU profile tells you the field is consistently alphabetic. The HU profile tells you there are exactly two formats and what they are. The choice of grain determines the question you are answering. (See the Worked Example: Profiling the French Lobbyist Registry appendix.)</p>
<p>The typical workflow is a two-pass approach: start with low grain to survey the landscape, then switch to high grain to examine specific areas of interest. This mirrors how experienced data engineers actually work — broad scan first, targeted investigation second — and the two grain levels formalise that workflow into the tool.</p>
<h2 id="unicode-character-classes"><a class="header" href="#unicode-character-classes">Unicode Character Classes</a></h2>
<p>The original bytefreq implementation, written in awk and designed for ASCII data, mapped characters byte-by-byte. Each byte (0–255) was assigned a character class based on its position in the ASCII table, and the mapping was deterministic regardless of the encoding of the input. This had the pragmatic advantage of working consistently on any input — including binary data and files with mixed or unknown encodings — because it made no assumptions about what the bytes represented. It was, deliberately, a byte-level tool.</p>
<p>As the world has moved to Unicode, the byte-level approach needed extending. Modern datasets contain text in dozens of scripts, and a useful profiler needs to handle them without requiring language-specific configuration. The current implementations — both the Rust-based bytefreq CLI and the WebAssembly-based DataRadar browser tool — support Unicode-aware masking at two levels, which we call <strong>HU</strong> (High Unicode) and <strong>LU</strong> (Low Unicode), extending the high/low grain concept into the Unicode space.</p>
<p>Under Unicode-aware masking, the character class translation uses the Unicode General Category to determine how each character is mapped:</p>
<ul>
<li><strong>Lu</strong> (Letter, uppercase) → <code>A</code></li>
<li><strong>Ll</strong> (Letter, lowercase) → <code>a</code></li>
<li><strong>Lt</strong> (Letter, titlecase) → <code>A</code></li>
<li><strong>Lo</strong> (Letter, other — CJK ideographs, Arabic, Thai, etc.) → <code>a</code></li>
<li><strong>Nd</strong> (Number, decimal digit) → <code>9</code></li>
<li><strong>Punctuation categories</strong> (Pc, Pd, Pe, Pf, Pi, Po, Ps) → kept as-is</li>
<li><strong>Symbol categories</strong> (Sc, Sk, Sm, So) → kept as-is</li>
<li><strong>Separator categories</strong> (Zs, Zl, Zp) → kept as-is</li>
</ul>
<p>This means that a Chinese place name like 北京饭店 (Beijing Hotel) produces a mask of <code>aaaa</code> (four Lo characters, each mapped to <code>a</code>), an Arabic address produces <code>a a a</code> preserving the spaces between words, and an Icelandic name like Jökulsárlón produces <code>Aaaaaaaaaa</code> — preserving the capitalisation structure even though the accented characters are outside the basic ASCII range.</p>
<p>The practical benefit is that profiling works across scripts without configuration. When profiling a global places dataset containing names in Chinese, Thai, Arabic, Cyrillic, Devanagari, Ethiopic, and Latin scripts, the profiler does not need to be told which languages to expect. It uses the Unicode category of each character to generate masks that preserve structure, and the frequency analysis surfaces the dominant patterns regardless of script.</p>
<h2 id="script-detection"><a class="header" href="#script-detection">Script Detection</a></h2>
<p>In addition to mask generation, both DataRadar and bytefreq perform automatic script detection per field, reporting the dominant scripts found in each column. This is implemented by examining the Unicode script property of each character and aggregating across all values in the field.</p>
<p>Script detection serves two purposes. First, it flags potential encoding issues: a column that is expected to contain Latin-script names but reports a significant minority of Cyrillic characters may have an encoding corruption (Cyrillic and Latin share visual forms for several characters, and mojibake — text decoded with the wrong character set — often manifests as unexpected script mixing). Second, it informs downstream processing: a column containing mixed Latin and Arabic text may need bidirectional text handling, which is worth knowing before it breaks a downstream rendering system.</p>
<h2 id="character-profiling"><a class="header" href="#character-profiling">Character Profiling</a></h2>
<p>Character Profiling — CP mode — is a complementary technique to mask profiling. Where mask profiling translates each character to its class (A, a, 9) and counts the frequency of the resulting masks, CP mode counts the actual characters — the literal Unicode code points — present in a field. The question it answers is different: not "what structures exist in this data?" but "what characters actually appear in this data?"</p>
<p>This distinction is particularly revealing for non-Latin scripts. When profiling Japanese earthquake data from JMA (the Japan Meteorological Agency), CP mode revealed the presence of full-width digits (０, １, ２, ３ and so on) alongside standard ASCII digits (0, 1, 2, 3). At LU grain, both full-width and ASCII digits map to <code>9</code>, so mask profiling alone cannot distinguish them — the masks are identical. CP mode surfaces the actual character inventory, making the mixing of digit forms immediately visible.</p>
<p>CP mode is equally powerful for detecting encoding anomalies. Consider a field that should contain French accented characters — é, è, ê, ç, à — but whose character inventory also includes Â, Ã, or the sequence Â©. Those are the telltale signatures of mojibake: UTF-8 byte sequences that have been decoded as Latin-1 (or Windows-1252). The multi-byte UTF-8 encoding of é (0xC3 0xA9) becomes Ã© when misinterpreted as two single-byte Latin-1 characters. The character inventory is the diagnostic — you do not need to write encoding-specific validation rules, because the wrong characters simply show up in the profile.</p>
<p>The practical workflow is straightforward: run mask profiling first to understand the structural patterns in your data, then run CP mode on fields where the character inventory matters. Names, addresses, free-text descriptions, any field where you suspect encoding issues or script mixing — these are the candidates. Mask profiling tells you the shape; CP mode tells you the alphabet.</p>
<p>CP mode output is itself a frequency table — character, count, percentage — ordered by frequency. Like mask profiles, it can be stored as a fact table and monitored over time. If a field that historically contained only Latin characters suddenly shows Cyrillic or CJK code points, that is a data quality event worth investigating. The character inventory becomes a baseline, and deviations from it become signals.</p>
<h2 id="casing-as-a-data-quality-signal"><a class="header" href="#casing-as-a-data-quality-signal">Casing as a Data Quality Signal</a></h2>
<p>The distinction between HU and LU grain is not just about collapsing length — it reveals casing inconsistency. At HU grain, <code>France</code>, <code>FRANCE</code>, <code>france</code>, and <code>FRance</code> produce four different masks: <code>Aaaaaa</code>, <code>AAAAAA</code>, <code>aaaaaa</code>, <code>AAaaaa</code>. At LU grain, the first three collapse to <code>Aa</code>, <code>A</code>, and <code>a</code> respectively — still distinct, still diagnostic. The fourth, <code>FRance</code>, collapses to <code>Aa</code> at LU grain, merging with the title-case form. But the point is that casing variation survives the grain reduction. LU grain does not erase it.</p>
<p>A real example: profiling the country field in the French lobbyist registry (HATVP — the Haute Autorité pour la transparence de la vie publique) revealed four distinct casings of the word "France." There was <code>France</code> (title case, the expected form), <code>FRANCE</code> (all caps), <code>france</code> (all lower), and at least one mixed-case variant. Each produced a different mask. The masks surfaced this inconsistency without any casing-specific validation rules — no regex, no lookup table, no rule that says "this field must be title case." The frequency distribution of masks simply showed that what should be a single pattern was in fact four, indicating data entry from different sources or systems with different conventions.</p>
<p>This generalises to any field where casing should be consistent: country names, status codes, category labels, department names, currency codes. If you profile such a field at LU grain and find multiple distinct masks for what should be a single-format value, you have a casing quality signal. The mask distribution is doing the validation for you. You do not need to define the expected casing in advance — the data tells you, through its masks, whether casing is consistent or not. And because the masks are stored as fact tables, you can track whether casing consistency improves or degrades over time, across loads, across source systems.</p>
<h2 id="the-byte-frequency-approach"><a class="header" href="#the-byte-frequency-approach">The Byte Frequency Approach</a></h2>
<p>It is worth noting that the original byte-level approach — profiling the actual byte values present in a file, without interpreting them as characters — remains useful for a specific class of problem: file inspection. When you receive a file and need to determine its encoding, delimiters, and line endings, byte frequency analysis will tell you what byte values are present and at what frequencies. A UTF-8 file will show characteristic byte patterns (leading bytes in the <code>0xC0</code>–<code>0xF4</code> range followed by continuation bytes in the <code>0x80</code>–<code>0xBF</code> range). A Latin-1 file will show bytes in the <code>0x80</code>–<code>0xFF</code> range that are not valid UTF-8 sequences. A file with mixed line endings will show both <code>0x0A</code> (Unix) and <code>0x0D 0x0A</code> (Windows).</p>
<p>This forensic byte-level analysis is how bytefreq got its name. While the higher-level character class masking is the tool most users will reach for day-to-day, the byte frequency mode remains available for the cases where you need to understand what is in the file before you can even begin to interpret its contents.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="population-analysis"><a class="header" href="#population-analysis">Population Analysis</a></h1>
<h2 id="structure-discovery-the-step-before-profiling"><a class="header" href="#structure-discovery-the-step-before-profiling">Structure Discovery: The Step Before Profiling</a></h2>
<p>Before you profile the values in a field, you need to know what fields exist and how populated they are. This is structure discovery — the census before the survey. It answers the most basic question about a dataset: what is actually here?</p>
<p>For tabular data — CSV files, fixed-width extracts, database tables — structure discovery means counting non-null values per column. In the UK Companies House dataset (55 columns, 100,000 records), this immediately reveals that <code>DissolutionDate</code> is 0% populated (the extract contains only active companies), that the four <code>SICCode</code> columns cascade from 100% down to 2% (most companies register one industry code; very few register four), and that the <code>PreviousName</code> columns cascade from 11.5% to 0% (most companies have never changed their name, and almost none have changed it ten times). These are significant findings before a single mask is generated.</p>
<p>For nested JSON, structure discovery means walking the tree to find all unique field paths and counting how many records contain each. In the JMA earthquake data (80 events, 2,433 station observations), the field <code>Head.Headline.Information</code> appears in only 10% of records — indicating it is reserved for significant earthquakes that warrant a headline. The field <code>Body.Earthquake.Hypocenter.Area.DetailedName</code> appears at 0% in the sampled data, suggesting it is either deprecated or reserved for a specificity level that none of the sampled events triggered. The structure itself is the first finding.</p>
<p>The population profile of field paths creates a map of the dataset. Fields at 100% are the backbone — they appear in every record and define the core structure. Fields at 0% are dormant or deprecated. Fields between 1% and 50% are conditional — they exist for some record types but not others, and understanding <em>why</em> is often the most valuable insight in the entire analysis. A field that appears in 10% of records is not necessarily poorly populated; it may be correctly populated for the 10% of records where it applies.</p>
<p>For tabular data this computation is trivial: count non-nulls per column, divide by total rows. For nested JSON it requires walking each record's tree and accumulating path presence across the full dataset. Both bytefreq and DataRadar support this as a standard operation, producing a table of field paths sorted by population percentage.</p>
<p>The worked examples in this book follow this pattern: every analysis begins with a structure discovery table showing field paths and population percentages, before any mask profiling begins. You cannot profile what you have not found, and you cannot interpret a population rate without knowing the full landscape of fields around it.</p>
<p>Once masks have been generated for every value in a column, the next step is to count them. The resulting frequency table — a list of unique masks and their occurrence counts — is the <em>population profile</em> of the column, and it is where the real insight lives.</p>
<h2 id="the-power-law-of-data"><a class="header" href="#the-power-law-of-data">The Power Law of Data</a></h2>
<p>In practice, most columns in structured data follow a power law distribution when profiled by masks. A small number of masks (typically one to three) account for 80 to 95 percent of all values, representing the "expected" formats. A long tail of rare masks accounts for the remainder, representing anomalies, edge cases, errors, and format variations that the documentation did not mention.</p>
<p>The dominant masks tell you what the column is <em>supposed</em> to contain. The long tail tells you what has gone wrong, what has drifted, or what was never documented in the first place. The population profile is, in effect, a structural census of the column.</p>
<h2 id="reading-a-population-profile"><a class="header" href="#reading-a-population-profile">Reading a Population Profile</a></h2>
<p>Consider a phone number column with one million rows. After masking at high grain, the population profile might look like this:</p>
<pre><code>Mask                    Count      %       Cumulative
99999 999999          812,000   81.2%       81.2%
+99 9999 999999        95,000    9.5%       90.7%
9999 999 9999          42,000    4.2%       94.9%
(999) 999-9999         31,000    3.1%       98.0%
aaaa                   12,000    1.2%       99.2%
99999999999             4,200    0.4%       99.6%
Aaaa aaa Aaaa           2,100    0.2%       99.8%
(other)                 1,700    0.2%      100.0%
</code></pre>
<p>This single view tells us more about the phone number column than any schema definition could. We can see that the dominant format is UK mobile (<code>99999 999999</code>, 81.2%), with significant minorities of international numbers, UK landlines, and US-formatted numbers. We can see that 1.2% of values are alphabetic — likely the strings <code>null</code>, <code>none</code>, or similar placeholders masking as <code>aaaa</code>. We can see 0.2% of values that look like names (<code>Aaaa aaa Aaaa</code>), almost certainly data in the wrong field. And we can see that the format without spaces (<code>99999999999</code>) is present but relatively rare, suggesting it might be a data entry variant rather than an error.</p>
<p>None of this required writing a single regex. None of it required a schema. The profiler generated the structural census mechanically, and the interpretation is immediate to anyone who can read the mask notation.</p>
<h2 id="key-metrics"><a class="header" href="#key-metrics">Key Metrics</a></h2>
<p>From the population profile, several metrics are worth computing:</p>
<p><strong>Coverage</strong> measures what percentage of values match the top N masks. If the top mask covers 99.9% of values, the column is structurally uniform and easy to process. If the top mask covers only 40%, the column contains significant structural diversity and will require more complex handling. Coverage is a quick indicator of how much work a column will create downstream.</p>
<p><strong>Mask cardinality</strong> counts the number of distinct masks in the column. A well-formed date column might have one or two masks. A free-text name field might have hundreds. High mask cardinality suggests either legitimate diversity (names vary in length and format) or structural chaos (multiple unrelated data types in the same column). The distinction is usually obvious from the masks themselves. Note that columns containing non-Latin scripts (as discussed in Chapter 5) tend to have higher mask cardinality at high grain, because CJK, Arabic, and Cyrillic names vary in length just as Latin names do — the structural diversity is real, not an error.</p>
<p><strong>Rare mask frequency</strong> identifies masks appearing fewer than N times, or below some percentage threshold of the total population. These are the candidates for investigation. They might be data entry errors, format migrations (records from an old system using a different format), encoding problems, or legitimate edge cases. The threshold is domain-dependent — in a million-row dataset, a mask appearing 10 times is probably an anomaly, while in a thousand-row dataset it might represent 1% of the data and be a genuine format variant.</p>
<h2 id="finding-the-cliff-point"><a class="header" href="#finding-the-cliff-point">Finding the Cliff Point</a></h2>
<p>The metrics above — coverage, mask cardinality, rare mask frequency — describe the shape of the distribution, but they do not tell you where to draw the line between "normal" and "investigate." The <strong>cliff point</strong> does.</p>
<p>Take the sorted mask frequency table and calculate one additional column: the <strong>percentage of previous mask</strong>. For each mask in the list, divide its count by the count of the mask immediately above it. The first mask has no predecessor, so start with the second.</p>
<p>Returning to our phone number example:</p>
<pre><code>Mask                    Count     % of Previous
99999 999999          812,000         —
+99 9999 999999        95,000       11.7%
9999 999 9999          42,000       44.2%
(999) 999-9999         31,000       73.8%
aaaa                   12,000       38.7%
99999999999             4,200       35.0%
Aaaa aaa Aaaa           2,100       50.0%
(other)                 1,700       81.0%
</code></pre>
<p>Walking down the list, look at how the percentage-of-previous behaves. From position two onwards, the ratios are relatively stable — each mask is some reasonable fraction of the one above it, reflecting the gradual decline you would expect in a power law distribution. But in many real-world columns, there is a point where this ratio drops sharply. The count might go from 12,000 to 400 — a percentage-of-previous of 3.3% — where the preceding steps were in the 30-70% range.</p>
<p>That sharp drop is the <strong>cliff point</strong>. Everything above it is part of the expected population — patterns that are either correct or wrong in ways you have already accounted for. Everything below it is the exception zone: masks so rare relative to the population above them that they warrant individual inspection.</p>
<p>This is <strong>management by exception</strong> applied to data quality. Rather than reviewing every mask in a column, the cliff point tells you where to focus your attention. Above the cliff: normal operations. Below the cliff: the review queue.</p>
<p>The masks below the cliff point become a structured work list. For each one, the question is the same: does this pattern represent a new assertion rule that the profiler should learn, or a treatment function that downstream consumers need? A mask like <code>99-99-9999</code> appearing twelve times in a column of <code>9999-99-99</code> dates might indicate an American-format date that needs a treatment function to reorder the components. A mask like <code>AAAA</code> appearing three times might be the string <code>NULL</code> written literally, needing a rule to flag it as a placeholder. Each exception either produces a new rule, a new treatment, or a documented decision to accept the anomaly — and the cliff point is what surfaced it for review in the first place.</p>
<h3 id="a-real-example-uk-postcodes-in-companies-house-data"><a class="header" href="#a-real-example-uk-postcodes-in-companies-house-data">A Real Example: UK Postcodes in Companies House Data</a></h3>
<p>To see the cliff point in practice, consider a real profiling run against 100,000 company records from the UK Companies House public dataset. The <code>RegAddress.PostCode</code> field — the registered office postcode — produces the following HU mask frequency table:</p>
<pre><code>Mask              Count      %       % of Previous
AA9 9AA          38,701   38.4%          —
AA99 9AA         35,691   35.4%        92.2%
A99 9AA           7,900    7.8%        22.1%
A9 9AA            5,956    5.9%        75.4%
AA9A 9AA          5,378    5.3%        90.3%
(empty)           4,367    4.3%        81.2%
A9A 9AA           1,967    2.0%        45.0%
AA999AA               7    0.0%         0.4%    ← cliff point
AA99AA                5    0.0%        71.4%
99 999                2    0.0%        40.0%
9999                  2    0.0%       100.0%
A9   9AA              2    0.0%       100.0%
AA9 9AA.              2    0.0%       100.0%
AA99 9 AA             1    0.0%        50.0%
A99A 9AA              1    0.0%       100.0%
AAAAA 9               1    0.0%       100.0%
...and 14 more singletons
</code></pre>
<p>The first seven rows — the five standard UK postcode formats (<code>AA9 9AA</code>, <code>AA99 9AA</code>, <code>A99 9AA</code>, <code>A9 9AA</code>, <code>AA9A 9AA</code>), empty values, and the sixth format (<code>A9A 9AA</code>) — account for 99.96% of all records. The percentage-of-previous ratios in this zone are all between 22% and 92%, reflecting the natural variation in how common each postcode format is.</p>
<p>Then between <code>A9A 9AA</code> (1,967 records) and <code>AA999AA</code> (7 records), the count drops from nearly two thousand to single digits. The percentage-of-previous plummets to <strong>0.4%</strong>. That is the cliff.</p>
<p>Below the cliff, every mask is a data quality issue worth inspecting:</p>
<ul>
<li><code>AA999AA</code> and <code>AA99AA</code> — valid formats with the space missing (<code>GU478QN</code>, <code>CH71ES</code>). Treatment: insert the space.</li>
<li><code>99 999</code> — a numeric value (<code>20 052</code>), clearly not a UK postcode. Likely a foreign postal code or data in the wrong field.</li>
<li><code>A9   9AA</code> — extra spaces (<code>M2 2EE...</code>), with trailing dots. Treatment: normalise whitespace, strip trailing punctuation.</li>
<li><code>AA9 9AA.</code> — trailing full stop (<code>BR7 5HF.</code>). Treatment: strip punctuation.</li>
<li><code>AA99 9 AA</code> — extra space in the outward code (<code>SW18 4 UH</code>). Treatment: normalise to standard format.</li>
<li><code>AAAAA 9</code> — not a postcode at all (<code>BLOCK 3</code>). An address fragment in the wrong field.</li>
<li><code>A_A9 9AA</code> — contains a semicolon (<code>L;N9 6NE</code>). Data entry error; likely <code>LN9 6NE</code>.</li>
<li><code>9A AAA</code> — inverted format (<code>2L ONE</code>). Not a postcode.</li>
</ul>
<p>Each exception below the cliff either produces a treatment function (strip the trailing dot, normalise spacing, insert the missing space) or a flag for manual review (the numeric values, the <code>BLOCK 3</code>, the inverted formats). The cliff point surfaced all of them mechanically, without writing a single postcode-specific validation rule.</p>
<p>In practice, the cliff point is not always a single dramatic drop. Some columns have a gradual slope with no obvious cliff — these are columns with genuine structural diversity (free-text fields, for example) where management by exception is less useful. Others have a razor-sharp cliff after the second or third mask, where 99% of the data conforms to two or three formats and everything else is noise. The clarity of the cliff point is itself diagnostic: a sharp cliff means the column has strong structural conventions; a gentle slope means it does not.</p>
<h2 id="population-checks"><a class="header" href="#population-checks">Population Checks</a></h2>
<p>A separate but related technique is the <strong>population check</strong>, which tests whether each field is populated or empty. This is implemented as a special mask that returns <code>1</code> if a field contains a value and <code>0</code> if it is null or empty. When aggregated, it produces a per-field population percentage.</p>
<p>Population checks are a basic hygiene measure but surprisingly revealing. A field that is documented as mandatory but shows 15% empty values indicates a data collection problem. A field that was previously 99.5% populated but has dropped to 80% suggests an upstream process change. A field that is 100% populated is either genuinely complete or has been backfilled with placeholders — and the mask profile of that field will tell you which.</p>
<p>When we built our reusable notebook for profiling data in Apache Spark, we included <code>POPCHECKS</code> as a standard mask alongside the ASCII high grain and low grain profilers, precisely because population analysis is so consistently useful as a first-pass check. The graphical output — a stacked bar chart showing populated versus missing values per field — is one of those visualisations that instantly tells you the shape of a dataset before you look at a single value.</p>
<h2 id="progressive-population"><a class="header" href="#progressive-population">Progressive Population</a></h2>
<p>Some fields do not have a fixed population rate — they fill over time. In the French lobbyist registry (HATVP), financial disclosure fields such as expenditure, revenue, and employee count start empty for newly registered organisations and populate progressively as annual reporting periods pass. A field that is 60% populated today may be 80% populated next year — not because data quality improved, but because more reporting periods have elapsed. The data was never missing; it simply did not exist yet.</p>
<p>This means a single population snapshot can be misleading. A field at 40% populated might look sparse, but if the dataset covers five years of registrations and only three years of financial reporting are required, 40% is exactly what you would expect. The population rate must be interpreted in the context of the data's temporal structure. Without that context, you risk raising false alarms about fields that are behaving exactly as designed.</p>
<p>When monitoring population rates over time (as described in the Quality Monitoring chapter), progressive population creates a naturally rising baseline. Distinguishing "population increased because more time has passed" from "population increased because a data collection issue was fixed" requires understanding the business process behind the data. The population profile surfaces the question; domain knowledge answers it. This is a recurring theme in data quality on read: the profiler finds the pattern, but only someone who understands the domain can say whether the pattern is correct.</p>
<h2 id="wildcard-profiling"><a class="header" href="#wildcard-profiling">Wildcard Profiling</a></h2>
<p>When the same field name appears at multiple levels of a nested structure, we can profile them collectively using a wildcard pattern. A query like <code>*.Name</code> gathers every <code>Name</code> field regardless of its position in the hierarchy, producing a single combined profile across all matching paths.</p>
<p>In the JMA earthquake data, <code>Name</code> appears at multiple nesting levels: <code>Body.Earthquake.Hypocenter.Area.Name</code> (the earthquake epicentre region), <code>Body.Intensity.Observation.Pref.Name</code> (the prefecture), <code>Body.Intensity.Observation.Pref.Area.City.Name</code> (the city), and <code>Body.Intensity.Observation.Pref.Area.City.IntensityStation.Name</code> (the individual monitoring station). Profiling <code>*.Name</code> collectively reveals whether the same character set and structural patterns are used consistently across all levels — or whether different nesting contexts use different conventions. If station names use Latin characters while prefecture names use kanji, the wildcard profile will show both populations in a single view.</p>
<p>This extends across datasets. If postcodes appear in multiple nested structures — billing address, shipping address, registered office — profiling <code>*.PostCode</code> shows all postcodes regardless of context. When the aggregate profile reveals anomalies, you drill into individual paths to localise the issue. The wildcard gives you the overview; the specific path gives you the detail.</p>
<p>Wildcard profiling is particularly powerful for cross-cutting consistency checks: verifying that all date fields across a dataset use the same format, that all name fields share the same casing conventions, or that all identifier fields have the same structural pattern. It turns field-by-field analysis into a dataset-wide consistency check, catching format drift that would be invisible when examining one field at a time.</p>
<h2 id="the-two-pass-workflow"><a class="header" href="#the-two-pass-workflow">The Two-Pass Workflow</a></h2>
<p>Combining population analysis with mask profiling gives us a general workflow for exploring any structured dataset:</p>
<ol>
<li>Run population checks to understand which fields are populated and which are sparse.</li>
<li>Run low grain mask profiling to identify the structural families in each populated field.</li>
<li>Review the long tail of rare masks to identify anomalies and potential quality issues.</li>
<li>Drill into specific fields with high grain masking where precision matters (postcodes, phone numbers, dates, identifiers).</li>
<li>Document the dominant masks as the "expected" formats for each field.</li>
</ol>
<p>This workflow takes minutes on a modestly sized dataset (up to a few hundred thousand rows) and scales to millions of rows with the CLI tool or billions with the Spark engine. The output — a per-field summary of structural patterns — is the foundation on which the rest of the DQOR process is built: masks as error codes, treatment functions, and the flat enhanced format that ties it all together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="masks-as-error-codes"><a class="header" href="#masks-as-error-codes">Masks as Error Codes</a></h1>
<p>The idea introduced in the profiling chapter — that a mask can be used as a key to retrieve records of a particular structural type — leads to what is perhaps the most important insight in the entire DQOR framework: <strong>every mask is an implicit data quality error code</strong>.</p>
<p>If you know what masks are "correct" for a column, then every other mask is an error. And unlike a generic boolean flag ("valid" or "invalid"), the mask itself tells you <em>what kind</em> of error it represents. The mask <code>99999</code> appearing in a name column does not just say "this is wrong" — it says "this is a numeric value where text was expected." The mask <code>A/A</code> does not just say "this fails validation" — it says "this is a two-character abbreviation with a slash, probably a placeholder like N/A." The mask is the diagnosis.</p>
<p>This thinking leads to the following conclusion: we can create a general framework around mask-based profiling for doing data quality control and remediation <em>as we read data within our data reading pipeline</em>. This has some advantageous solution properties that are worth setting out explicitly.</p>
<h2 id="allow-lists-and-exclusion-lists"><a class="header" href="#allow-lists-and-exclusion-lists">Allow Lists and Exclusion Lists</a></h2>
<p>The simplest way to operationalise masks as error codes is through allow lists and exclusion lists.</p>
<p>An <strong>allow list</strong> defines the acceptable masks for a column. Any value whose mask does not appear in the allow list is flagged as an anomaly. For a UK postcode column, the allow list might contain:</p>
<pre><code>A9 9AA
A99 9AA
A9A 9AA
AA9 9AA
AA99 9AA
AA9A 9AA
</code></pre>
<p>These six masks cover all valid UK postcode formats. Any value that produces a different mask — <code>aaaa</code> (lowercase text), <code>99999</code> (numeric), <code>A/A</code> (placeholder), or an empty string — is automatically flagged, and the mask tells you exactly what structural form the offending value takes.</p>
<p>An <strong>exclusion list</strong> takes the opposite approach: it defines masks that are known to be problematic, and flags any value that matches. This is useful when the set of valid formats is large or open-ended (as with free-text name fields), but certain structural patterns are reliably indicative of errors:</p>
<pre><code>9999           → numeric value in a text field
               → empty string (zero-length value)
a              → single lowercase character
aaaa://aaa.aaa → URL in a name field
</code></pre>
<p>This is not a theoretical exercise. In the UK Companies House profiling (see the Worked Example appendix), the <code>RegAddress.PostCode</code> field at LU grain produces just two dominant masks — <code>A9 9A</code> (88.3%, e.g. <code>L23 0RG</code>) and <code>A9A 9A</code> (7.3%, e.g. <code>W1W 7LT</code>) — which together cover all six standard UK postcode formats when expanded at HU grain. These two masks plus the empty value (4.4%) account for 99.96% of the data. An allow list of <code>{A9 9A, A9A 9A, (empty)}</code> at LU grain would instantly flag the remaining 0.04% — records containing missing spaces (<code>GU478QN</code>), trailing punctuation (<code>BR7 5HF.</code>), embedded semicolons (<code>L;N9 6NE</code>), and values that are not postcodes at all (<code>BLOCK 3</code>, <code>2L ONE</code>). The allow list is three entries. The error detection is comprehensive.</p>
<p>In practice, allow lists are more useful for format-controlled fields (postcodes, phone numbers, dates, identifiers) where the set of valid patterns is finite and known. Exclusion lists are more useful for free-text fields where the valid patterns are diverse but certain structural types are reliably wrong.</p>
<h2 id="building-quality-gates"><a class="header" href="#building-quality-gates">Building Quality Gates</a></h2>
<p>The combination of population analysis and mask-based error codes creates a natural quality gate for incoming data:</p>
<ol>
<li><strong>Profile the column</strong> using mask-based profiling at the appropriate grain level.</li>
<li><strong>Compare each mask against the allow list</strong> (or exclusion list) for that column.</li>
<li><strong>Check population thresholds</strong> — is the proportion of "good" masks above the minimum acceptable level? Has a previously rare "bad" mask suddenly increased in frequency?</li>
<li><strong>Route errors by mask</strong> — different masks may require different handling. A placeholder (<code>A/A</code>) might be replaced with a null. An all-caps name (<code>AAAA AAAAA</code>) might be normalised to title case. A numeric value in a name field (<code>99999</code>) might be quarantined for manual review.</li>
</ol>
<p>The French lobbyist registry provides a concrete example of routing by mask. The director's role field (<code>dirigeants.fonction</code>) produces masks that reveal three casing conventions in use: <code>Aa Aa</code> for title case (<code>Directeur Général</code>, 92 records), <code>Aa a</code> for French grammatical case (<code>Directeur général</code>, 74 records), and <code>A A</code> for uppercase (<code>DIRECTEUR GENERAL</code>, 29 records). A quality gate on this field would not flag any of these as errors — they are all valid role descriptions. But it would route each casing variant to a normalisation function, ensuring that downstream analytics do not create three separate categories for what is semantically the same role. The mask is not just an error detector; it is a router. (See the Worked Example: Profiling the French Lobbyist Registry appendix.)</p>
<p>The quality gate can run automatically on every new batch of data, providing a continuous structural health check. When the profile of incoming data drifts — a new mask appears that was not seen before, or the population of a known-bad mask increases — the gate flags it for investigation.</p>
<p>This approach maps directly to the Data Quality Controls capability described in enterprise data operating models, where dataset registration, profiling for outliers, column-level validation, alerts and notifications, bad data quarantine, and DQ remediation rules are all core components. Mask-based profiling provides a single mechanism that addresses all of these capabilities, because the mask itself serves as the registration key, the outlier detector, the validation check, the alert trigger, the quarantine criterion, and the remediation lookup key — all from one pass over the data.</p>
<h2 id="masks-as-provenance"><a class="header" href="#masks-as-provenance">Masks as Provenance</a></h2>
<p>There is a secondary benefit to treating masks as error codes that is easy to overlook: they provide provenance for quality decisions. When a downstream consumer asks "why was this record flagged?" or "why was this value changed?", the mask provides a clear, reproducible answer. The record was flagged because its mask was <code>99999</code> and the allow list for the name column does not include numeric masks. The value was changed because its mask was <code>AAAA AAAAA</code> and the treatment function for that mask is title-case normalisation.</p>
<p>This audit trail is built into the mechanism by construction. No additional logging or documentation is required — the mask is both the detection method and the explanation. In regulated environments where data lineage and transformation justification are compliance requirements, this property is particularly valuable.</p>
<h2 id="text-encoded-numeric-ranges"><a class="header" href="#text-encoded-numeric-ranges">Text-Encoded Numeric Ranges</a></h2>
<p>A particularly instructive pattern occurs when numeric data is encoded as text ranges rather than as actual numbers. In the French lobbyist registry (HATVP), the expenditure field contains values like <code>50000 à 99999 euros</code> and <code>10000 à 24999 euros</code>. These are not numbers — they are text descriptions of numeric bands. The mask at HU grain is something like <code>99999 a 99999 aaaaa</code>, which clearly reveals the structure: digits, then the French word "à", then more digits, then a unit label.</p>
<p>This is a mask-as-error-code in a subtle sense. The mask is not "wrong" — the data faithfully represents what was reported. But the mask tells you that this field cannot be aggregated numerically without transformation. You cannot sum these ranges, compute averages, or join them to numeric thresholds. The mask diagnoses the field as requiring a treatment function that either extracts the midpoint, maps the range to a numeric band code, or flags it for domain-specific interpretation.</p>
<p>This pattern generalises beyond French expenditure data. Survey responses ("18-24 years", "25-34 years"), salary bands ("£30,000-£39,999"), and classification ranges ("Category A-C") all encode numeric information as text. Mask-based profiling surfaces these immediately because the structural fingerprint — digits mixed with letters and delimiters — is visually distinct from either pure numeric or pure text fields. The mask doesn't just flag the anomaly; it tells you the exact encoding scheme being used.</p>
<p>The treatment for text-encoded ranges depends on the consumer. A statistical analysis team might extract numeric boundaries and compute midpoints. A reporting team might preserve the original text labels. A downstream database might map each range to an enumerated code. The mask identifies the pattern; the treatment is domain-specific — consistent with the DQOR principle of suggestions, never mandates.</p>
<h2 id="from-detection-to-treatment"><a class="header" href="#from-detection-to-treatment">From Detection to Treatment</a></h2>
<p>The logical next step, once masks have been classified as "good" or "bad" for a given column, is to define what happens to the records that fall into each category. That is the subject of the next chapter: treatment functions and the data quality loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="treatment-functions-and-the-quality-loop"><a class="header" href="#treatment-functions-and-the-quality-loop">Treatment Functions and the Quality Loop</a></h1>
<p>Profiling tells you what is in the data. Masks as error codes tell you what is wrong. <strong>Treatment functions</strong> close the loop by defining what to do about it.</p>
<p>The key principle is that treatment is mask-driven. Each error mask, for a given column, maps to a specific remediation action. The mask is the lookup key, the column provides the context, and the treatment function provides the correction. This three-part mapping — (column, mask) → treatment — is the operational core of the DQOR framework.</p>
<h2 id="common-treatments"><a class="header" href="#common-treatments">Common Treatments</a></h2>
<p>The treatments themselves are usually straightforward. Most data quality problems, once identified, have obvious corrections.</p>
<p><strong>Format normalisation</strong> handles data that is correct but inconsistently formatted. A customer name with the mask <code>AAAA AAAAA</code> (all uppercase) is structurally valid as a name but stylistically inconsistent with the dominant mask <code>Aaaa Aaaaa</code> (title case). The treatment is <code>title_case()</code>: transform <code>JOHN SMITH</code> to <code>John Smith</code>. Similarly, a name with the mask <code>aaaa aaaaa</code> (all lowercase) receives the same treatment. The original value is preserved in the <code>.raw</code> column; the normalised value is placed in a treatment column alongside it.</p>
<p>A real-world example from the French lobbyist registry illustrates. The country field (<code>pays</code>) contains <code>FRANCE</code> (375 records), <code>France</code> (22 records), and <code>france</code> (1 record) — three LU masks (<code>A</code>, <code>Aa</code>, <code>a</code>) for what is semantically a single value. The title-case treatment normalises all three to <code>France</code>. The role field shows the same pattern at a larger scale: <code>Vice-Président</code> and <code>Vice-président</code> coexist as <code>Aa-Aa</code> and <code>Aa-a</code> — identical meaning, different capitalisation after the hyphen. (See the Worked Example: Profiling the French Lobbyist Registry appendix.)</p>
<p><strong>Whitespace trimming</strong> removes leading or trailing spaces that should not be present. A mask of <code>Aaaa Aaaaa </code> (note the trailing space) is structurally almost identical to the expected <code>Aaaa Aaaaa</code>, and the treatment is simply <code>trim()</code>. These cases are common in data extracted from fixed-width file formats where field padding was not stripped during extraction.</p>
<p>In the UK Companies House data, the postcode field reveals several whitespace variants. The mask <code>A9 9 A</code> (2 records, e.g. <code>WR9 9 AY</code>) has an extra space in the inward code. The mask <code>A9 9A.</code> (2 records, e.g. <code>BR7 5HF.</code>) has trailing punctuation. And <code>A9A</code> (12 records, e.g. <code>GU478QN</code>) is a valid postcode with the required space missing entirely. Each mask triggers a specific treatment: normalise the internal spacing, strip the trailing dot, insert the missing space before the three-character inward code. The mask determines the treatment, and the treatment is deterministic — no ambiguity, no special cases, just a mechanical correction driven by the structural fingerprint. (See the Worked Example: Profiling UK Companies House Data appendix.)</p>
<p><strong>Placeholder replacement</strong> converts sentinel values to proper nulls. Values with masks like <code>A/A</code> (<code>N/A</code>), <code>aaaa</code> (<code>null</code>, <code>none</code>), <code>---</code> (decorative dashes), or the empty string are all encoding the same semantic concept — "this field has no value" — using different textual representations. The treatment is to replace them with an actual null, ensuring that downstream null-handling logic works correctly.</p>
<p><strong>Quarantine</strong> isolates records that are too broken to fix automatically. A value with the mask <code>99999</code> in a name column, or <code>aaaa://aaa.aaa.aaa</code> (a URL) in an address column, indicates data that is not just poorly formatted but fundamentally in the wrong field. These records are routed to a restricted quarantine area where administrators with appropriate access rights can examine the raw data, determine the root cause, and propose corrective measures. Quarantine is especially important for records where data quality failures indicate potential privacy issues — for example, free-text fields containing credit card numbers or unmasked personal identifiers.</p>
<p>The Companies House <code>RegAddress.PostTown</code> field provides a clear quarantine case. Among the 100,000 records, 14 have the mask <code>A9 9A</code> — postcodes like <code>EH47 8PG</code> appearing in the town name field. Another 32 have <code>9 A A</code> — street addresses like <code>150 HOLYWOOD ROAD</code>. And one record has <code>9A A</code>: the value <code>2ND FLOOR</code>. These are not formatting problems that can be corrected automatically. They represent data in the wrong column — column misalignment in the source system — and the only safe action is quarantine for manual review. The masks tell you not just that something is wrong, but what kind of wrong it is: <code>A9 9A</code> in a town field says 'this is a postcode', which is a fundamentally different problem from <code>A,</code> in a town field which says 'this is a town with trailing punctuation'. (See the Worked Example: Profiling UK Companies House Data appendix.)</p>
<h2 id="the-treatment-pipeline"><a class="header" href="#the-treatment-pipeline">The Treatment Pipeline</a></h2>
<p>A treatment pipeline for a single field follows a simple pattern:</p>
<ol>
<li>Read the raw value.</li>
<li>Generate its mask.</li>
<li>Look up the treatment function for that (column, mask) combination.</li>
<li>Apply the treatment to produce a corrected value.</li>
<li>Re-mask the corrected value to verify that it now matches an expected mask.</li>
<li>If the re-masked value is acceptable, write the treatment alongside the raw value.</li>
<li>If the re-masked value still does not match an expected mask, escalate to manual review.</li>
</ol>
<p>The <strong>re-mask step</strong> is important. It provides a built-in verification that the treatment function actually produced a valid result. If a title-case normalisation function is applied to an all-caps name but the result still does not match the expected mask (perhaps because the original value was not a name at all, despite being in the name column), the re-mask step catches the failure and prevents a bad correction from propagating.</p>
<h2 id="properties-of-good-treatment-functions"><a class="header" href="#properties-of-good-treatment-functions">Properties of Good Treatment Functions</a></h2>
<p>Good treatment functions share several properties:</p>
<p><strong>Idempotent</strong>: applying the function twice produces the same result as applying it once. <code>title_case(title_case("JOHN SMITH"))</code> should return <code>John Smith</code>, not <code>John smith</code> or something worse. Idempotency ensures that treatment pipelines can be re-run without creating cascading distortions.</p>
<p><strong>Non-destructive</strong>: the original value is always preserved alongside the treated value. The treatment function writes to a parallel column (the <code>.Rules</code> or treatment column in the flat enhanced format), never overwriting the <code>.raw</code> value. This ensures that treatments can be audited, reversed, and reprocessed if the treatment logic is later found to be incorrect.</p>
<p><strong>Auditable</strong>: the mask that triggered the treatment is recorded alongside the treatment itself. The provenance chain is: raw value → mask → treatment function → treated value → re-mask verification. Every step is traceable.</p>
<h2 id="data-quality-remediation-rules-at-scale"><a class="header" href="#data-quality-remediation-rules-at-scale">Data Quality Remediation Rules at Scale</a></h2>
<p>In enterprise data platforms, treatment functions are not ad hoc scripts but managed assets. They are proposed by data quality analysts, agreed with data stewards and source system owners, tested, released through change management processes, and monitored in production. A remediation rules engine automates the application of these rules at scale, logging every treatment applied, and producing audit reports that demonstrate the value created by the remediation pipelines.</p>
<p>This level of process rigour is essential in environments where data remediation has compliance implications. Automated data remediation can only be applied where clear data quality checks have tagged the data appropriately, and where the remediation solutions have been agreed with stakeholders. The mask-based approach supports this by construction: the mask is the tag, the allow list/exclusion list is the check, and the treatment function is the agreed remediation.</p>
<h2 id="the-quality-loop"><a class="header" href="#the-quality-loop">The Quality Loop</a></h2>
<p>Over time, as treatment functions are applied and their results monitored, the long tail of error masks shrinks. Known errors are corrected automatically; new patterns are detected, investigated, and either added to the allow list (if they turn out to be legitimate) or assigned new treatment functions (if they represent a new class of error).</p>
<p>This creates a <strong>continuous improvement loop</strong>:</p>
<ol>
<li><strong>Profile</strong> — discover new masks in incoming data.</li>
<li><strong>Classify</strong> — determine whether each mask is expected (allow list), an error (exclusion list), or unknown (investigate).</li>
<li><strong>Treat</strong> — write or update treatment functions for error masks.</li>
<li><strong>Monitor</strong> — track the effectiveness of treatments and watch for new patterns.</li>
<li><strong>Refine</strong> — adjust allow lists, exclusion lists, and treatment functions based on operational experience.</li>
</ol>
<p>Each iteration through this loop improves the quality of the downstream data products. The loop does not require a large upfront investment in rules definition — you start with whatever you can profile on day one, and build incrementally as you learn the data. This incremental approach is well suited to the reality of data quality work, where perfect knowledge of the data is never available at the start and understanding improves over time through operational experience.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-flat-enhanced-format-a-feature-store-for-data-quality"><a class="header" href="#the-flat-enhanced-format-a-feature-store-for-data-quality">The Flat Enhanced Format: A Feature Store for Data Quality</a></h1>
<p>The preceding chapters described the techniques — masking, population analysis, error codes, treatment functions — but left open the question of how the outputs of all this profiling and treatment are actually stored and delivered to consumers. The answer is the <strong>flat enhanced format</strong>, and it is arguably the most important architectural decision in the entire DQOR framework.</p>
<h2 id="from-nested-to-flat"><a class="header" href="#from-nested-to-flat">From Nested to Flat</a></h2>
<p>To understand the flat enhanced format, start with what bytefreq produces in its standard enhanced mode (<code>-e</code>). For each record, every field becomes a nested JSON object containing the raw value, its masks, and any inferred rules:</p>
<pre><code class="language-json">{
  "Accounts.LastMadeUpDate": {
    "HU": "99_99_9999",
    "LU": "9_9_9",
    "Rules": { "std_date": "2019-09-30", "string_length": 10 },
    "raw": "30/09/2019"
  }
}
</code></pre>
<p>This is rich and self-describing, but nested structures can be awkward to query in flat analytical tools (SQL engines, DataFrames, spreadsheets). The flat enhanced format (<code>-E</code>) is a <strong>flattened key-value pair schema, sourced from nested data</strong> — one pair per attribute:</p>
<pre><code class="language-json">{
  "Accounts.LastMadeUpDate.raw": "30/09/2019",
  "Accounts.LastMadeUpDate.HU": "99_99_9999",
  "Accounts.LastMadeUpDate.LU": "9_9_9",
  "Accounts.LastMadeUpDate.Rules.std_date": "2019-09-30",
  "Accounts.LastMadeUpDate.Rules.string_length": 10
}
</code></pre>
<p>Each record is now a self-contained set of key-value pairs. The quality metadata travels with the data it describes — no joins, no lookups, no separate tables. Every record carries its own profiling output.</p>
<p>This is important because key-value pairs do not assume a fixed schema. The flat enhanced format is a <strong>flexible, floating schema</strong> where:</p>
<ul>
<li>
<p><strong>Ragged rows are handled gracefully.</strong> If one record has twelve fields and the next has eight, each record simply carries its own set of pairs. There is no need for null-padding to fit a rigid column structure, and no schema-on-write enforcement that rejects records with unexpected shapes. Real-world data is ragged — files from different sources, different vintages, different levels of completeness — and the key-value pair format absorbs that variation without friction.</p>
</li>
<li>
<p><strong>Annotations are easily added.</strong> Adding a new quality rule, a new treatment, or a new derived attribute is just adding another key-value pair to the record. There is no ALTER TABLE, no schema migration, no reprocessing of historical records. The format is inherently additive — new annotations appear alongside existing ones, and consumers that do not need them simply ignore keys they do not recognise.</p>
</li>
<li>
<p><strong>Field names use namespace dot notation, providing provenance and scoping.</strong> The key <code>Accounts.LastMadeUpDate.Rules.std_date</code> is not just a column name — it is a path that tells you exactly where this value came from: the <code>Accounts.LastMadeUpDate</code> field, its <code>Rules</code> annotation layer, specifically the <code>std_date</code> rule. This dot-separated namespace convention means that the key itself carries provenance. You can programmatically group all keys under <code>Accounts.LastMadeUpDate.*</code>, or extract all <code>*.Rules.*</code> annotations across every field, or filter to just <code>*.raw</code> to recover the original data. The namespace is the schema.</p>
</li>
</ul>
<p>This pattern originated in the Hadoop era, where the economics were clear: joins across distributed datasets were expensive (network shuffles scaled with data size), while storage was cheap and getting cheaper. Co-locating related information in the same record — rather than normalising into separate tables — eliminated the most costly operation in the pipeline. The pattern persists today in Delta Lake, Iceberg, and other lakehouse architectures, and it underpins the design of feature stores in machine learning, where pre-computed features are stored alongside the raw data so that serving pipelines can retrieve everything in a single read.</p>
<h2 id="from-nested-input-to-flat-output"><a class="header" href="#from-nested-input-to-flat-output">From Nested Input to Flat Output</a></h2>
<p>The previous section showed how bytefreq's output transforms nested quality metadata into flat key-value pairs. But there is an equally important input-side question: how does the profiler handle nested <em>source</em> data? When the input is deeply nested JSON — not a flat CSV — the profiler must first discover the structure before it can profile the values.</p>
<p>bytefreq walks the JSON tree of each record, generating dot-notation paths for every leaf value. A six-level-deep field in the JMA earthquake data becomes <code>Body.Intensity.Observation.Pref.Area.City.IntensityStation.Name</code>. An array produces one path per element, with the array items treated as repeated instances of the same path. The result is a flat inventory of field paths — the structure discovery step described in Chapter 6.</p>
<p>This flattening is not a lossy transformation for profiling purposes. The dot-notation path preserves the nesting hierarchy: you can always reconstruct where a field sits in the original structure by reading its path. And because the path is just a string, it can be used as a key for grouping, filtering, and wildcard queries (<code>*.Name</code>, <code>*.PostCode</code>).</p>
<p>The input flattening and the output flattening are conceptually the same operation applied at different stages. On input, nested source data is flattened into field paths for profiling. On output, nested quality metadata is flattened into key-value pairs for consumption. The flat enhanced format is the common representation at both ends of the pipeline.</p>
<p>This means bytefreq can accept CSV, JSON (including deeply nested), Parquet, and Excel as input, and produce the same flat enhanced output regardless of the source format. The input format determines how field paths are discovered; the output format is always the same flattened key-value pair schema. The profiler abstracts away the structural complexity of the source and presents a uniform interface to downstream consumers.</p>
<h2 id="the-column-structure"><a class="header" href="#the-column-structure">The Column Structure</a></h2>
<p>For each field in the original data, the flat enhanced format produces a family of parallel columns:</p>
<p><strong><code>.raw</code></strong> contains the original, untouched value exactly as it was received from the source. This column is immutable — it is never modified, never overwritten, and never deleted. It is the single source of truth and the foundation of the audit trail. If a downstream consumer needs to verify what was originally received, the <code>.raw</code> value is the authoritative record.</p>
<p><strong><code>.HU</code></strong> contains the high-grain Unicode mask of the raw value. This is the structural fingerprint, the profiling output. It shows the shape of the data without revealing the content, making it safe for sharing in contexts where the raw data is sensitive (names, addresses, financial details) but the structural patterns need to be reviewed.</p>
<p><strong><code>.LU</code></strong> contains the low-grain Unicode mask — the collapsed version that groups consecutive characters of the same class. This is useful for high-level pattern discovery and for comparing structural families across fields or datasets.</p>
<p><strong><code>.Rules</code></strong> contains automatically inferred properties and suggested treatments. This is where the profiler records what it has discovered about the value and what it recommends doing with it. For example:</p>
<pre><code class="language-json">{
  "is_unix_timestamp": "milliseconds",
  "std_datetime": "2025-12-19 22:00:40 UTC"
}
</code></pre>
<p>This tells the consumer: the raw value <code>1766181640870</code> appears to be a Unix timestamp in milliseconds, and if you choose to interpret it as a datetime, the suggested standardised form is <code>2025-12-19 22:00:40 UTC</code>. The consumer can adopt the suggestion, ignore it, or apply their own interpretation. The rules column is advisory, not prescriptive.</p>
<h2 id="suggestions-never-mandates"><a class="header" href="#suggestions-never-mandates">Suggestions, Never Mandates</a></h2>
<p>This last point is a fundamental design principle. The flat enhanced format can contain <strong>multiple competing rules</strong> for the same field. A value that looks like it could be either a Unix timestamp in seconds or a large integer might have both <code>is_unix_timestamp: seconds</code> and <code>is_numeric: true</code> in its rules. A date string that could be parsed as either <code>DD/MM/YYYY</code> or <code>MM/DD/YYYY</code> (the eternal ambiguity of <code>03/04/2025</code>) might carry both interpretations. The profiler does not resolve the ambiguity — it surfaces it, documents both possibilities, and leaves the decision to the consumer.</p>
<p>This non-prescriptive approach is deliberate. In a DQOR architecture, consumers have different requirements and different tolerances. A data science team might prefer to keep the raw timestamp and parse it themselves. A reporting team might want the standardised datetime. A compliance team might need to see both the raw value and the suggested interpretation side by side. The flat enhanced format supports all of these use cases from the same output, without requiring separate pipelines or separate quality processes.</p>
<h2 id="adding-new-derivations"><a class="header" href="#adding-new-derivations">Adding New Derivations</a></h2>
<p>The architectural beauty of the flat enhanced format is that adding new quality checks, new treatments, or new derived features is simply a matter of adding new columns. The existing columns — <code>.raw</code>, <code>.HU</code>, <code>.LU</code>, <code>.Rules</code> — are never modified. If a new version of the profiler detects a new pattern (say, UK National Insurance numbers in a field that was previously unprofiled for that format), a new rule is added to the <code>.Rules</code> column. If a new treatment function is developed (say, a geocoding lookup for postcode fields), a new <code>.geo</code> column can be added alongside the existing family.</p>
<p>This additive, append-only approach means that the flat enhanced format is inherently <strong>backwards compatible</strong>. Consumers that were written against an earlier version of the format, which did not include the new columns, continue to work unchanged — they simply do not see the new columns. Consumers that want the new features select the additional columns. There is no migration, no schema change, no reprocessing of historical data.</p>
<p>This is the same property that makes feature stores effective in machine learning: the ability to add new features without disrupting existing model-serving pipelines. In the data quality context, it means that the quality process can improve continuously — new rules, new treatments, new detections — without requiring coordinated releases across all downstream consumers.</p>
<h2 id="practical-implications"><a class="header" href="#practical-implications">Practical Implications</a></h2>
<p>The flat enhanced format has several practical implications that are worth noting.</p>
<p><strong>Storage cost</strong> increases because every field is replicated multiple times (raw, HU, LU, Rules, plus any treatment columns). In practice, this overhead is modest — mask columns are typically shorter than the raw values they describe, and Rules columns are sparse (most fields have only a few applicable rules). On modern storage (cloud object stores, columnar formats like Parquet), the incremental cost is negligible compared to the raw data volume.</p>
<p><strong>Column naming conventions</strong> matter. A consistent naming scheme — <code>fieldname.raw</code>, <code>fieldname.HU</code>, <code>fieldname.LU</code>, <code>fieldname.Rules.rule_name</code> — makes the format self-documenting and allows consumers to discover the available quality metadata programmatically. DataRadar and bytefreq use this convention by default.</p>
<p><strong>Columnar storage formats</strong> (Parquet, ORC) are particularly well suited to the flat enhanced format because consumers typically read only a subset of columns. A consumer that needs only the raw values reads only the <code>.raw</code> columns and pays no I/O cost for the quality metadata. A consumer that needs only the masks reads only the <code>.HU</code> or <code>.LU</code> columns. The wide-table format, which would be wasteful in a row-oriented store, is efficient in a columnar store because unused columns are never read.</p>
<p><strong>The format works at any scale</strong>: as a JSON or NDJSON file from the browser tool (DataRadar), as a CSV or Parquet output from the CLI tool (bytefreq), or as a distributed dataset in a Spark-based engine. The principle is the same at every scale; only the storage medium and the processing engine change.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tools-dataradar-and-bytefreq"><a class="header" href="#the-tools-dataradar-and-bytefreq">The Tools: DataRadar and bytefreq</a></h1>
<p>The techniques described in this book are implemented in two open-source tools, each designed for a different scale and a different user. The underlying profiling engine is the same across both; what changes is the deployment model, the interface, and the volume of data each can handle.</p>
<h2 id="dataradar-browser-based-profiling"><a class="header" href="#dataradar-browser-based-profiling">DataRadar: Browser-Based Profiling</a></h2>
<p>DataRadar is a browser-based data quality profiler that runs entirely client-side using WebAssembly. You upload a file — CSV, Excel, JSON, or NDJSON — and the profiling happens in your browser. No data is sent to any server. No software needs to be installed.</p>
<p>This matters more than it might initially seem. In many organisations — councils, NHS trusts, universities, small businesses — the people who need to assess data quality are working on locked-down machines where they cannot install software. They have no Python, no R, no SQL tools. What they have is a web browser. DataRadar meets them where they are.</p>
<p>The browser tool supports the full DQOR workflow: mask-based profiling at multiple grain levels, population analysis, script detection, and flat enhanced output. For nested or semi-structured data (JSON, GeoJSON), it can flatten the structure and produce the parallel column families (<code>.raw</code>, <code>.HU</code>, <code>.LU</code>, <code>.Rules</code>) as a downloadable NDJSON file that can be loaded directly into Pandas, Polars, DuckDB, or any other tool that reads newline-delimited JSON.</p>
<p>A typical use case: a council data analyst receives a GeoJSON feed of planning applications from a government portal. They paste the URL into DataRadar, the tool fetches and profiles the data, and within seconds they can see the structural patterns in each field — including fields with epoch timestamps that the tool has automatically detected and offered to convert to human-readable datetimes. They export the flat enhanced output, load it into Excel or a notebook, and proceed with their analysis using whichever columns they need: raw values for verification, masks for quality assessment, suggested treatments for convenience.</p>
<p>DataRadar is free and available at <a href="https://dataradar.co.uk">dataradar.co.uk</a>. It handles datasets up to approximately 50,000 rows comfortably, depending on the browser and the machine. For anything larger, bytefreq (described below and in detail in Chapter 13) provides the same profiling engine without the browser's memory constraints.</p>
<h2 id="bytefreq-the-command-line-profiler"><a class="header" href="#bytefreq-the-command-line-profiler">bytefreq: The Command-Line Profiler</a></h2>
<p>For larger datasets, or for integration into automated pipelines, <strong>bytefreq</strong> is the CLI tool. It is implemented in Rust, multi-threaded using Rayon, and handles CSV, JSON, NDJSON, Excel (.xlsx, .xls, .xlsb, .ods), and Apache Parquet formats — including nested structs, list columns, and automatic timestamp conversion. It is designed for Unix-style pipe workflows and can process files with millions of rows.</p>
<p>The name is historical. The original bytefreq was written in awk in 2007 as a byte-frequency profiler — a tool for counting the frequency of each byte value in a file to determine encoding, delimiters, and character distributions. Over time, it evolved to include the mask-based profiling functions described in this book. The current Rust implementation is a ground-up rewrite that retains the name and the profiling philosophy while delivering the performance needed for large-scale local processing.</p>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<pre><code class="language-bash"># Install Rust if needed
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Install bytefreq from GitHub (with all format support)
cargo install --git https://github.com/minkymorgan/bytefreq --features parquet,excel
</code></pre>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre><code class="language-bash"># Profile a CSV file using high-grain Unicode masking
cat data.csv | bytefreq -g HU

# Profile with low-grain masking
cat data.csv | bytefreq -g LU

# Profile JSON data
cat data.json | bytefreq -f json

# Profile an Excel file
bytefreq -f excel --excel-path data.xlsx

# Profile a Parquet file
bytefreq -f parquet --parquet-path data.parquet

# Character frequency profiling (encoding inspection)
cat data.csv | bytefreq -r CP

# Generate flat enhanced output with quality assertions
cat data.csv | bytefreq -E
</code></pre>
<p>The <code>-E</code> flag produces the flat enhanced format described in Chapter 9: each field in the input is expanded into its family of parallel columns (<code>.raw</code>, <code>.HU</code>, <code>.LU</code>, <code>.Rules</code>), with automatically inferred quality assertions in the Rules column. This output can be piped to a file, loaded into a database, or consumed by a downstream pipeline.</p>
<p>bytefreq is designed for pipe-based workflows, which means it composes naturally with other Unix tools:</p>
<pre><code class="language-bash"># Profile the first 10,000 rows of a compressed file
zcat data.csv.gz | head -10000 | bytefreq -g HU

# Profile and extract only the masks for column 3
cat data.csv | bytefreq -g HU | jq '.columns[2].masks'

# Profile an Excel file (requires the excel feature)
cargo install --git https://github.com/minkymorgan/bytefreq --features excel
bytefreq -f excel --excel-path data.xlsx --sheet 1
</code></pre>
<p>bytefreq is open source, licensed under MIT, and available at <a href="https://github.com/minkymorgan/bytefreq">github.com/minkymorgan/bytefreq</a>.</p>
<h2 id="scaling-beyond-a-single-machine"><a class="header" href="#scaling-beyond-a-single-machine">Scaling Beyond a Single Machine</a></h2>
<p>For organisations working with billions of rows, neither a browser tool nor a single-machine CLI is sufficient. The good news is that mask-based profiling is inherently parallelisable, and there are concrete paths to scaling it without building a custom framework from scratch.</p>
<h3 id="why-it-parallelises-cleanly"><a class="header" href="#why-it-parallelises-cleanly">Why It Parallelises Cleanly</a></h3>
<p>The mask function is a stateless per-value transformation: it takes a string in and produces a mask out, with no dependencies on other values, other rows, or other columns. This makes it embarrassingly parallel — the same property that makes <code>map()</code> operations fast in Spark, Flink, Polars, and DuckDB. The assertion rules are equally independent: each rule examines a single (field_name, raw, HU, LU) tuple and produces a result with no side effects. The flat enhanced output is a wide table that maps naturally to columnar storage formats like Parquet, Delta Lake, and Apache Iceberg — the same lakehouse formats that carry the Hadoop-era denormalisation pattern (as described in Chapter 9) into modern cloud architectures.</p>
<h3 id="practical-scaling-options"><a class="header" href="#practical-scaling-options">Practical Scaling Options</a></h3>
<p><strong>DuckDB</strong> handles hundreds of millions of rows on a single machine with minimal setup. The bytefreq CLI can generate flat enhanced NDJSON output, which DuckDB reads natively. For datasets in the hundreds-of-millions range, this is often sufficient:</p>
<pre><code class="language-bash">cat large_dataset.csv | bytefreq -d ',' -E &gt; enhanced.ndjson
duckdb -c "
  CREATE TABLE dq AS SELECT * FROM read_ndjson_auto('enhanced.ndjson');
  SELECT \"postcode.HU\" AS mask, COUNT(*) AS cnt
  FROM dq GROUP BY mask ORDER BY cnt DESC LIMIT 20;
"
</code></pre>
<p><strong>Polars</strong> (Python or Rust) can apply the mask function as a custom expression across a LazyFrame, leveraging its multi-threaded query engine. For teams already using Polars for data processing, wrapping the bytefreq mask logic in a Polars UDF is straightforward.</p>
<p><strong>Apache Spark</strong> remains the standard for datasets measured in billions of rows. The mask function can be implemented as a Spark UDF (in Scala, Python, or — via the Spark Rust bindings — directly in Rust) and applied across a distributed DataFrame. The flat enhanced output writes naturally to Parquet with Snappy compression, partitioned by date or source for efficient downstream querying. The mask function described in Chapter 4 can be implemented in approximately 20 lines of Scala:</p>
<pre><code class="language-scala">val maskUDF = udf((value: String) =&gt; {
  if (value == null) ""
  else value.map {
    case c if c.isUpper =&gt; 'A'
    case c if c.isLower =&gt; 'a'
    case c if c.isDigit =&gt; '9'
    case c =&gt; c
  }.mkString
})

df.withColumn("name_HU", maskUDF(col("name")))
  .withColumn("name_LU", /* collapse consecutive same-class chars */)
  .write.parquet("enhanced_output/")
</code></pre>
<p><strong>Cloud-native options</strong> such as AWS Glue, GCP Dataflow, and Azure Synapse all support UDF-based transformations at scale. The mask function is small enough to inline in a serverless job definition — no external library dependencies required.</p>
<h3 id="the-product-ladder"><a class="header" href="#the-product-ladder">The Product Ladder</a></h3>
<p>The tools form a natural scaling path:</p>
<ol>
<li><strong>DataRadar</strong> (browser) — free, zero-install, up to ~50K rows. Perfect for quick checks, exploratory profiling, and environments where software installation is not possible.</li>
<li><strong>bytefreq</strong> (CLI) — free, open source, millions of rows. Supports CSV, JSON, Excel, and Parquet natively. For data engineers, CI/CD pipelines, and automated profiling workflows on a single machine.</li>
<li><strong>DuckDB / Polars</strong> — hundreds of millions of rows on a single machine, using bytefreq's flat enhanced output as the input.</li>
<li><strong>Spark / cloud engines</strong> — billions to trillions of rows, implementing the mask function as a UDF in a distributed framework.</li>
</ol>
<p>The profiling philosophy, the mask functions, and the flat enhanced output format are consistent across all of these. A profile generated by DataRadar in a browser is structurally identical to one generated by a Spark job on a thousand-node cluster. The techniques scale; you choose the engine that fits your volume.</p>
<h3 id="enterprise-support"><a class="header" href="#enterprise-support">Enterprise Support</a></h3>
<p>For organisations that need help implementing DQOR at scale, we offer commercial consulting and support through Gamakon. This includes bespoke implementations built on our fork of the <a href="https://github.com/UKHomeOffice/data-quality-profiler-and-rules-engine">Data Quality Profiler and Rules Engine</a>, an open-source Spark-based tool proven at enterprise scale. Contact <a href="mailto:andrew@gamakon.ai">andrew@gamakon.ai</a> for details.</p>
<h2 id="choosing-the-right-tool"><a class="header" href="#choosing-the-right-tool">Choosing the Right Tool</a></h2>
<p>The decision is usually straightforward. If you are exploring a dataset for the first time and want to understand its structure quickly, use DataRadar in the browser — it takes seconds and requires nothing to be installed. If you are profiling data as part of an automated pipeline, or the dataset is too large for the browser, use bytefreq on the command line.</p>
<p>In many organisations, both tools coexist. Data analysts use DataRadar for ad-hoc exploration. Data engineers use bytefreq in CI/CD pipelines and automated quality gates. The consistent profiling output across both means that quality rules and treatment functions developed using one tool can be deployed on the other.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quality-monitoring-profiling-reports-as-fact-tables"><a class="header" href="#quality-monitoring-profiling-reports-as-fact-tables">Quality Monitoring: Profiling Reports as Fact Tables</a></h1>
<p>The introduction described the vision: exit checks, entrance checks, line of sight, and accountability through measurement. This chapter describes the implementation.</p>
<p>The key insight is that the profiling reports generated by bytefreq and DataRadar — both the DQ mask frequency tables and the CP character profiling reports — are already structured as fact tables. They have dimensions (column name, mask or character, data feed identifier, timestamp) and measures (count, percentage, coverage). Stored consistently over time, they become a timeseries database of data quality telemetry that can be queried, aggregated, and visualised like any other operational metric.</p>
<h2 id="the-operating-model"><a class="header" href="#the-operating-model">The Operating Model</a></h2>
<p>Before diving into the technical details, it is worth stepping back to see where quality monitoring fits in a data operating model.</p>
<p><img src="DataOperatingModel_Capabilities_202512.png" alt="Data Operating Model Capabilities" /></p>
<p>The diagram above shows a reference data operating model organised as a set of capabilities. Data Quality Discovery — the mask-based profiling described in this book — sits as a foundational capability that feeds into Data Quality Monitoring, which in turn feeds into Performance Reporting and Service Assurance. The profiling reports are the raw telemetry; the monitoring architecture is the plumbing that turns telemetry into KPIs; the service assurance layer is where those KPIs drive accountability.</p>
<p>This is not a technology architecture. It is an organisational capability map. The tools described in this book — bytefreq, DataRadar, DuckDB — are implementations. The capabilities they serve are what matter to a CDO or CTO.</p>
<h2 id="reports-as-fact-tables"><a class="header" href="#reports-as-fact-tables">Reports as Fact Tables</a></h2>
<p>A standard DQ profile from bytefreq looks like this:</p>
<pre><code>=== Column: postcode ===
Mask                Count   Example
A9 9A               8,412   SW1A 1AA
A99 9A              1,203   M60 1NW
A9A 9A                892   W1D 3QU
9                     312   N/A
</code></pre>
<p>In machine-readable mode (JSON output), this becomes a structured record:</p>
<pre><code class="language-json">{
  "column": "postcode",
  "masks": [
    {"mask": "A9 9A", "count": 8412, "example": "SW1A 1AA"},
    {"mask": "A99 9A", "count": 1203, "example": "M60 1NW"},
    {"mask": "A9A 9A", "count": 892, "example": "W1D 3QU"},
    {"mask": "9", "count": 312, "example": "N/A"}
  ],
  "total": 10819,
  "mask_cardinality": 4
}
</code></pre>
<p>Add a feed identifier and a timestamp, and you have a fact record:</p>
<pre><code class="language-json">{
  "feed": "council-planning-applications",
  "profiled_at": "2025-12-19T08:00:00Z",
  "column": "postcode",
  "masks": [...],
  "total": 10819,
  "mask_cardinality": 4,
  "coverage_top1": 0.777,
  "population_rate": 0.985
}
</code></pre>
<p>This is a dimensional fact table. The feed, timestamp, and column are the dimensions. The mask distribution, cardinality, coverage, and population rate are the measures. Store these records consistently and you have a timeseries.</p>
<h2 id="the-directory-pattern"><a class="header" href="#the-directory-pattern">The Directory Pattern</a></h2>
<p>The simplest implementation is a directory of files, partitioned by date and feed:</p>
<pre><code>quality-reports/
  2025-12-18/
    council-planning-applications.dq.ndjson
    council-planning-applications.cp.ndjson
    nhs-patient-demographics.dq.ndjson
    nhs-patient-demographics.cp.ndjson
  2025-12-19/
    council-planning-applications.dq.ndjson
    council-planning-applications.cp.ndjson
    nhs-patient-demographics.dq.ndjson
    nhs-patient-demographics.cp.ndjson
</code></pre>
<p>Each file contains the profiling report for one feed on one date. The DQ file contains mask frequency tables per column. The CP file contains character frequency tables. Both are NDJSON — one JSON object per column.</p>
<p>This is the same pool-and-glob pattern described in the DataRadar walkthrough chapter, applied to profiling reports rather than flat enhanced exports. The storage cost is negligible — profiling reports are small (kilobytes, not megabytes) because they contain aggregated frequencies, not individual records.</p>
<h2 id="querying-the-timeseries"><a class="header" href="#querying-the-timeseries">Querying the Timeseries</a></h2>
<p>DuckDB's file glob turns this directory into a queryable timeseries with no ingestion pipeline:</p>
<pre><code class="language-sql">-- Coverage trend for a specific column across all dates
SELECT
    profiled_at::DATE AS report_date,
    coverage_top1
FROM read_ndjson_auto('quality-reports/*/*.dq.ndjson', filename=true)
WHERE feed = 'council-planning-applications'
  AND column = 'postcode'
ORDER BY report_date;
</code></pre>
<pre><code class="language-sql">-- Feeds where mask cardinality increased (new patterns appearing)
SELECT
    feed,
    column,
    profiled_at::DATE AS report_date,
    mask_cardinality
FROM read_ndjson_auto('quality-reports/*/*.dq.ndjson')
WHERE mask_cardinality &gt; 10
ORDER BY feed, column, report_date;
</code></pre>
<pre><code class="language-sql">-- Population rate drop detection (mandatory field becoming sparse)
WITH trends AS (
    SELECT
        feed,
        column,
        profiled_at::DATE AS report_date,
        population_rate,
        LAG(population_rate) OVER (
            PARTITION BY feed, column ORDER BY profiled_at
        ) AS prev_rate
    FROM read_ndjson_auto('quality-reports/*/*.dq.ndjson')
)
SELECT * FROM trends
WHERE prev_rate - population_rate &gt; 0.05
ORDER BY report_date DESC;
</code></pre>
<p>These are the queries that power a quality dashboard. No database to maintain, no ingestion pipeline to build — just a directory of small JSON files and a query engine that reads them on demand.</p>
<h2 id="exit-checks-and-entrance-checks"><a class="header" href="#exit-checks-and-entrance-checks">Exit Checks and Entrance Checks</a></h2>
<p>The monitoring architecture has two deployment points.</p>
<h3 id="exit-checks-producer-side"><a class="header" href="#exit-checks-producer-side">Exit Checks (Producer Side)</a></h3>
<p>An exit check runs after a data pipeline produces its output, before the output is published to consumers. In a CI/CD pipeline, this is a post-build step:</p>
<pre><code class="language-bash">#!/bin/bash
# exit-check.sh — run after data pipeline completes
FEED="council-planning-applications"
DATE=$(date +%Y-%m-%d)
OUTPUT_DIR="quality-reports/${DATE}"
mkdir -p "${OUTPUT_DIR}"

# Profile the output
cat pipeline-output.csv \
  | bytefreq -d ',' -f tabular \
  &gt; "${OUTPUT_DIR}/${FEED}.dq.ndjson"

# Character profile
cat pipeline-output.csv \
  | bytefreq -d ',' -r CP \
  &gt; "${OUTPUT_DIR}/${FEED}.cp.ndjson"

# Check for regressions against previous day
# (custom script that compares today's report with yesterday's)
python3 check-regressions.py \
  --today "${OUTPUT_DIR}/${FEED}.dq.ndjson" \
  --baseline "quality-reports/$(date -d yesterday +%Y-%m-%d)/${FEED}.dq.ndjson"
</code></pre>
<p>The exit check produces the quality report and optionally runs regression detection — comparing today's profile against yesterday's to flag significant changes. If the regression check fails (coverage dropped below threshold, new unexpected masks appeared, population rate fell), the pipeline can halt publication and alert the team.</p>
<h3 id="entrance-checks-consumer-side"><a class="header" href="#entrance-checks-consumer-side">Entrance Checks (Consumer Side)</a></h3>
<p>An entrance check runs when a data feed is received, before it enters the consumer's pipeline:</p>
<pre><code class="language-bash">#!/bin/bash
# entrance-check.sh — run when feed arrives
FEED="council-planning-applications"
DATE=$(date +%Y-%m-%d)
OUTPUT_DIR="quality-reports/${DATE}"
mkdir -p "${OUTPUT_DIR}"

# Profile the received data
cat received-feed.csv \
  | bytefreq -d ',' -E \
  &gt; "${OUTPUT_DIR}/${FEED}.enhanced.ndjson"

cat received-feed.csv \
  | bytefreq -d ',' \
  &gt; "${OUTPUT_DIR}/${FEED}.dq.ndjson"

# Compare against the producer's exit check report
# (if available via shared quality report exchange)
python3 compare-exit-entrance.py \
  --exit "producer-reports/${DATE}/${FEED}.dq.ndjson" \
  --entrance "${OUTPUT_DIR}/${FEED}.dq.ndjson"
</code></pre>
<p>When both exit and entrance checks are in place, discrepancies between them reveal problems in transit — encoding changes, truncation, field reordering, or lossy transformations that happened between the producer's output and the consumer's input.</p>
<h2 id="kpis-and-the-quality-dashboard"><a class="header" href="#kpis-and-the-quality-dashboard">KPIs and the Quality Dashboard</a></h2>
<p>From the timeseries of profiling reports, several KPIs emerge naturally:</p>
<p><strong>Coverage stability</strong> — Is the top-1 mask coverage for each column holding steady over time? A sudden drop means a new pattern has appeared in significant volume.</p>
<p><strong>Mask cardinality trend</strong> — Is the number of distinct masks per column increasing? A gradual increase may indicate format drift. A sudden spike may indicate a data source change or a pipeline bug.</p>
<p><strong>Population rate</strong> — What percentage of each field is populated? Track this daily. A mandatory field that drops from 99.5% to 80% is an early warning of an upstream collection problem.</p>
<p><strong>New mask detection</strong> — Did any mask appear today that has never appeared before in this feed? New masks are the single most valuable alert in quality monitoring — they indicate structural change, which may be benign (a new valid format) or problematic (data corruption, source system change, encoding error).</p>
<p><strong>Assertion pass rate</strong> — For columns where the rules engine runs (as described in the Assertion Rules Engine chapter), what percentage of values pass their assertions? An IBAN column where <code>is_valid_iban</code> drops from 98% to 85% deserves immediate investigation.</p>
<p>These KPIs are not exotic. They are the data quality equivalent of uptime, latency, and error rate in service monitoring. The difference is that most organisations do not measure them consistently — not because the measurement is hard, but because nobody set up the infrastructure to collect and store the reports. The directory-of-profiles pattern described here makes that infrastructure trivially simple.</p>
<h2 id="line-of-sight-from-impact-to-source"><a class="header" href="#line-of-sight-from-impact-to-source">Line of Sight: From Impact to Source</a></h2>
<p>The monitoring architecture becomes genuinely powerful when connected to data lineage.</p>
<p>Consider a scenario: a downstream analytics team discovers that 5% of their geospatial analyses are failing because postcodes cannot be geocoded. The entrance check report for the feed shows that 5% of postcode values have the mask <code>aaaa</code> — alphabetic strings like <code>null</code>, <code>none</code>, <code>test</code>. The timeseries shows this started three weeks ago. The feed comes from Council X. Council X's exit check report confirms the same pattern — their collection system started accepting free-text in the postcode field after a software update.</p>
<p>With lineage metadata connecting the feed to its downstream consumers, the impact is quantifiable: 5% of records × N downstream analyses × cost per failed analysis = £Y. This is not a vague "your data is bad" complaint. It is a specific, evidenced, costed impact statement that can be presented to Council X's management.</p>
<p>This is the accountability loop that the introduction described. The timeseries provides the evidence. The lineage provides the traceability. The profiling reports provide the specificity. Together, they enable the conversation: "Your department's data collection change on this date caused this downstream impact costing this amount. Here is the evidence. How shall we fix it?"</p>
<h2 id="fit-for-the-journey"><a class="header" href="#fit-for-the-journey">Fit for the Journey</a></h2>
<p>The traditional framing of data quality is <strong>fit for purpose</strong> — can the immediate consumer use the data for their intended task? This is necessary but insufficient.</p>
<p>Data in a modern government or enterprise rarely has one consumer. A dataset collected at a local council may flow through a regional aggregator, a central government data platform, a statistical publication pipeline, a machine learning feature store, and a public API before reaching its final consumers. At each stage, the data is read, interpreted, transformed, and forwarded. At each stage, structural assumptions are made. At each stage, quality issues can be introduced, amplified, or — if the right checks are in place — detected and addressed.</p>
<p><strong>Fit for the journey</strong> means the data carries enough structural metadata to be understood and validated at every stage. The flat enhanced format (described in the Flat Enhanced Format chapter) provides this at the record level — each value carries its masks and assertions alongside the raw data. The profiling reports described in this chapter provide it at the feed level — each delivery carries a machine-readable quality certificate that downstream consumers can compare against their expectations.</p>
<p>When a data feed arrives with its profiling report, the consumer does not need to re-profile from scratch (though they may choose to, as an entrance check). They can read the report, compare it against the baseline, and make an informed decision: accept, reject, or accept with caveats. The report is a passport — a document that accompanies the data on its journey and records its structural state at each checkpoint.</p>
<h2 id="discovery-before-exploration-1"><a class="header" href="#discovery-before-exploration-1">Discovery Before Exploration</a></h2>
<p>One final point about where this monitoring architecture sits in the broader data quality landscape.</p>
<p>Mask-based profiling is not a replacement for tools like Great Expectations, dbt tests, Pandas profiling, or Soda. Those tools are excellent at <em>validating known expectations</em>: is this column non-null? Does this value fall within a range? Does this distribution match the historical baseline? They are exploratory and validation tools that assume you already understand the structure of your data well enough to write meaningful tests.</p>
<p>Data Quality Discovery — the mask-based profiling step — comes <em>before</em> exploration. It answers the question that the exploratory tools cannot: <strong>what does this data actually look like?</strong> You cannot write a Great Expectations test for a column whose structure you have not yet discovered. You cannot explore what you cannot read.</p>
<p>The monitoring architecture described in this chapter adds the time dimension to that discovery. A single profile tells you what the data looks like today. A timeseries of profiles tells you how it is changing. The exit and entrance checks tell you where problems are being introduced. The KPIs tell you whether quality is improving or degrading. And the lineage integration tells you who is affected and what it costs.</p>
<p>These are the building blocks for assuring a data service — not just a file, but the entire flow of data through an organisation. The tools in the following chapters show how to implement each building block. The architecture is how they fit together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-dataradar-a-walkthrough"><a class="header" href="#using-dataradar-a-walkthrough">Using DataRadar: A Walkthrough</a></h1>
<p>The previous chapters described the theory: masks, grain levels, population analysis, error codes, treatment functions, and the flat enhanced format. This chapter puts it into practice using DataRadar, the browser-based profiling tool. We will walk through a complete profiling session, from uploading a file to interpreting the output and exporting the results.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Open <a href="https://dataradar.co.uk">dataradar.co.uk</a> in any modern browser. There is nothing to install, no account to create, and no data leaves your machine — all processing happens client-side using WebAssembly.</p>
<p>The interface presents a file upload area at the top. You can either click to browse for a file, or drag and drop one onto the page. DataRadar supports four input formats:</p>
<ul>
<li><strong>CSV / Tabular</strong> — comma, pipe, tab, semicolon, or custom delimited files</li>
<li><strong>Excel</strong> — .xlsx, .xls, .xlsb, and .ods spreadsheets (with sheet selection)</li>
<li><strong>JSON / NDJSON</strong> — newline-delimited JSON (one record per line), or standard JSON arrays</li>
<li><strong>URLs</strong> — paste a URL to a JSON API endpoint and DataRadar will fetch and profile the response directly</li>
</ul>
<p>For CSV files, the delimiter is auto-detected but can be overridden. For Excel files, you can select which sheet to profile and whether the first row contains headers.</p>
<h2 id="the-report-options"><a class="header" href="#the-report-options">The Report Options</a></h2>
<p>Before running the profiler, three settings control what output you get:</p>
<h3 id="report-type"><a class="header" href="#report-type">Report Type</a></h3>
<ul>
<li><strong>Data Quality (DQ)</strong> — the default. Generates mask-based frequency profiles for each column, showing the structural patterns and their counts. This is what you want for the workflow described in this book.</li>
<li><strong>Character Profiling (CP)</strong> — generates byte-level or code-point-level frequency analysis of the file content. This is the forensic mode described in Chapter 5, useful for diagnosing encoding issues, identifying unexpected control characters, or determining the character sets present in the data.</li>
</ul>
<h3 id="masking-level"><a class="header" href="#masking-level">Masking Level</a></h3>
<p>Four grain levels are available:</p>
<ul>
<li><strong>High Unicode (HU)</strong> — detailed masks with full Unicode character class support. Every character maps individually. This is the default and the most generally useful mode.</li>
<li><strong>Low Unicode (LU)</strong> — compressed masks where consecutive characters of the same class are collapsed. Use this for initial discovery when you want to see structural families rather than exact formats.</li>
<li><strong>High ASCII (H)</strong> — the classic A/a/9 mask at full resolution, treating all non-ASCII bytes as "other." Useful for legacy data or when you specifically want ASCII-only profiling.</li>
<li><strong>Low ASCII (L)</strong> — compressed ASCII masks. The original bytefreq mode, equivalent to the <code>sed</code> one-liner described in Chapter 4.</li>
</ul>
<p>For most work, start with <strong>LU</strong> (Low Unicode) to get the broad structural picture, then switch to <strong>HU</strong> (High Unicode) to examine specific columns in detail.</p>
<h3 id="output-format"><a class="header" href="#output-format">Output Format</a></h3>
<p>The profiling results can be displayed and exported in several formats:</p>
<ul>
<li><strong>Human-readable Text</strong> — a formatted report suitable for reading in the browser or pasting into a document.</li>
<li><strong>JSON</strong> — structured output for programmatic consumption.</li>
<li><strong>Markdown</strong> — formatted for inclusion in documentation or GitHub README files.</li>
</ul>
<h2 id="running-a-profile"><a class="header" href="#running-a-profile">Running a Profile</a></h2>
<p>With a file loaded and the options set, click <strong>Analyze Data</strong>. The profiler runs in the browser and results appear below the controls.</p>
<p>The output is organised by column. For each column in the input data, the profiler shows:</p>
<ul>
<li>The <strong>column name</strong> (or column number for headerless files).</li>
<li>The <strong>total count</strong> of values profiled.</li>
<li>A <strong>frequency table</strong> of masks, sorted by count descending.</li>
</ul>
<p>For example, profiling a CSV with a <code>phone_number</code> column at High Unicode grain might produce:</p>
<pre><code>=== phone_number (1,000 values) ===

Mask                    Count    %
99999 999999              812   81.2%
+99 9999 999999            95    9.5%
9999 999 9999              42    4.2%
(999) 999-9999             31    3.1%
aaaa                       12    1.2%
99999999999                 4    0.4%
Aaaa aaa Aaaa               2    0.2%
                             2    0.2%
</code></pre>
<p>This is the population profile described in Chapter 6. The dominant mask (<code>99999 999999</code>) represents UK mobile numbers. The long tail reveals international formats, US formats, placeholders (<code>aaaa</code> — probably <code>null</code> or <code>none</code>), names in the wrong field (<code>Aaaa aaa Aaaa</code>), and empty strings.</p>
<h2 id="inspecting-the-data"><a class="header" href="#inspecting-the-data">Inspecting the Data</a></h2>
<p>Before running the full profile, DataRadar offers a <strong>data preview</strong> that shows the first rows of the parsed file. This is worth checking — it confirms that the delimiter was detected correctly, that headers were identified, and that the columns are aligned. If the preview looks wrong (columns misaligned, headers appearing as data rows, or delimiter issues), adjust the format settings and re-check before profiling.</p>
<p>For JSON input, the preview shows the flattened field paths, which is useful for understanding the structure of nested data before profiling it.</p>
<h2 id="the-flat-enhanced-export"><a class="header" href="#the-flat-enhanced-export">The Flat Enhanced Export</a></h2>
<p>The most powerful output mode is the <strong>Flat Enhanced JSON</strong> export, selected from the Output Format dropdown. This produces the flat enhanced format described in Chapter 9: for every field in every record, the output includes the parallel column families:</p>
<pre><code class="language-json">{
  "phone_number.raw": "+44 7700 900123",
  "phone_number.HU": "+99 9999 999999",
  "phone_number.LU": "+9 9 9",
  "phone_number.Rules": {
    "string_length": 15,
    "poss_postal_country": null
  },
  "postcode.raw": "SW1A 1AA",
  "postcode.HU": "AA9A 9AA",
  "postcode.LU": "A9A 9A",
  "postcode.Rules": {
    "string_length": 8,
    "is_uk_postcode": true,
    "poss_postal_country": ["UK"]
  }
}
</code></pre>
<p>Each record in the input becomes a single JSON line in the output, with every field expanded into its <code>.raw</code>, <code>.HU</code>, <code>.LU</code>, and <code>.Rules</code> sub-columns. This is the file you would load into Pandas, Polars, DuckDB, or any other analytical tool for downstream processing.</p>
<h3 id="loading-flat-enhanced-output-in-python"><a class="header" href="#loading-flat-enhanced-output-in-python">Loading Flat Enhanced Output in Python</a></h3>
<pre><code class="language-python">import pandas as pd

df = pd.read_json('output.ndjson', lines=True)

# Use the raw values
df['postcode.raw']

# Use the mask for quality checks
df['postcode.HU']

# Use the Rules suggestions
df['postcode.Rules'].apply(lambda r: r.get('is_uk_postcode') if r else None)
</code></pre>
<h3 id="loading-in-duckdb"><a class="header" href="#loading-in-duckdb">Loading in DuckDB</a></h3>
<pre><code class="language-sql">SELECT
    "postcode.raw" AS postcode,
    "postcode.HU" AS mask,
    "postcode.Rules"-&gt;&gt;'is_uk_postcode' AS is_valid
FROM read_ndjson_auto('output.ndjson');
</code></pre>
<p>The real trick comes at scale. In practice, you pool hundreds of small enhanced output files into a single directory — one per source file, one per batch, one per day — and use DuckDB's file glob to query across all of them in one shot:</p>
<pre><code class="language-sql">SELECT
    "postcode.raw" AS postcode,
    "postcode.HU" AS mask,
    "postcode.Rules"-&gt;&gt;'is_uk_postcode' AS is_valid,
    filename
FROM read_ndjson_auto('exports/*.ndjson', filename=true)
WHERE "postcode.Rules"-&gt;&gt;'is_uk_postcode' = 'false';
</code></pre>
<p>This is the pattern that makes mask-based profiling operational. You do not need to merge files, build a database, or maintain an ingestion pipeline. You just drop enhanced exports into a directory and query the lot. DuckDB handles the file glob, schema unification, and columnar scanning — and because the flat enhanced format is regular NDJSON with consistent column names, it all just works. A directory of exports becomes a queryable quality lake with zero infrastructure.</p>
<h2 id="working-with-json-and-api-data"><a class="header" href="#working-with-json-and-api-data">Working With JSON and API Data</a></h2>
<p>One of DataRadar's distinguishing features is its ability to profile JSON data directly, including data fetched from API endpoints. This is particularly useful for open data projects where the data arrives as GeoJSON, REST API responses, or NDJSON feeds.</p>
<p>To profile an API endpoint, paste the URL into the URL field and click fetch. DataRadar will retrieve the response, detect the format, and present it for profiling. If the response is a paginated API response (a single JSON object containing an array), DataRadar detects this and offers to extract and convert the array to NDJSON format automatically.</p>
<p>For example, profiling the USGS earthquake feed:</p>
<pre><code>https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson
</code></pre>
<p>DataRadar will detect the nested GeoJSON structure, flatten the <code>properties</code> and <code>geometry</code> objects into dot-notation field paths (<code>properties.time</code>, <code>properties.mag</code>, <code>geometry.coordinates.0</code>), and profile each flattened field. The flat enhanced export then produces output like:</p>
<pre><code class="language-json">{
  "properties.time.raw": "1766181640870",
  "properties.time.HU": "9999999999999",
  "properties.time.LU": "9",
  "properties.time.Rules": {
    "string_length": 13,
    "is_numeric": true
  }
}
</code></pre>
<p>From this output, it is immediately clear that the <code>time</code> field contains 13-digit numeric values — Unix timestamps in milliseconds. A downstream consumer can parse these into datetimes with confidence, knowing that the mask confirms structural consistency across all records.</p>
<h2 id="multilingual-data"><a class="header" href="#multilingual-data">Multilingual Data</a></h2>
<p>DataRadar handles international data without configuration. When profiling a dataset containing names, addresses, or descriptions in non-Latin scripts, the Unicode-aware masking produces structurally meaningful masks for every script:</p>
<ul>
<li>Chinese characters (Lo category) mask to <code>a</code>, so 北京饭店 becomes <code>aaaa</code></li>
<li>Arabic text with spaces preserves word boundaries: <code>a a a</code></li>
<li>Cyrillic names follow the same uppercase/lowercase distinction as Latin: <code>Aaaaaaa</code></li>
<li>Mixed-script fields (Latin + CJK, Arabic + digits) reveal the mixing in the mask</li>
</ul>
<p>The profiler also reports detected scripts per field, flagging columns that contain mixed scripts — which may indicate encoding issues, data from multiple sources, or legitimate multilingual content.</p>
<h2 id="the-workflow-in-practice"><a class="header" href="#the-workflow-in-practice">The Workflow in Practice</a></h2>
<p>A typical DataRadar session follows the two-pass workflow described in Chapter 6:</p>
<ol>
<li><strong>Load the file</strong> and check the data preview to confirm correct parsing.</li>
<li><strong>Run a Low Unicode (LU) profile</strong> to survey the structural landscape. Scan each column's masks to understand the dominant patterns and spot obvious anomalies.</li>
<li><strong>Switch to High Unicode (HU)</strong> and re-profile to examine specific columns where format precision matters (postcodes, phone numbers, dates, identifiers).</li>
<li><strong>Export Flat Enhanced JSON</strong> for any data you want to process further — the export preserves raw values, masks, and rule suggestions for every record.</li>
<li><strong>Load the export</strong> into your analytical tool of choice (Pandas, DuckDB, Excel) and proceed with your analysis, using the mask and Rules columns to guide quality decisions.</li>
</ol>
<p>The entire process — from opening the browser to having a flat enhanced export loaded in a notebook — typically takes less than five minutes. No installation, no configuration, no data leaving your machine.</p>
<p>For larger datasets — anything beyond roughly 50,000 rows — the browser's memory constraints become the limiting factor. If you hit this ceiling, switch to bytefreq on the command line (see Chapter 13), which handles millions of rows with the same profiling engine and the same output format. DataRadar is for exploration and quick checks; bytefreq is for scale.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-bytefreq-installation-build-and-command-line-reference"><a class="header" href="#using-bytefreq-installation-build-and-command-line-reference">Using bytefreq: Installation, Build, and Command-Line Reference</a></h1>
<p>This chapter covers the practical side of bytefreq: how to install it, how to build it from source, and how to use it from the command line. If the previous chapters described the <em>what</em> and <em>why</em> of mask-based profiling, this chapter covers the <em>how</em>.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>bytefreq is written in Rust and built using Cargo, Rust's package manager and build system. If you do not already have Rust installed, the standard installation method is:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>This installs <code>rustc</code> (the compiler), <code>cargo</code> (the build tool), and <code>rustup</code> (the toolchain manager). Follow the on-screen prompts — the defaults are fine for most systems. After installation, restart your terminal or run <code>source $HOME/.cargo/env</code> to make the tools available.</p>
<p>Verify the installation:</p>
<pre><code class="language-bash">rustc --version
cargo --version
</code></pre>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>There are two ways to install bytefreq.</p>
<h3 id="from-github-recommended"><a class="header" href="#from-github-recommended">From GitHub (recommended)</a></h3>
<pre><code class="language-bash">cargo install --git https://github.com/minkymorgan/bytefreq
</code></pre>
<p>This clones the repository, compiles the release binary, and installs it to <code>~/.cargo/bin/</code>, which should already be on your PATH if Rust is installed correctly.</p>
<h3 id="from-a-local-clone"><a class="header" href="#from-a-local-clone">From a local clone</a></h3>
<pre><code class="language-bash">git clone https://github.com/minkymorgan/bytefreq.git
cd bytefreq
cargo build --release
cargo install --path .
</code></pre>
<p>Building from a local clone is useful if you intend to modify the code — for example, to add custom assertion rules as described in the previous chapter.</p>
<h3 id="verify"><a class="header" href="#verify">Verify</a></h3>
<pre><code class="language-bash">bytefreq --version
</code></pre>
<h2 id="input-formats"><a class="header" href="#input-formats">Input Formats</a></h2>
<p>bytefreq supports four input formats:</p>
<p><strong>Tabular</strong> (<code>-f tabular</code>, the default) — delimited text where the first line is a header row and subsequent lines are data records. The delimiter defaults to pipe (<code>|</code>) but can be set to any character using the <code>-d</code> flag. Tabular data is read from standard input (stdin).</p>
<p><strong>JSON</strong> (<code>-f json</code>) — newline-delimited JSON (NDJSON), where each line is a complete JSON object. bytefreq flattens nested structures using dot-notation paths (e.g., <code>customer.address.postcode</code>), handling arrays and nested objects to a configurable depth. JSON data is read from standard input.</p>
<p><strong>Excel</strong> (<code>-f excel --excel-path file.xlsx</code>) — native Excel file support for <code>.xlsx</code>, <code>.xls</code>, <code>.xlsb</code>, and <code>.ods</code> formats. Requires building with the <code>excel</code> feature flag (<code>cargo install --git https://github.com/minkymorgan/bytefreq --features excel</code>). By default, bytefreq reads the first sheet; use <code>--excel-sheet</code> to select a specific sheet by index (0-based).</p>
<p><strong>Parquet</strong> (<code>-f parquet --parquet-path file.parquet</code>) — native Apache Parquet file support. Requires building with the <code>parquet</code> feature flag (<code>cargo install --git https://github.com/minkymorgan/bytefreq --features parquet</code>). Parquet files are converted internally to JSON lines, so all JSON features — dot-notation nested paths, array index handling (<code>-a</code>), path depth limiting (<code>-p</code>), and enhanced output — work with Parquet data. Nested structs produce dot-notation paths (<code>user.address.city</code>), and list columns produce indexed array paths (<code>scores[0]</code>, <code>scores[1]</code>). Timestamps are automatically converted to ISO 8601 strings, and all standard Arrow data types are supported.</p>
<p>To install with all optional format support:</p>
<pre><code class="language-bash">cargo install --git https://github.com/minkymorgan/bytefreq --features parquet,excel
</code></pre>
<p>A note on CSV: bytefreq defaults to pipe-delimited input rather than comma-delimited, because pipe characters appear far less frequently in real-world data values and thus produce fewer parsing ambiguities. If your data is comma-delimited, pass <code>-d ','</code>. For complex CSV files with quoted fields, escaped delimiters, or embedded newlines, bytefreq uses a proper CSV parser that handles quoted fields and escape sequences correctly.</p>
<h2 id="command-line-reference"><a class="header" href="#command-line-reference">Command-Line Reference</a></h2>
<pre><code>bytefreq [OPTIONS]

OPTIONS:
  -g, --grain &lt;GRAIN&gt;          Masking grain level [default: LU]
                                 H  - High grain ASCII (A/a/9)
                                 L  - Low grain ASCII (compressed)
                                 U  - High grain Unicode (HU)
                                 LU - Low grain Unicode (compressed)

  -d, --delimiter &lt;DELIM&gt;      Field delimiter [default: |]

  -f, --format &lt;FORMAT&gt;        Input format [default: tabular]
                                 tabular - Delimited text with header
                                 json    - Newline-delimited JSON
                                 excel   - Excel file (requires --excel-path)
                                 parquet - Parquet file (requires --parquet-path)

      --excel-path &lt;PATH&gt;      Path to Excel file (with -f excel)
      --excel-sheet &lt;INDEX&gt;    Sheet index, 0-based [default: 0]
      --parquet-path &lt;PATH&gt;    Path to Parquet file (with -f parquet)

  -r, --report &lt;REPORT&gt;        Report type [default: DQ]
                                 DQ - Data Quality (mask frequencies)
                                 CP - Character Profiling (byte/codepoint frequencies)

  -p, --pathdepth &lt;DEPTH&gt;      JSON nesting depth [default: 9]

  -a, --remove-array-numbers   Collapse array indices in JSON paths

  -e, --enhanced-output        Output flat enhanced JSON (nested format)

  -E, --flat-enhanced           Output flat enhanced JSON (flattened format)

  -h, --help                   Print help
  -V, --version                Print version
</code></pre>
<h2 id="basic-profiling"><a class="header" href="#basic-profiling">Basic Profiling</a></h2>
<p>The most common use case is profiling a delimited file at the default grain level (Low Unicode):</p>
<pre><code class="language-bash">cat data.csv | bytefreq -d ','
</code></pre>
<p>The output is a human-readable frequency report, organised by column. For each column, bytefreq lists the unique masks found, their occurrence counts, and a randomly sampled example value for each mask (selected using reservoir sampling to ensure a truly random representative):</p>
<pre><code>=== Column: postcode ===
Mask                Count   Example
A9 9A               8,412   SW1A 1AA
A99 9A              1,203   M60 1NW
A9A 9A                892   W1D 3QU
AA9 9A                567   EC2R 8AH
9                     312   N/A
                       44
</code></pre>
<p>The example column is particularly useful during exploratory profiling — it lets you see an actual value behind each mask without having to go back to the raw data.</p>
<h2 id="grain-levels-in-practice"><a class="header" href="#grain-levels-in-practice">Grain Levels in Practice</a></h2>
<h3 id="low-unicode-lu--the-default"><a class="header" href="#low-unicode-lu--the-default">Low Unicode (LU) — the default</a></h3>
<pre><code class="language-bash">cat data.csv | bytefreq -d ',' -g LU
</code></pre>
<p>Consecutive characters of the same Unicode class are collapsed. Good for initial discovery: how many structural families exist in each column?</p>
<h3 id="high-unicode-hu--exact-formats"><a class="header" href="#high-unicode-hu--exact-formats">High Unicode (HU) — exact formats</a></h3>
<pre><code class="language-bash">cat data.csv | bytefreq -d ',' -g HU
</code></pre>
<p>Every character maps individually. Good for precision work: what exact postcode formats are present? What date formats are in use?</p>
<h3 id="high-ascii-h-and-low-ascii-l--legacy-modes"><a class="header" href="#high-ascii-h-and-low-ascii-l--legacy-modes">High ASCII (H) and Low ASCII (L) — legacy modes</a></h3>
<pre><code class="language-bash">cat data.csv | bytefreq -d ',' -g H
cat data.csv | bytefreq -d ',' -g L
</code></pre>
<p>The original A/a/9 masks without Unicode awareness. All non-ASCII characters are left unmapped. Useful when profiling data known to be ASCII-only, or when comparing results against the legacy awk-based bytefreq.</p>
<h2 id="character-profiling-1"><a class="header" href="#character-profiling-1">Character Profiling</a></h2>
<p>The <code>-r CP</code> flag switches from mask-based profiling to character-level frequency analysis:</p>
<pre><code class="language-bash">cat data.csv | bytefreq -d ',' -r CP
</code></pre>
<p>This reports the frequency of every Unicode code point found in the file, alongside the character itself and its Unicode name. The output is sorted by frequency and grouped by Unicode General Category (Letter, Number, Punctuation, Symbol, Separator, Other).</p>
<p>Character profiling is the forensic tool. Use it when you need to:</p>
<ul>
<li><strong>Determine the encoding</strong> of an unknown file — UTF-8, Latin-1, Windows-1252, and mixed encodings each produce characteristic byte patterns.</li>
<li><strong>Find invisible characters</strong> — zero-width spaces, byte order marks, soft hyphens, and other non-printing characters that cause subtle parsing failures.</li>
<li><strong>Detect control characters</strong> — tabs, carriage returns, null bytes, and other control characters in fields that should contain only printable text.</li>
<li><strong>Understand the script composition</strong> — what proportion of the text is Latin, Cyrillic, CJK, Arabic, or other scripts?</li>
</ul>
<h2 id="json-profiling"><a class="header" href="#json-profiling">JSON Profiling</a></h2>
<p>For JSON data, use <code>-f json</code>:</p>
<pre><code class="language-bash">cat data.ndjson | bytefreq -f json
</code></pre>
<p>bytefreq expects newline-delimited JSON — one complete JSON object per line. It flattens nested structures into dot-notation paths:</p>
<pre><code class="language-json">{"customer": {"address": {"postcode": "SW1A 1AA"}}}
</code></pre>
<p>becomes a column named <code>customer.address.postcode</code> with value <code>SW1A 1AA</code>.</p>
<h3 id="controlling-nesting-depth"><a class="header" href="#controlling-nesting-depth">Controlling nesting depth</a></h3>
<p>For deeply nested JSON, the <code>-p</code> flag controls how many levels of nesting bytefreq will traverse. Consider this input:</p>
<pre><code class="language-json">{"org": {"dept": {"team": {"lead": {"name": "Alice"}}}}}
</code></pre>
<p>With the default depth (<code>-p 9</code>), this produces a column named <code>org.dept.team.lead.name</code>. Limiting the depth changes what bytefreq sees:</p>
<pre><code class="language-bash"># Full depth — profiles org.dept.team.lead.name
cat data.ndjson | bytefreq -f json

# Depth 3 — profiles org.dept.team (stops here, treats remaining nesting as a value)
cat data.ndjson | bytefreq -f json -p 3

# Depth 1 — profiles org (the entire nested object as a single JSON string)
cat data.ndjson | bytefreq -f json -p 1
</code></pre>
<p>Limiting depth is useful for very complex JSON structures where the full path depth produces an unmanageable number of columns. Start shallow and increase depth as needed.</p>
<h3 id="collapsing-array-indices"><a class="header" href="#collapsing-array-indices">Collapsing array indices</a></h3>
<p>JSON arrays produce indexed paths by default. Given this input:</p>
<pre><code class="language-json">{"items": [{"name": "Widget"}, {"name": "Gadget"}, {"name": "Doohickey"}]}
</code></pre>
<p>bytefreq generates separate columns: <code>items.0.name</code>, <code>items.1.name</code>, <code>items.2.name</code>. The <code>-a</code> flag collapses the array index, treating all array elements as the same column:</p>
<pre><code class="language-bash"># Without -a: items.0.name, items.1.name, items.2.name (3 separate columns)
cat data.ndjson | bytefreq -f json

# With -a: items.name (1 column, all array elements pooled together)
cat data.ndjson | bytefreq -f json -a true
</code></pre>
<p>This produces <code>items.name</code> instead of separate columns per array position, which is usually what you want for profiling the structural patterns within array elements. The collapsed column's mask frequency table then reflects the patterns across <em>all</em> array elements, not just those at a specific index.</p>
<h2 id="enhanced-output"><a class="header" href="#enhanced-output">Enhanced Output</a></h2>
<p>The <code>-e</code> and <code>-E</code> flags switch bytefreq from profiling mode to enhanced output mode. Instead of producing a frequency report, the tool processes every record and outputs the flat enhanced format described in Chapter 9.</p>
<h3 id="nested-enhanced--e"><a class="header" href="#nested-enhanced--e">Nested enhanced (<code>-e</code>)</a></h3>
<pre><code class="language-bash">cat data.csv | bytefreq -d ',' -e
</code></pre>
<p>Produces one JSON object per input row, with each field expanded into a nested structure:</p>
<pre><code class="language-json">{
  "postcode": {
    "raw": "SW1A 1AA",
    "HU": "AA9A 9AA",
    "LU": "A9A 9A",
    "Rules": {
      "string_length": 8,
      "is_uk_postcode": true,
      "poss_postal_country": ["UK"]
    }
  }
}
</code></pre>
<h3 id="flat-enhanced--e"><a class="header" href="#flat-enhanced--e">Flat enhanced (<code>-E</code>)</a></h3>
<pre><code class="language-bash">cat data.csv | bytefreq -d ',' -E
</code></pre>
<p>Produces the same information but flattened to dot-notation keys — one level deep, no nesting:</p>
<pre><code class="language-json">{
  "postcode.raw": "SW1A 1AA",
  "postcode.HU": "AA9A 9AA",
  "postcode.LU": "A9A 9A",
  "postcode.Rules.string_length": 8,
  "postcode.Rules.is_uk_postcode": true,
  "postcode.Rules.poss_postal_country": ["UK"]
}
</code></pre>
<p>The flat format is easier to load into columnar tools (Pandas, DuckDB, Parquet) because every key maps directly to a column name without requiring nested JSON parsing.</p>
<h2 id="pipeline-recipes"><a class="header" href="#pipeline-recipes">Pipeline Recipes</a></h2>
<p>bytefreq is designed for Unix pipelines. Here are some common patterns:</p>
<h3 id="profile-the-first-10000-rows-of-a-large-file"><a class="header" href="#profile-the-first-10000-rows-of-a-large-file">Profile the first 10,000 rows of a large file</a></h3>
<pre><code class="language-bash">head -10001 data.csv | bytefreq -d ','
</code></pre>
<p>(10,001 to include the header row.)</p>
<h3 id="profile-compressed-data"><a class="header" href="#profile-compressed-data">Profile compressed data</a></h3>
<pre><code class="language-bash">zcat data.csv.gz | bytefreq -d ','
</code></pre>
<h3 id="profile-a-remote-api-response"><a class="header" href="#profile-a-remote-api-response">Profile a remote API response</a></h3>
<pre><code class="language-bash">curl -s 'https://api.example.com/data' | bytefreq -f json
</code></pre>
<h3 id="generate-flat-enhanced-output-and-load-into-duckdb"><a class="header" href="#generate-flat-enhanced-output-and-load-into-duckdb">Generate flat enhanced output and load into DuckDB</a></h3>
<pre><code class="language-bash">cat data.csv | bytefreq -d ',' -E &gt; enhanced.ndjson
duckdb -c "SELECT * FROM read_ndjson_auto('enhanced.ndjson') LIMIT 10;"
</code></pre>
<h3 id="profile-only-specific-columns-using-pre-processing"><a class="header" href="#profile-only-specific-columns-using-pre-processing">Profile only specific columns (using pre-processing)</a></h3>
<pre><code class="language-bash">cat data.csv | cut -d',' -f1,3,5 | bytefreq -d ','
</code></pre>
<h3 id="compare-two-files-structurally"><a class="header" href="#compare-two-files-structurally">Compare two files structurally</a></h3>
<pre><code class="language-bash">diff &lt;(cat file1.csv | bytefreq -d ',') &lt;(cat file2.csv | bytefreq -d ',')
</code></pre>
<p>This shows which columns have gained or lost structural patterns between two versions of the same dataset — useful for detecting format drift over time.</p>
<h3 id="profile-an-excel-file-native"><a class="header" href="#profile-an-excel-file-native">Profile an Excel file (native)</a></h3>
<pre><code class="language-bash">bytefreq -f excel --excel-path data.xlsx
</code></pre>
<p>To profile a specific sheet (0-based index):</p>
<pre><code class="language-bash">bytefreq -f excel --excel-path data.xlsx --excel-sheet 2
</code></pre>
<p>(Requires building with <code>--features excel</code>. Alternatively, DataRadar handles Excel files natively in the browser.)</p>
<h3 id="profile-a-parquet-file"><a class="header" href="#profile-a-parquet-file">Profile a Parquet file</a></h3>
<pre><code class="language-bash">bytefreq -f parquet --parquet-path data.parquet
</code></pre>
<p>Nested structs produce dot-notation paths and list columns produce indexed array paths, just like JSON. Use <code>-a</code> to collapse array indices:</p>
<pre><code class="language-bash">bytefreq -f parquet --parquet-path data.parquet -a
</code></pre>
<p>Generate flat enhanced output from Parquet:</p>
<pre><code class="language-bash">bytefreq -f parquet --parquet-path data.parquet -E &gt; enhanced.ndjson
</code></pre>
<p>(Requires building with <code>--features parquet</code>.)</p>
<h2 id="understanding-the-output"><a class="header" href="#understanding-the-output">Understanding the Output</a></h2>
<p>The standard DQ report output follows a consistent format:</p>
<pre><code>=== Column: field_name ===
Mask                Count   Example
aaaa.aaaa@aaaa.aaa  45,231  john.smith@email.com
aaaa@aaaa.aaa        8,102  jane@company.org
Aaaa Aaaaa             312  John Smith
99999                   45  12345
                        12
--------END OF REPORT--------
</code></pre>
<p>Each section corresponds to one column in the input. Masks are sorted by descending frequency, so the most common patterns appear first. The example value is a true random sample selected using reservoir sampling — not the first occurrence, but a statistically representative one.</p>
<p>The <code>--------END OF REPORT--------</code> marker signals the end of the output, which is useful when piping to downstream tools.</p>
<h2 id="performance"><a class="header" href="#performance">Performance</a></h2>
<p>bytefreq uses Rayon for multi-threaded processing, so it will utilise all available CPU cores when generating enhanced output. For standard DQ profiling, the bottleneck is typically I/O rather than computation — the mask function is simple enough that CPU time is negligible compared to the time spent reading input.</p>
<p>On a modern machine, expect throughput of several hundred thousand rows per second for tabular data, depending on the number of columns and the average field length. For most datasets under a few million rows, profiling completes in seconds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-assertion-rules-engine-inside-bytefreq"><a class="header" href="#the-assertion-rules-engine-inside-bytefreq">The Assertion Rules Engine: Inside bytefreq</a></h1>
<p>The preceding chapters described the DQOR framework conceptually — masks, population analysis, error codes, treatment functions, and the flat enhanced format. This chapter opens the bonnet. We will walk through the actual Rust code that implements assertion rules in bytefreq, show how the rules engine works, and explain how to add a new rule. If you are not a Rust programmer, do not worry — the patterns are straightforward and the logic reads more like pseudocode than systems programming. The important thing is the <em>design patterns</em>, not the language syntax.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The rules engine in bytefreq is deliberately simple. It consists of two files in the <code>src/rules/</code> directory:</p>
<ul>
<li><strong><code>assertions.rs</code></strong> — a library of assertion functions, each of which examines a (field_name, raw, HU, LU) tuple and returns zero or more assertions about the value.</li>
<li><strong><code>enhancer.rs</code></strong> — a thin orchestration layer that calls <code>execute_assertions</code> and returns the results.</li>
</ul>
<p>When bytefreq runs in enhanced mode (<code>-e</code> or <code>-E</code>), every value in the input is processed through a pipeline:</p>
<ol>
<li>The raw value is read from the input (CSV column, JSON field, etc.).</li>
<li>The HU (high-grain Unicode) and LU (low-grain Unicode) masks are generated.</li>
<li>The triple <code>(raw, HU, LU)</code> is passed to the rules engine along with the field name.</li>
<li>The rules engine runs all applicable assertions and returns a JSON object.</li>
<li>The output is written in the flat enhanced format: <code>{ "raw": ..., "HU": ..., "LU": ..., "Rules": ... }</code>.</li>
</ol>
<p>The processing is parallelised across columns using Rayon, so on a multi-core machine the assertion checks run concurrently for each field in a row:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_tabular_line_as_json(
    processed_fields: &amp;Vec&lt;(String, String)&gt;
) -&gt; serde_json::Value {
    let json_line: HashMap&lt;String, serde_json::Value&gt; = processed_fields
        .par_iter()
        .map(|(column_name, value)| {
            let hu_masked_value = mask_value(value, "HU", column_name);
            let lu_masked_value = mask_value(value, "LU", column_name);

            let data = json!({
                "raw": value,
                "LU": lu_masked_value,
                "HU": hu_masked_value
            });

            let assertions = process_data(&amp;column_name, &amp;data);

            let enhanced_value = json!({
                "raw": value,
                "HU": hu_masked_value,
                "LU": lu_masked_value,
                "Rules": assertions
            });

            (column_name.clone(), enhanced_value)
        })
        .collect();

    serde_json::Value::Object(json_line.into_iter().collect())
}
<span class="boring">}</span></code></pre></pre>
<p>The key thing to notice is that the assertion rules receive the mask as well as the raw value. This is the design pattern that makes the engine efficient: the mask acts as a fast structural filter, allowing rules to skip values that are structurally irrelevant without parsing or interpreting them.</p>
<h2 id="the-enhancer"><a class="header" href="#the-enhancer">The Enhancer</a></h2>
<p>The enhancer (<code>src/rules/enhancer.rs</code>) is intentionally minimal:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::rules::assertions::execute_assertions;

pub fn process_data(
    field_name: &amp;str,
    data: &amp;serde_json::Value
) -&gt; Option&lt;serde_json::Value&gt; {
    let lu = data["LU"].as_str().unwrap_or("");
    let hu = data["HU"].as_str().unwrap_or("");
    let raw = data["raw"].as_str().unwrap_or("");

    let assertions = execute_assertions(field_name, raw, lu, hu);

    if assertions.as_object().unwrap().is_empty() {
        None
    } else {
        Some(assertions)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It extracts the triple from the JSON structure, calls <code>execute_assertions</code>, and returns <code>None</code> if no rules matched (keeping the output sparse — fields with no applicable rules produce no Rules column, which saves space in the flat enhanced output).</p>
<h2 id="the-assertions-library"><a class="header" href="#the-assertions-library">The Assertions Library</a></h2>
<p>The core of the engine is <code>execute_assertions</code> in <code>src/rules/assertions.rs</code>. This function takes the field name, raw value, LU mask, and HU mask, and builds up a JSON object of assertions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn execute_assertions(
    field_name: &amp;str,
    raw: &amp;str,
    lu: &amp;str,
    hu: &amp;str
) -&gt; serde_json::Value {
    let mut assertions: serde_json::Map&lt;String, serde_json::Value&gt; =
        serde_json::Map::new();

    // Always compute string length
    assertions.insert(
        "string_length".to_string(),
        json!(string_length(raw))
    );

    // Postal code country detection — only if field name contains "post"
    if field_name.to_lowercase().contains("post") {
        let possible_countries = get_possible_countries(
            field_name, raw, hu, lu
        );
        if !possible_countries.is_empty() {
            assertions.insert(
                "poss_postal_country".to_string(),
                json!(possible_countries)
            );
        }
    }

    // Country name standardisation
    if field_name.to_lowercase().contains("country")
        &amp;&amp; !lu.chars().any(|c| c.is_numeric())
    {
        if let Some((iso3, region_code)) = country_name_to_iso3(raw)
            .map(|iso3| (iso3.clone(), format!("{}-{}", iso3, raw)))
            .or_else(|| handle_country_name_variations(raw))
        {
            assertions.insert("std_country_iso3".to_string(), json!(iso3));
            assertions.insert("std_region_code".to_string(), json!(region_code));
        }
    }

    // Numeric detection
    if lu == "9" || lu == "9.9" {
        assertions.insert(
            "is_numeric".to_string(),
            json!(is_numeric(raw))
        );
    }

    // UK postcode validation
    if lu == "A9 9A" || hu == "A9A 9A" {
        assertions.insert(
            "is_uk_postcode".to_string(),
            json!(is_uk_postcode(raw))
        );
    }

    // Date parsing
    if lu == "9_9_9" {
        assertions.insert(
            "std_date".to_string(),
            json!(parse_date(raw))
        );
    }

    // Date of birth sensibility check
    if hu == "99_99_9999" &amp;&amp; field_name.to_lowercase().contains("dob") {
        assertions.insert(
            "is_sensible_dob".to_string(),
            json!(is_sensible_dob(raw))
        );
    }

    serde_json::Value::Object(assertions)
}
<span class="boring">}</span></code></pre></pre>
<p>There are several design patterns worth noting here.</p>
<h2 id="pattern-1-mask-gated-rules"><a class="header" href="#pattern-1-mask-gated-rules">Pattern 1: Mask-Gated Rules</a></h2>
<p>Most rules are gated by the LU or HU mask. The UK postcode check only fires when <code>lu == "A9 9A"</code> — meaning the value structurally looks like a postcode (letters, digits, space, digits, letters). The date parser only fires when <code>lu == "9_9_9"</code> — meaning the value has three groups of digits separated by a non-digit character. The numeric check only fires when <code>lu == "9"</code> or <code>lu == "9.9"</code>.</p>
<p>This is efficient. Rather than running every assertion against every value (which would be wasteful for a million-row file with dozens of columns), the mask pre-filters. A name column with mask <code>Aaaa Aaaaa</code> will skip the postcode check, the numeric check, and the date parser entirely. Only rules whose structural precondition matches the mask will execute.</p>
<p>This is the same principle introduced in Chapter 7 (Masks as Error Codes), but applied in reverse: instead of using masks to <em>detect</em> problems, we use them to <em>select</em> which enhancement rules are applicable.</p>
<h2 id="pattern-2-field-name-aware-rules"><a class="header" href="#pattern-2-field-name-aware-rules">Pattern 2: Field-Name-Aware Rules</a></h2>
<p>Some rules use the field name as additional context. The postal country detection only runs when the field name contains <code>"post"</code>. The country name standardisation only runs when the field name contains <code>"country"</code>. The date-of-birth sensibility check only runs when the field name contains <code>"dob"</code>.</p>
<p>This is a pragmatic heuristic. A value of <code>SW1A 1AA</code> in a field called <code>postcode</code> should be checked as a UK postcode. The same value in a field called <code>reference_code</code> probably should not. The field name provides domain context that the mask alone cannot.</p>
<p>The heuristic is deliberately loose — <code>contains("post")</code> will match <code>postcode</code>, <code>postal_code</code>, <code>home_postcode</code>, <code>post_code</code>, and even <code>post_office_box</code>. This is intentional: it is better to over-match and produce an assertion that the consumer can ignore, than to under-match and miss a useful suggestion.</p>
<h2 id="pattern-3-standardisation-suggestions"><a class="header" href="#pattern-3-standardisation-suggestions">Pattern 3: Standardisation Suggestions</a></h2>
<p>Several rules do not just detect a property but suggest a standardised form. The country name rule maps free-text country names to ISO 3166-1 alpha-3 codes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn country_name_to_iso3(value: &amp;str) -&gt; Option&lt;String&gt; {
    let name_to_iso3 = country(|c| (
        c.name.to_lowercase(),
        c.iso3
    ));
    name_to_iso3
        .get(&amp;value.to_lowercase())
        .map(|s| s.to_string())
}
<span class="boring">}</span></code></pre></pre>
<p>The function uses the <code>geonamescache</code> crate to look up country names against a known dictionary, returning the ISO3 code if a match is found. It also handles common variations that the standard dictionary misses — <code>"England"</code>, <code>"Scotland"</code>, <code>"Wales"</code>, and <code>"Northern Ireland"</code> are mapped to their ISO codes with region suffixes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_country_name_variations(country_name: &amp;str) -&gt; Option&lt;(String, String)&gt; {
    match country_name.to_lowercase().as_str() {
        "england"          =&gt; Some(("GBR".to_string(), "GB-ENG".to_string())),
        "scotland"         =&gt; Some(("GBR".to_string(), "GB-SCT".to_string())),
        "northern ireland" =&gt; Some(("GBR".to_string(), "GB-NIR".to_string())),
        "wales" | "cymru"  =&gt; Some(("GBR".to_string(), "GB-WLS".to_string())),
        _ =&gt; None,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The output in the Rules column would look like:</p>
<pre><code class="language-json">{
  "std_country_iso3": "GBR",
  "std_region_code": "GBR-England"
}
</code></pre>
<p>This is a <em>suggestion</em>, not a correction. The raw value <code>"England"</code> is preserved in the <code>.raw</code> column. The consumer can choose to use the ISO3 code, or keep the original, or apply their own mapping. The engine surfaces the assertion; the consumer decides what to do with it.</p>
<h2 id="pattern-4-postal-code-country-detection"><a class="header" href="#pattern-4-postal-code-country-detection">Pattern 4: Postal Code Country Detection</a></h2>
<p>The <code>get_possible_countries</code> function is a particularly good example of mask-driven inference. It uses the HU mask of a postal code to determine which countries could have produced that format:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_possible_countries(
    _column_name: &amp;str, raw: &amp;str, hu: &amp;str, lu: &amp;str
) -&gt; Vec&lt;String&gt; {
    let mut possible_countries: Vec&lt;String&gt; = Vec::new();

    match hu {
        "9999" =&gt; {
            possible_countries.extend(vec![
                "AT", "BE", "BG", "CH", "CY", "CZ", "DK", "EE",
                "FI", "GR", "HU", "IE", "LT", "LU", "LV", "MT",
                "NL", "NO", "PL", "PT", "RO", "SE", "SI", "SK"
            ].into_iter().map(|s| s.to_string()));
        }
        "99999" =&gt; {
            possible_countries.extend(vec![
                "DE", "ES", "FR", "HR", "IT"
            ].into_iter().map(|s| s.to_string()));
        }
        "999-99" =&gt; {
            possible_countries.push("SE".to_string());
        }
        "AAA-9999" =&gt; {
            possible_countries.push("IE".to_string());
        }
        _ =&gt; {}
    }

    // Refine using value-level checks
    if lu == "9-9999" &amp;&amp; raw.starts_with("1") {
        possible_countries.retain(|c| c == "DE");
    }

    // UK postal code patterns
    let uk_patterns = vec!["A9 9A", "A9A 9A", "A9A"];
    if uk_patterns.contains(&amp;lu) {
        possible_countries.push("UK".to_string());
    }

    possible_countries
}
<span class="boring">}</span></code></pre></pre>
<p>Notice the two-level logic. First, the HU mask narrows the field to a set of possible countries (a 4-digit postal code could be Austrian, Belgian, Swiss, etc.). Then, value-level checks refine the set further (a 4-digit code starting with <code>0</code> is likely Dutch; a 5-digit code starting with <code>9</code> is likely French). The result is a list of <em>possible</em> countries, not a definitive answer — again, a suggestion that the consumer can use to inform their own logic.</p>
<h2 id="implementing-a-new-rule"><a class="header" href="#implementing-a-new-rule">Implementing a New Rule</a></h2>
<p>Adding a new assertion rule to bytefreq involves three steps.</p>
<h3 id="step-1-write-the-detection-function"><a class="header" href="#step-1-write-the-detection-function">Step 1: Write the Detection Function</a></h3>
<p>Create a function in <code>assertions.rs</code> that takes a raw value (and optionally the masks or field name) and returns the assertion result. For example, a rule to detect email addresses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_email(value: &amp;str) -&gt; bool {
    let re = Regex::new(
        r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    ).unwrap();
    re.is_match(value)
}

pub fn extract_email_domain(value: &amp;str) -&gt; Option&lt;String&gt; {
    value.split('@').nth(1).map(|s| s.to_lowercase())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-2-wire-it-into-execute_assertions"><a class="header" href="#step-2-wire-it-into-execute_assertions">Step 2: Wire It Into execute_assertions</a></h3>
<p>Add a conditional block in the <code>execute_assertions</code> function, gated by the appropriate mask pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Email detection — LU mask "a@a.a" covers most email patterns
if lu.contains("@") &amp;&amp; lu.contains(".") {
    assertions.insert(
        "is_email".to_string(),
        json!(is_email(raw))
    );
    if let Some(domain) = extract_email_domain(raw) {
        assertions.insert(
            "email_domain".to_string(),
            json!(domain)
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The mask gate here is simple: if the LU mask contains both <code>@</code> and <code>.</code>, the value <em>might</em> be an email address (since those punctuation characters are preserved in the mask). The <code>is_email</code> function then performs the definitive check, and <code>extract_email_domain</code> provides a standardised extraction.</p>
<h3 id="step-3-build-and-test"><a class="header" href="#step-3-build-and-test">Step 3: Build and Test</a></h3>
<pre><code class="language-bash">cargo build
echo 'name,email,postcode
John Smith,john@example.com,SW1A 1AA
Jane Doe,jane.doe@company.co.uk,EC2R 8AH' | cargo run -- -E
</code></pre>
<p>The output for the email column would include:</p>
<pre><code class="language-json">{
  "email": {
    "raw": "john@example.com",
    "HU": "aaaa@aaaaaaa.aaa",
    "LU": "a@a.a",
    "Rules": {
      "string_length": 16,
      "is_email": true,
      "email_domain": "example.com"
    }
  }
}
</code></pre>
<h3 id="design-guidelines-for-new-rules"><a class="header" href="#design-guidelines-for-new-rules">Design Guidelines for New Rules</a></h3>
<p>When writing a new assertion rule, several principles from the existing codebase are worth following:</p>
<p><strong>Gate by mask first.</strong> The mask check should be the outer conditional, because it is essentially free (a string comparison) and filters out the majority of values that cannot possibly match. Only values that pass the mask gate should incur the cost of the full assertion logic (regex matching, parsing, dictionary lookup, etc.).</p>
<p><strong>Use the field name as a hint, not a requirement.</strong> Field-name matching (<code>field_name.contains("post")</code>) is useful for disambiguation but should not be the only gate. Some datasets have opaque field names (<code>col_7</code>, <code>field_12</code>), and the rule should still fire for structurally matching values even when the field name provides no context.</p>
<p><strong>Return suggestions, not corrections.</strong> The assertion should describe what the value <em>is</em> or what it <em>could be</em>, not what it <em>should be changed to</em>. The consumer decides whether to act on the suggestion. This keeps the rules engine non-destructive and maintains the DQOR principle of preserving the raw value.</p>
<p><strong>Cache expensive lookups.</strong> The country name lookup uses a <code>RwLock&lt;HashMap&gt;</code> cache to avoid repeated dictionary scans. Any rule that performs an expensive operation (network call, large dictionary lookup, complex regex compilation) should cache results for values it has seen before. The <code>lazy_static</code> pattern used for the country cache is a good template:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    pub static ref COUNTRY_NAME_TO_ISO3_CACHE:
        RwLock&lt;HashMap&lt;String, Option&lt;String&gt;&gt;&gt; =
            RwLock::new(HashMap::new());
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Keep rules independent.</strong> Each rule should be self-contained. Rules should not depend on the output of other rules, and the order in which they execute should not matter. This allows the engine to run rules in parallel (which it does via Rayon) and makes it safe to add, remove, or modify rules without side effects.</p>
<h2 id="the-rules-as-a-living-library"><a class="header" href="#the-rules-as-a-living-library">The Rules as a Living Library</a></h2>
<p>The assertion rules in bytefreq are not a closed set. They are a starting point — a library of common patterns that cover postal codes, country names, dates, numeric values, and basic structural properties. As the tool encounters new types of data, new rules are added.</p>
<p>This is the same continuous improvement loop described in Chapter 8 (treatment functions): profile the data, discover new patterns, write rules to detect and characterise them, and add the rules to the library. Over time, the library grows to reflect the kinds of data that bytefreq's users actually encounter, making the flat enhanced output increasingly useful with each release.</p>
<p>The rules are also an invitation. Because the engine is open source and the pattern for adding a new rule is straightforward — write a function, gate it by mask, wire it into <code>execute_assertions</code> — users with domain-specific knowledge can contribute rules for their own data types. The mask-gated architecture means domain-specific rules coexist with the general-purpose ones without interference, and the flat enhanced format ensures that all assertions — general and domain-specific — are delivered to consumers in a consistent structure.</p>
<p>To make this concrete, here are sketches for three domain-specific rules that follow the same patterns described above.</p>
<h3 id="example-nhs-number-validation-healthcare"><a class="header" href="#example-nhs-number-validation-healthcare">Example: NHS Number Validation (Healthcare)</a></h3>
<p>An NHS number is a 10-digit identifier with a modulus 11 check digit. The mask gate is simple: <code>hu == "9999999999"</code> (exactly 10 digits). The validation function computes the weighted sum and checks the remainder:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Gate: hu == "9999999999"
pub fn is_nhs_number(value: &amp;str) -&gt; bool {
    let digits: Vec&lt;u32&gt; = value.chars().filter_map(|c| c.to_digit(10)).collect();
    if digits.len() != 10 { return false; }
    let weighted_sum: u32 = digits[..9].iter()
        .enumerate()
        .map(|(i, &amp;d)| d * (10 - i as u32))
        .sum();
    let remainder = weighted_sum % 11;
    let check = if remainder == 0 { 0 } else { 11 - remainder };
    check != 10 &amp;&amp; check == digits[9]
}
<span class="boring">}</span></code></pre></pre>
<p>The mask gate ensures this function never fires on phone numbers, postcodes, or other 10-digit values in columns that are not plausibly NHS numbers. A field-name hint (<code>field_name.contains("nhs")</code> or <code>field_name.contains("patient")</code>) could narrow it further.</p>
<h3 id="example-iban-detection-financial-services"><a class="header" href="#example-iban-detection-financial-services">Example: IBAN Detection (Financial Services)</a></h3>
<p>An IBAN starts with a two-letter country code, followed by two check digits, followed by a country-specific Basic Bank Account Number (BBAN). The HU mask for a GB IBAN looks like <code>AA99AAAA99999999999999</code> — 22 characters, letters then digits. The mask gate targets this family of patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Gate: hu starts with "AA99" and length matches known IBAN lengths
pub fn is_valid_iban(value: &amp;str) -&gt; bool {
    let clean: String = value.chars().filter(|c| !c.is_whitespace()).collect();
    if clean.len() &lt; 15 || clean.len() &gt; 34 { return false; }
    // Move first 4 chars to end, convert letters to digits (A=10..Z=35)
    let rearranged = format!("{}{}", &amp;clean[4..], &amp;clean[..4]);
    let numeric: String = rearranged.chars().map(|c| {
        if c.is_alphabetic() {
            format!("{}", c.to_ascii_uppercase() as u32 - 55)
        } else {
            c.to_string()
        }
    }).collect();
    // Modulus 97 check
    numeric.chars().fold(0u64, |acc, c| {
        (acc * 10 + c.to_digit(10).unwrap() as u64) % 97
    }) == 1
}
<span class="boring">}</span></code></pre></pre>
<p>The output might include both validation and decomposition:</p>
<pre><code class="language-json">{
  "is_iban": true,
  "iban_country": "GB",
  "iban_bban": "NWBK60161331926819"
}
</code></pre>
<h3 id="example-email-address-detection"><a class="header" href="#example-email-address-detection">Example: Email Address Detection</a></h3>
<p>The email rule shown in the "Implementing a New Rule" section above is another example of the pattern. The mask gate (<code>lu.contains("@") &amp;&amp; lu.contains(".")</code>) is structural, the validation is semantic, and the extraction (<code>email_domain</code>) provides a useful standardisation suggestion. Together, these three examples — healthcare, financial services, and general-purpose — illustrate how the same mask-gate-then-validate pattern extends to any domain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion" class="unnumbered"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>Mask-based profiling is not a silver bullet. It will not catch semantic errors — a phone number that is structurally valid but belongs to the wrong person, a date that is correctly formatted but factually wrong, a numeric value that parses fine but represents a measurement in the wrong units. It will not replace domain expertise, business validation rules, or statistical anomaly detection. Those techniques have their place, and they should continue to be used where they are appropriate.</p>
<p>Mask-based profiling is complementary to tools like Great Expectations, dbt tests, and Soda — not a replacement for them. Those tools excel at <em>validating known expectations</em>: is this column non-null? Does this value fall within a range? Does this foreign key relationship hold? Mask-based profiling excels at <em>discovering what you did not know to expect</em>. Use DQOR to explore and characterise the data first, then encode what you learn as expectations in whatever validation framework your pipeline already uses. The masks tell you what to test for; the validation tools enforce the tests.</p>
<p>What mask-based profiling does, and does exceptionally well, is provide a <strong>fast, assumption-free structural census</strong> of any dataset at the point of consumption. It answers the question "what does this data actually look like?" before you invest time and resources in trying to use it. It generates quality metadata — masks, population profiles, error codes — as a side effect of profiling, at no additional cost. And it does so deterministically, reproducibly, and at any scale from a single CSV in a browser to billions of records on a Spark cluster.</p>
<p>The Data Quality on Read architecture that surrounds the technique — raw data preservation, deferred quality processing, the flat enhanced format, treatment functions keyed by mask — is designed for the reality of modern data work, where the data you need to use was created by someone else, documented imperfectly, and delivered with whatever level of quality the source system happened to produce. You cannot control the source. What you can control is how quickly and cheaply you understand what you have received, and how systematically you address the issues you find.</p>
<p>The tools are open source. The technique is simple enough to prototype in a single line of <code>sed</code> and powerful enough to run in production at enterprise scale. The hardest part, as with most things in data engineering, is not the technology but the discipline: profiling consistently, documenting what you find, building the quality loop, and maintaining it over time.</p>
<p>If there is a single lesson from nearly two decades of applying this technique across financial services, telecoms, government, and open data projects, it is this: the data is never as clean as the specification says it is, the specification is never as accurate as the author believes it is, and the cost of discovering these facts late is always higher than the cost of discovering them early.</p>
<p>Profile early. Profile often. Let the masks speak for themselves.</p>
<p>If you are ready to try the technique, the <a href="./getting-started.html">Getting Started</a> appendix has everything you need to run your first profile in under a minute.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary" class="unnumbered"><a class="header" href="#glossary">Glossary</a></h1>
<p>This glossary defines the key technical terms used throughout this book. In translated editions, these terms are kept in English to maintain consistency with the tools and code examples. The definitions below serve as the reference for all translations.</p>
<p><strong>allow list</strong> — A list of masks that are considered acceptable for a given column. Values whose masks do not appear in the allow list are flagged as anomalies. Compare with <em>exclusion list</em>.</p>
<p><strong>assertion</strong> — A property or suggestion automatically inferred by the rules engine about a data value. For example, <code>is_uk_postcode: true</code> or <code>std_country_iso3: "GBR"</code>. Assertions are advisory — consumers choose whether to act on them.</p>
<p><strong>bytefreq</strong> — An open-source command-line data profiling tool, written in Rust, that implements mask-based profiling and the flat enhanced output format. Originally written in awk in 2007. Short for <em>byte frequencies</em>.</p>
<p><strong>character class</strong> — A category of character defined by the Unicode General Category standard: uppercase letter (Lu), lowercase letter (Ll), digit (Nd), punctuation, symbol, separator, and so on. Mask-based profiling translates each character to a symbol representing its class.</p>
<p><strong>character profiling (CP)</strong> — A report mode that analyses the frequency of individual byte values or Unicode code points in a file. Used for encoding detection, invisible character discovery, and script composition analysis. Compare with <em>data quality profiling</em>.</p>
<p><strong>coverage</strong> — The percentage of values in a column that match the top N masks. High coverage (&gt;95%) indicates a structurally uniform column; low coverage indicates structural diversity.</p>
<p><strong>DataRadar</strong> — A browser-based data quality profiling tool that runs entirely client-side using WebAssembly. Implements the same profiling engine as bytefreq. Available at dataradar.co.uk.</p>
<p><strong>data quality on read (DQOR)</strong> — An architecture principle where data quality profiling, validation, and remediation are deferred until the moment of consumption, rather than applied at ingest time. A parallel to <em>schema on read</em>.</p>
<p><strong>cliff point</strong> — The point in a sorted mask frequency table where the percentage-of-previous-mask drops sharply, separating expected patterns from rare exceptions. Used for management by exception: masks above the cliff are normal operations; masks below it form a review queue for potential new assertion rules or treatment functions.</p>
<p><strong>data quality profiling (DQ)</strong> — The default report mode in bytefreq and DataRadar. Generates mask frequency tables for each column, showing structural patterns and their occurrence counts.</p>
<p><strong>exclusion list</strong> — A list of masks that are known to be problematic for a given column. Values whose masks match the exclusion list are flagged as errors. Compare with <em>allow list</em>.</p>
<p><strong>flat enhanced format</strong> — A flattened key-value pair schema, sourced from nested data. Each field in the original data is expanded into a family of dot-notated keys: <code>.raw</code> (original value), <code>.HU</code> (high-grain mask), <code>.LU</code> (low-grain mask), and <code>.Rules</code> (assertions and suggestions). The floating schema handles ragged rows gracefully, annotations are easily added, and the namespace dot notation provides provenance and scoping.</p>
<p><strong>grain</strong> — The resolution level of a mask. <em>High grain</em> maps every character individually, preserving exact lengths. <em>Low grain</em> collapses consecutive characters of the same class into a single symbol, reducing cardinality for structural discovery.</p>
<p><strong>HU (High Unicode)</strong> — High-grain masking with Unicode character class support. Every character maps individually using its Unicode General Category. The most detailed masking level.</p>
<p><strong>LU (Low Unicode)</strong> — Low-grain masking with Unicode support. Consecutive characters of the same class are collapsed. The default masking level in bytefreq, and the recommended starting point for exploratory profiling.</p>
<p><strong>mask</strong> — A structural fingerprint of a data value, produced by translating each character to a symbol representing its character class. Uppercase letters become <code>A</code>, lowercase become <code>a</code>, digits become <code>9</code>, and punctuation is kept as-is. For example, <code>John Smith</code> produces the mask <code>Aaaa Aaaaa</code>.</p>
<p><strong>mask cardinality</strong> — The number of distinct masks found in a column. Low cardinality (1–3 masks) indicates a well-structured column; high cardinality may indicate structural diversity or data quality issues.</p>
<p><strong>population check</strong> — A test that determines whether each field in a record is populated or empty. When aggregated, it produces a per-field population percentage showing the proportion of non-null values.</p>
<p><strong>population profile</strong> — A frequency table of masks for a column, sorted by count. Shows the dominant structural patterns and the long tail of rare masks.</p>
<p><strong>Rayon</strong> — A Rust library for data parallelism that enables multi-threaded processing with minimal code changes. bytefreq uses Rayon to parallelise mask generation and assertion rule evaluation across columns, utilising all available CPU cores automatically.</p>
<p><strong>provenance</strong> — The ability to trace a derived or treated value back to the original raw value it was computed from. The flat enhanced format preserves provenance by keeping the <code>.raw</code> column immutable alongside all derived columns.</p>
<p><strong>.raw</strong> — The column in the flat enhanced format that contains the original, untouched value exactly as received from the source. Never modified, never overwritten.</p>
<p><strong>reservoir sampling</strong> — A statistical technique used by bytefreq to select a truly random example value for each mask in a profiling report, without requiring a second pass over the data.</p>
<p><strong>.Rules</strong> — The column in the flat enhanced format that contains automatically inferred assertions and suggested treatments for a value. Rules are advisory, not prescriptive — multiple competing suggestions can coexist.</p>
<p><strong>schema on read</strong> — A data architecture principle where structural interpretation is deferred until the point of consumption, rather than enforced at ingest time. The foundation of modern data lake architectures, and the conceptual predecessor of <em>data quality on read</em>.</p>
<p><strong>script detection</strong> — Automatic identification of the dominant Unicode scripts present in each column (e.g., Latin, Cyrillic, Arabic, CJK). Used to flag encoding issues and inform downstream processing.</p>
<p><strong>treatment function</strong> — A remediation action mapped to a specific (column, mask) combination. For example, applying title-case normalisation to values with the mask <code>AAAA AAAAA</code>, or replacing placeholder values (mask <code>A/A</code>) with nulls. Treatment functions are non-destructive — the original value is always preserved.</p>
<p><strong>WebAssembly (WASM)</strong> — A binary instruction format that allows code written in languages like Rust to run in web browsers at near-native speed. DataRadar uses WASM to run the bytefreq profiling engine client-side, ensuring that data never leaves the user's machine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-1" class="unnumbered"><a class="header" href="#getting-started-1">Getting Started</a></h1>
<p>You have read the book. Now try the technique. Here is the shortest path from zero to a working profile.</p>
<h2 id="option-1-dataradar-in-your-browser-30-seconds"><a class="header" href="#option-1-dataradar-in-your-browser-30-seconds">Option 1: DataRadar in Your Browser (30 seconds)</a></h2>
<ol>
<li>Open <a href="https://dataradar.co.uk">dataradar.co.uk</a>.</li>
<li>Drop a CSV, Excel, or JSON file onto the page — or paste a URL to an open data endpoint.</li>
<li>Click <strong>Profile</strong>. The masks appear immediately.</li>
<li>Switch between LU and HU grain to explore structural patterns at different resolutions.</li>
<li>Click <strong>Export Flat Enhanced</strong> to download the NDJSON output with <code>.raw</code>, <code>.HU</code>, <code>.LU</code>, and <code>.Rules</code> columns.</li>
</ol>
<p>No installation. No sign-up. No data leaves your machine.</p>
<h2 id="option-2-bytefreq-on-the-command-line-5-minutes"><a class="header" href="#option-2-bytefreq-on-the-command-line-5-minutes">Option 2: bytefreq on the Command Line (5 minutes)</a></h2>
<p>Install Rust and bytefreq:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env
cargo install --git https://github.com/minkymorgan/bytefreq
</code></pre>
<p>Profile a file:</p>
<pre><code class="language-bash">cat your_data.csv | bytefreq -d ','
</code></pre>
<p>Generate flat enhanced output:</p>
<pre><code class="language-bash">cat your_data.csv | bytefreq -d ',' -E &gt; enhanced.ndjson
</code></pre>
<p>Query the output with DuckDB:</p>
<pre><code class="language-bash">duckdb -c "SELECT * FROM read_ndjson_auto('enhanced.ndjson') LIMIT 10;"
</code></pre>
<h2 id="sample-data"><a class="header" href="#sample-data">Sample Data</a></h2>
<p>If you do not have a dataset to hand, try the UK government's Electric Vehicle Chargepoint Registry — a real open dataset with messy postcodes, mixed formats, and international address data:</p>
<pre><code class="language-bash">curl -sL 'https://www.gov.uk/guidance/find-and-use-data-on-public-electric-vehicle-chargepoints' -o chargepoints.csv
cat chargepoints.csv | bytefreq -d ','
</code></pre>
<p>Or paste the URL directly into DataRadar.</p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><strong>DataRadar</strong>: <a href="https://dataradar.co.uk">dataradar.co.uk</a></li>
<li><strong>bytefreq source</strong>: <a href="https://github.com/minkymorgan/bytefreq">github.com/minkymorgan/bytefreq</a></li>
<li><strong>This book</strong>: <a href="https://github.com/minkymorgan/DataQualityOnRead">github.com/minkymorgan/DataQualityOnRead</a></li>
<li><strong>Enterprise support</strong>: <a href="mailto:andrew@gamakon.ai">andrew@gamakon.ai</a></li>
</ul>
<h2 id="what-to-do-next"><a class="header" href="#what-to-do-next">What to Do Next</a></h2>
<ol>
<li>Profile a dataset you are working with right now. Look at the masks. What surprises you?</li>
<li>Export the flat enhanced format and load it into your tool of choice (Pandas, Polars, DuckDB, Excel).</li>
<li>Identify the top three mask patterns per column — those are your "expected" formats.</li>
<li>Look at the long tail — the rare masks. Those are your quality issues.</li>
<li>Write treatment functions for the issues you find, keyed by mask (as described in Chapter 8).</li>
<li>Repeat. Profile early. Profile often.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="worked-example-profiling-uk-companies-house-data" class="unnumbered"><a class="header" href="#worked-example-profiling-uk-companies-house-data">Worked Example: Profiling UK Companies House Data</a></h1>
<p>This appendix is a complete worked example. We take a real dataset — 99,999 company registration records from UK Companies House — and profile it end to end using bytefreq's low-grain Unicode (LU) masking. For each field, we show the actual mask frequency table, identify the cliff point where applicable, and catalogue every data quality issue we find. The result is a concrete illustration of the techniques described in the preceding chapters, applied to real government data with real problems.</p>
<h2 id="the-dataset"><a class="header" href="#the-dataset">The Dataset</a></h2>
<p>Companies House publishes a free monthly snapshot of every company registered in England and Wales, Scotland, and Northern Ireland. The <strong>BasicCompanyData</strong> file is a pipe-delimited extract containing company name, registered address, incorporation date, SIC codes, company status, and related metadata. It is freely available from <a href="http://download.companieshouse.gov.uk/">download.companieshouse.gov.uk</a>.</p>
<p>The extract used here is <code>BasicCompanyData-2021-02-01-part6_6_100k.pip</code> — 99,999 records from the February 2021 release. It contains 55 columns, ranging from well-structured identifiers (company number) to free-text fields (company name, address lines) to date fields, categorical codes, and URLs. It is exactly the kind of messy, real-world dataset that DQOR techniques are designed for.</p>
<h2 id="running-the-profile"><a class="header" href="#running-the-profile">Running the Profile</a></h2>
<p>The profile was generated with a single command:</p>
<pre><code class="language-bash">cat BasicCompanyData-2021-02-01-part6_6_100k.pip | bytefreq -g LU
</code></pre>
<p>We use LU (Low-grain Unicode) masking as the discovery grain — it collapses consecutive characters of the same class, producing a compact set of structural patterns for each column. This is the recommended starting point for any new dataset. Where precision matters, you can drill into specific fields with HU (High-grain Unicode) masking afterwards.</p>
<h2 id="structure-discovery-column-population-analysis"><a class="header" href="#structure-discovery-column-population-analysis">Structure Discovery: Column Population Analysis</a></h2>
<p>Before examining mask patterns, we count non-null values per column. For a tabular dataset this is the equivalent of the field path population analysis we perform on nested JSON — it tells us the shape of the data before we look at what is in it. In a pipe-delimited file with 55 columns, many of those columns will be sparsely populated, and knowing which ones are empty (and how empty) is the first step in understanding the dataset.</p>
<pre><code>Column                                        Non-Null  % Populated
----------------------------------------------------------------------
CompanyName                                      99,999     100.0%
CompanyNumber                                    99,999     100.0%
CompanyCategory                                  99,999     100.0%
CompanyStatus                                    99,999     100.0%
CountryOfOrigin                                  99,998     100.0%
Mortgages.NumMortCharges                         99,999     100.0%
Mortgages.NumMortOutstanding                     99,999     100.0%
Mortgages.NumMortPartSatisfied                   99,999     100.0%
Mortgages.NumMortSatisfied                       99,999     100.0%
SICCode.SicText_1                                99,999     100.0%
LimitedPartnerships.NumGenPartners               99,999     100.0%
LimitedPartnerships.NumLimPartners               99,999     100.0%
URI                                              99,999     100.0%
IncorporationDate                                99,947      99.9%
ConfStmtNextDueDate                              96,331      96.3%
RegAddress.AddressLine1                          96,168      96.2%
RegAddress.PostCode                              95,632      95.6%
RegAddress.PostTown                              94,988      95.0%
Accounts.AccountRefDay                           94,821      94.8%
Accounts.AccountRefMonth                         94,821      94.8%
Returns.NextDueDate                              94,672      94.7%
Accounts.NextDueDate                             94,610      94.6%
ConfStmtLastMadeUpDate                           77,078      77.1%
Accounts.AccountCategory                         75,465      75.5%
Accounts.LastMadeUpDate                          69,539      69.5%
RegAddress.Country                               65,069      65.1%
RegAddress.AddressLine2                          63,688      63.7%
Returns.LastMadeUpDate                           45,896      45.9%
RegAddress.County                                38,625      38.6%
SICCode.SicText_2                                12,406      12.4%
PreviousName_1.CONDATE                           11,469      11.5%
PreviousName_1.CompanyName                       11,469      11.5%
SICCode.SicText_3                                 4,747       4.7%
SICCode.SicText_4                                 2,040       2.0%
PreviousName_2.CONDATE                            1,888       1.9%
PreviousName_2.CompanyName                        1,888       1.9%
RegAddress.CareOf                                 1,699       1.7%
PreviousName_3.CONDATE                              379       0.4%
PreviousName_3.CompanyName                          379       0.4%
RegAddress.POBox                                    258       0.3%
PreviousName_4.CONDATE                               69       0.1%
PreviousName_4.CompanyName                           69       0.1%
PreviousName_5.CONDATE                               25       0.0%
PreviousName_5.CompanyName                           25       0.0%
PreviousName_6.CONDATE                                6       0.0%
PreviousName_6.CompanyName                            6       0.0%
PreviousName_7.CONDATE                                2       0.0%
PreviousName_7.CompanyName                            2       0.0%
PreviousName_8.CONDATE                                0       0.0%
PreviousName_8.CompanyName                            0       0.0%
PreviousName_9.CONDATE                                0       0.0%
PreviousName_9.CompanyName                            0       0.0%
PreviousName_10.CONDATE                               0       0.0%
PreviousName_10.CompanyName                           0       0.0%
DissolutionDate                                       0       0.0%
</code></pre>
<p>The core identity fields — CompanyName, CompanyNumber, CompanyCategory, CompanyStatus, CountryOfOrigin — are 100% populated, or 99.998% in the case of CountryOfOrigin, which has exactly one empty record out of 99,999. These are the registration fundamentals, the columns that define what a company is before we know anything else about it. The four Mortgages columns and two LimitedPartnerships columns are also 100% populated, though as we will see in the field-by-field analysis, "populated" does not mean "informative" — most of these contain zeros. A column that is universally present but universally zero is telling us something about the schema rather than about the companies.</p>
<p>The address block reveals a clear hierarchy of completeness. AddressLine1 (96.2%) and PostCode (95.6%) are near-universal, PostTown follows at 95.0%, then Country drops to 65.1%, AddressLine2 to 63.7%, and County falls to just 38.6%. County is the most sparsely populated address field, which we will confirm in the field-by-field analysis — but the population table already tells us that more than 60% of companies have no county recorded. This is not a data quality issue in the traditional sense; counties are increasingly optional in UK postal addresses and many companies simply do not provide one. The distinction matters: a field that is empty because the information was never required is fundamentally different from a field that is empty because something went wrong.</p>
<p>The SIC code columns tell a story of diminishing specificity. SicText_1 is 100% populated (though 6,562 of those values are "None Supplied", which we will return to later), SicText_2 drops to 12.4%, SicText_3 to 4.7%, and SicText_4 to just 2.0%. Most companies declare a single industry classification. The 12.4% with a second SIC code are companies operating across multiple sectors — a recruitment agency that also provides training, for example. By the fourth code, only 2,040 companies remain, and these tend to be diversified conglomerates or holding companies with genuinely distinct lines of business.</p>
<p>The PreviousName columns are the tabular equivalent of a ragged nested array. The schema allocates 10 slots (PreviousName_1 through PreviousName_10), but population drops exponentially: 11.5% of companies have changed name at least once, 1.9% at least twice, 0.4% three times, and by PreviousName_7 we are down to 2 companies. PreviousName_8 through PreviousName_10 are completely empty — no company in this extract has changed its name eight or more times. This is a classic schema design problem: pre-allocating fixed columns for a variable-length list. In nested JSON, this would be a single array of arbitrary length. In a flat file, it wastes 6 entirely empty column pairs and forces a hard limit of 10 name changes. The population analysis makes the waste visible at a glance. The exponential decay in population across these numbered column pairs is a strong signal that the underlying data model is — or was — a JSON array that has been flattened into fixed columns for tabular export. The original Companies House API does in fact serve this data as a JSON array of previous names with no fixed limit. The tabular export imposed the ten-slot ceiling, wasted six entirely empty column pairs, and lost the structural elegance of the original format. This is a common pattern in government open data: the machine-readable JSON is flattened into CSV or pipe-delimited files for broader accessibility, and structural information is lost in the translation.</p>
<p>DissolutionDate is 0% populated across all 99,999 records, and this single observation tells us something important about the extract itself: this file contains only active companies. Dissolved companies would have a dissolution date. The column exists in the schema but is structurally empty in this particular data slice. This is the kind of insight that saves hours of investigation — you do not need to wonder whether dissolved companies are included, or build filters to exclude them. The population analysis answers that question before you read a single value.</p>
<p>The accounts and returns fields show two tiers of completeness that reveal something about the lifecycle of a company. The "next due" dates (AccountRefDay, AccountRefMonth, NextDueDate, Returns.NextDueDate) cluster around 94–95% — these are forward-looking obligations that exist for almost every active company. But the "last made up" dates tell a different story: Accounts.LastMadeUpDate is 69.5% and Returns.LastMadeUpDate drops to just 45.9%. The gap between "when you must file" and "when you last filed" reveals that roughly 30% of companies have never filed accounts and 54% have never filed a return. These are most likely recently incorporated companies that have not yet reached their first filing deadline — they have obligations but no history of meeting them yet.</p>
<h2 id="field-by-field-analysis"><a class="header" href="#field-by-field-analysis">Field-by-Field Analysis</a></h2>
<h3 id="company-number"><a class="header" href="#company-number">Company Number</a></h3>
<p><code>CompanyNumber</code></p>
<pre><code>Mask     Count      %       Example
9       87,730   87.7%      12432873
A9      12,145   12.1%      GE000152
A9A        124    0.1%      IP28746R
</code></pre>
<p>Three masks, no cliff point needed — with only three patterns, every one is worth understanding.</p>
<p>The dominant format <code>9</code> (87.7%) represents standard company numbers — eight numeric digits like <code>12432873</code>. The <code>A9</code> pattern (12.1%) covers companies with letter prefixes: <code>GE000152</code> (German registered), <code>SC</code> (Scottish), <code>NI</code> (Northern Ireland), <code>OC</code> (overseas companies), and similar jurisdiction indicators. The rare <code>A9A</code> pattern (0.1%, 124 records) covers industrial and provident societies with a trailing letter, such as <code>IP28746R</code>.</p>
<p><strong>Issues found:</strong> None. This is a well-structured identifier with consistent formatting. The three patterns are all legitimate and well-documented. A good assertion rule would validate that the prefix letters match known jurisdiction codes.</p>
<h3 id="registered-address-postcode"><a class="header" href="#registered-address-postcode">Registered Address: Postcode</a></h3>
<p><code>RegAddress.PostCode</code></p>
<pre><code>Mask              Count      %       % of Prev   Example
A9 9A            88,252   88.3%          —        L23 0RG
A9A 9A            7,347    7.3%        8.3%       W1W 7LT
(empty)           4,367    4.4%       59.4%
A9A                  12    0.0%        0.3%       GU478QN          ← cliff point
A9                    3    0.0%       25.0%       BB14006
9                     3    0.0%      100.0%       0255
9 9                   3    0.0%      100.0%       19 904
A9 9A.                2    0.0%       66.7%       BR7 5HF.
A9 9 A                2    0.0%      100.0%       WR9 9 AY
A9 A                  2    0.0%      100.0%       BA14 HHD
A9A9A                 1    0.0%       50.0%       EC1V2NX
A_A9 9A               1    0.0%      100.0%       L;N9 6NE
A 9                   1    0.0%      100.0%       BLOCK 3
A 9A                  1    0.0%      100.0%       CRO 9XP
9A A                  1    0.0%      100.0%       2L ONE
A9A 9 A               1    0.0%      100.0%       EC1V 1 NR
</code></pre>
<p>This field is analysed in detail in Chapter 6 using the HU (high-grain) profile, which separates the five standard UK postcode formats. At LU grain, those five formats collapse into two masks: <code>A9 9A</code> (the standard pattern, e.g. <code>L23 0RG</code>) and <code>A9A 9A</code> (formats where the outward code ends in a letter, like <code>W1W 7LT</code>).</p>
<p>The cliff drops from 7,347 to 12 — a percentage-of-previous of <strong>0.3%</strong>. Everything below is a data quality issue:</p>
<ul>
<li><code>A9A</code> (12 records, e.g. <code>GU478QN</code>) — valid postcodes with the space missing. <strong>Treatment:</strong> insert space before the inward code.</li>
<li><code>A9 9A.</code> (2 records, e.g. <code>BR7 5HF.</code>) — trailing full stop. <strong>Treatment:</strong> strip trailing punctuation.</li>
<li><code>A9 9 A</code> (2 records, e.g. <code>WR9 9 AY</code>) — extra space in the inward code. <strong>Treatment:</strong> normalise whitespace.</li>
<li><code>A9A9A</code> (1 record: <code>EC1V2NX</code>) — a valid postcode with all spaces removed. <strong>Treatment:</strong> insert space before the inward code.</li>
<li><code>A_A9 9A</code> (1 record: <code>L;N9 6NE</code>) — semicolon in the postcode, likely a typo for <code>LN9 6NE</code>. <strong>Treatment:</strong> character substitution rule.</li>
<li><code>A 9</code> (1 record: <code>BLOCK 3</code>) — not a postcode at all. Address fragment in the wrong field.</li>
<li><code>A 9A</code> (1 record: <code>CRO 9XP</code>) — likely a miskeyed <code>CR0 9XP</code> where the digit zero was typed as the letter O. <strong>Treatment:</strong> character substitution.</li>
<li><code>9A A</code> (1 record: <code>2L ONE</code>) — not a postcode. Investigate source record.</li>
<li><code>9</code> and <code>9 9</code> (3 each, e.g. <code>0255</code>, <code>19 904</code>) — numeric values, likely foreign postal codes or phone number fragments.</li>
</ul>
<h3 id="registered-address-post-town"><a class="header" href="#registered-address-post-town">Registered Address: Post Town</a></h3>
<p><code>RegAddress.PostTown</code></p>
<pre><code>Mask              Count      %       Example
A                84,153   84.2%      READING
A A               6,299    6.3%      HEBDEN BRIDGE
(empty)           5,011    5.0%
A A A             1,585    1.6%      STOCKTON ON TEES
A-A-A             1,428    1.4%      STOCKTON-ON-TEES
A. A                350    0.4%      ST. HELENS
A_A A               184    0.2%      KING'S LYNN
A A. A              179    0.2%      OTTERY ST. MARY
A, A                151    0.2%      MERSEYSIDE,...
A A A A              79    0.1%      HARROW ON THE...
A A, A               78    0.1%      BILLINGTON ROAD,...
A,                   62    0.1%      LONDON,
A-A-A-A              60    0.1%      ASHBY-DE-LA-ZOUCH
A-A                  44    0.0%      (various)
A. A-A-A             43    0.0%      ST. (various)
9 A A                32    0.0%      150 HOLYWOOD ROAD
A _ A                26    0.0%      BRIGHTON &amp; HOVE
A9 9A                14    0.0%      EH47 8PG
9-9 A A              10    0.0%      1-7 KING STREET
A 9                  10    0.0%      LEEDS 4
A9A 9A                3    0.0%      W1K 5SL
9                     2    0.0%      20037
A 9-9                 1    0.0%      CT 0633-4409
9A A                  1    0.0%      2ND FLOOR
</code></pre>
<p>...and 75 more masks.</p>
<p>The top five masks are all legitimate town name patterns: single words (<code>READING</code>), two words (<code>HEBDEN BRIDGE</code>), three words (<code>STOCKTON ON TEES</code>), hyphenated forms (<code>STOCKTON-ON-TEES</code>), and abbreviated forms (<code>ST. HELENS</code>). Together they cover 98.5% of records.</p>
<p>Below the cliff, things get interesting:</p>
<ul>
<li><code>A, A</code> (151 records, e.g. <code>MERSEYSIDE,...</code>) — town with trailing county or region, comma-separated. The town field is being used to store town-plus-county.</li>
<li><code>A,</code> (62 records, e.g. <code>LONDON,</code>) — trailing comma, as if the value was split from a comma-separated address string but the comma came along for the ride. <strong>Treatment:</strong> strip trailing punctuation.</li>
<li><code>9 A A</code> (32 records, e.g. <code>150 HOLYWOOD ROAD</code>) — a street address, not a town. Data in the wrong field entirely.</li>
<li><code>A9 9A</code> (14 records, e.g. <code>EH47 8PG</code>) — a <strong>postcode</strong> in the town field. Classic column misalignment.</li>
<li><code>9-9 A A</code> (10 records, e.g. <code>1-7 KING STREET</code>) — street addresses in the town field.</li>
<li><code>A 9</code> (10 records, e.g. <code>LEEDS 4</code>) — historic postal district format. Legitimate but archaic.</li>
<li><code>A9A 9A</code> (3 records, e.g. <code>W1K 5SL</code>) — another postcode in the town field.</li>
<li><code>9</code> (2 records, e.g. <code>20037</code>) — a US ZIP code in the town field.</li>
<li><code>9A A</code> (1 record: <code>2ND FLOOR</code>) — a floor number. Not a town by any definition.</li>
</ul>
<p><strong>Key finding:</strong> At least 59 records have postcodes or street addresses in the town field, indicating systematic column misalignment in a subset of the source data.</p>
<h3 id="registered-address-county"><a class="header" href="#registered-address-county">Registered Address: County</a></h3>
<p><code>RegAddress.County</code></p>
<pre><code>Mask              Count      %       Example
(empty)          61,374   61.4%
A                30,482   30.5%      HERTFORDSHIRE
A A               6,948    6.9%      WEST MIDLANDS
A A A               626    0.6%      ENGLAND AND WALES
A. A                111    0.1%      CO. DURHAM
A _ A               104    0.1%      TYNE &amp; WEAR
A.                   49    0.0%      KENT.
A A A A              40    0.0%      EAST RIDING OF...
A,                   35    0.0%      WORCESTER,
A-A                  33    0.0%      INVERNESS-SHIRE
A, A                 22    0.0%      HARROW, MIDDLESEX
A 9                  14    0.0%      DELAWARE 19801
A9 9A                11    0.0%      N3 2SB
A-A-A                10    0.0%      STOKE-ON-TRENT
9                     9    0.0%      100031
A _A_                 8    0.0%      COUNTY (OPTIONAL)
A.A                   7    0.0%      S.GLAMORGAN
A. A.                 7    0.0%      CO. ANTRIM.
A9                    7    0.0%      WC1
A A 9                 6    0.0%      NEW YORK 10286
-                     3    0.0%      -
A 9 A                 3    0.0%      WY 82001 USA
A.A.A.                3    0.0%      R.C.T.
A 9-9                 3    0.0%      TOKYO 100-8051
A. A9 9A              2    0.0%      WILTSHIRE. SN14...
A9 9A.                2    0.0%      DN1 2HD.
A.A.                  2    0.0%      U.K.
A A.                  2    0.0%      WEST YORKS.
-A-                   1    0.0%      --SELECT--
.                     1    0.0%      .
A9A 9A                1    0.0%      LONDONWC1X 8JX
- -                   1    0.0%      - -
A. A9A                1    0.0%      CAMBS. PE189QX
A.A.A9 9A             1    0.0%      N.WALES.LL15 1LG
A - A                 1    0.0%      ENGLAND - UK
_A A, A A A_          1    0.0%      [OUTSIDE US, ENTER COUNTY HERE]
</code></pre>
<p>The county field is 61.4% empty — expected, since counties are increasingly optional in UK addresses. The legitimate patterns (<code>A</code>, <code>A A</code>, <code>A A A</code>) cover 97.8% of populated values.</p>
<p>Below the cliff, a catalogue of problems:</p>
<ul>
<li><code>A.</code> (49 records, e.g. <code>KENT.</code>) — trailing full stop on county names. <strong>Treatment:</strong> strip trailing punctuation.</li>
<li><code>A,</code> (35 records, e.g. <code>WORCESTER,</code>) — trailing comma. <strong>Treatment:</strong> strip trailing punctuation.</li>
<li><code>A 9</code> (14 records, e.g. <code>DELAWARE 19801</code>) — US state with ZIP code. Foreign address data in the county field.</li>
<li><code>A9 9A</code> (11 records, e.g. <code>N3 2SB</code>) — UK postcodes in the county field. Column misalignment again.</li>
<li><code>9</code> (9 records, e.g. <code>100031</code>) — pure numeric. Likely foreign postal codes.</li>
<li><code>A _A_</code> (8 records: <code>COUNTY (OPTIONAL)</code>) — placeholder text left by a web form. The literal string "COUNTY (OPTIONAL)" was submitted as the county value.</li>
<li><code>A A 9</code> (6 records, e.g. <code>NEW YORK 10286</code>) — US city with ZIP code.</li>
<li><code>A 9-9</code> (3 records, e.g. <code>TOKYO 100-8051</code>) — Japanese address data. This is not a UK county.</li>
<li><code>-</code> (3 records) and <code>- -</code> (1 record) — dash placeholders, the universal "I had to put something in this field."</li>
<li><code>A. A9 9A</code> (2 records, e.g. <code>WILTSHIRE. SN14...</code>) — county with postcode appended.</li>
<li><code>A9 9A.</code> (2 records, e.g. <code>DN1 2HD.</code>) — a postcode with a trailing full stop, in the county field.</li>
<li><code>-A-</code> (1 record: <code>--SELECT--</code>) — a web form dropdown placeholder that was submitted as data. Someone's browser rendered a <code>&lt;select&gt;</code> element, they left it on the default option, and the literal text <code>--SELECT--</code> was persisted to the database.</li>
<li><code>A9A 9A</code> (1 record: <code>LONDONWC1X 8JX</code>) — an entire postcode, concatenated with the city name, stuffed into the county field.</li>
<li><code>A. A9A</code> (1 record: <code>CAMBS. PE189QX</code>) — an abbreviated county with a postcode jammed onto the end.</li>
<li><code>A.A.A9 9A</code> (1 record: <code>N.WALES.LL15 1LG</code>) — abbreviated region with an unseparated postcode.</li>
<li><code>_A A, A A A_</code> (1 record: <code>[OUTSIDE US, ENTER COUNTY HERE]</code>) — instructional placeholder text from a web form, complete with square brackets, submitted as the actual county value.</li>
</ul>
<p><strong>Key finding:</strong> The county field is a dumping ground. Web form placeholders (<code>COUNTY (OPTIONAL)</code>, <code>--SELECT--</code>, <code>[OUTSIDE US, ENTER COUNTY HERE]</code>), foreign addresses (<code>DELAWARE 19801</code>, <code>NEW YORK 10286</code>, <code>TOKYO 100-8051</code>), postcodes, and trailing punctuation all appear. This single field demonstrates why profiling by masks is more effective than regex validation — the variety of failure modes is too diverse for any reasonable set of hand-written rules to catch.</p>
<h3 id="registered-address-country"><a class="header" href="#registered-address-country">Registered Address: Country</a></h3>
<p><code>RegAddress.Country</code></p>
<pre><code>Mask              Count      %       Example
A                41,019   41.0%      ENGLAND
(empty)          34,930   34.9%
A A              24,039   24.0%      UNITED KINGDOM
A A A                 5    0.0%      ISLE OF MAN
A A, A                5    0.0%      VIRGIN ISLANDS,...
A _ A                 1    0.0%      ENGLAND &amp; WALES
</code></pre>
<p>Three legitimate patterns that together account for 99.97% of records. But there is a consistency problem: <code>A</code> (41,019) covers single-word countries like <code>ENGLAND</code>, <code>SCOTLAND</code>, <code>WALES</code>, while <code>A A</code> (24,039) covers <code>UNITED KINGDOM</code>. These are the same country expressed differently — some records say <code>ENGLAND</code>, others say <code>UNITED KINGDOM</code>, and 34.9% say nothing at all.</p>
<p>Below the cliff:</p>
<ul>
<li><code>A A A</code> (5 records, e.g. <code>ISLE OF MAN</code>) — legitimate, just rare.</li>
<li><code>A A, A</code> (5 records, e.g. <code>VIRGIN ISLANDS,...</code>) — legitimate but includes comma formatting.</li>
<li><code>A _ A</code> (1 record: <code>ENGLAND &amp; WALES</code>) — a jurisdiction description, not a country name. This is what someone writes when they are not sure which constituent nation to pick.</li>
</ul>
<p><strong>Key finding:</strong> The real issue here is not the exceptions — it is the inconsistency between <code>ENGLAND</code> and <code>UNITED KINGDOM</code> as country values. A treatment function should normalise these to a single canonical form (such as ISO 3166 country code <code>GB</code>).</p>
<h3 id="company-category"><a class="header" href="#company-category">Company Category</a></h3>
<p><code>CompanyCategory</code></p>
<pre><code>Mask                                               Count      %       Example
Aa Aa Aa                                          85,872   85.9%      Private Limited Company
A_A A A_A _Aa, a a a, a a a_                       6,203    6.2%      PRI/LTD BY GUAR/NSC (Private, limited by guarantee, no share capital)
A_A_A _Aa, Aa a a, a a a, a a _Aa_ a_              5,585    5.6%      PRI/LBG/NSC (Private, Limited by guarantee, no share capital, use of 'Limited' exemption)
Aa Aa                                               1,631    1.6%      Limited Partnership
Aa Aa Aa Aa                                           455    0.5%      Scottish Limited Partnership
Aa a a                                                137    0.1%      Other company type
Aa Aa a Aa Aa                                          89    0.1%      Investment Company with Variable Capital
A A A. 9 _Aa a a, a 9 a a Aa Aa_                       3    0.0%      PRIV LTD SECT. 30 (Private limited company, section 30 of the Companies Act)
</code></pre>
<p>Two formatting conventions exist side by side: human-readable title case (<code>Private Limited Company</code>, 85.9%) and coded abbreviations with parenthetical expansions (<code>PRI/LTD BY GUAR/NSC (Private, limited by guarantee, no share capital)</code>, 6.2%; <code>PRI/LBG/NSC (Private, Limited by guarantee, no share capital, use of 'Limited' exemption)</code>, 5.6%). The coded forms use slashes, parentheses, and abbreviations — a completely different format from the title case descriptions.</p>
<p>The 3-record <code>PRIV LTD SECT. 30</code> mask is a third variation: all-caps abbreviation with a section number reference and a parenthetical expansion. Three encoding schemes in a single column.</p>
<p><strong>Key finding:</strong> This field has multiple distinct encoding schemes coexisting. A treatment function should either expand the abbreviations to full text or code the full text to abbreviations, depending on the consumer's needs. The profiler has discovered what no schema definition would tell you: the field is not consistently formatted.</p>
<h3 id="company-status"><a class="header" href="#company-status">Company Status</a></h3>
<p><code>CompanyStatus</code></p>
<pre><code>Mask                                Count      %       Example
Aa                                 96,621   96.6%      Active
Aa - Aa a Aa a                      3,277    3.3%      Active - Proposal to Strike off
Aa Aa                                  79    0.1%      Voluntary Arrangement
Aa a Aa Aa a a a a a                   12    0.0%      Live but Receiver Manager on at least one charge
Aa Aa_Aa Aa                             5    0.0%      In Administration/Administrative Receiver
A                                       5    0.0%      RECEIVERSHIP
</code></pre>
<p>96.6% of companies are <code>Active</code>. The <code>A</code> mask (5 records: <code>RECEIVERSHIP</code>) is the only ALL-CAPS value in a field that otherwise uses title case. This is a minor casing inconsistency — but it is the kind of thing that breaks a <code>CASE WHEN</code> statement or a join on status values. A downstream query looking for <code>WHERE status = 'Receivership'</code> will silently miss these five records.</p>
<p><strong>Treatment:</strong> Normalise casing to title case.</p>
<h3 id="country-of-origin"><a class="header" href="#country-of-origin">Country of Origin</a></h3>
<p><code>CountryOfOrigin</code></p>
<pre><code>Mask              Count      %       Example
Aa Aa            99,868   99.9%      United Kingdom
A A                  78    0.1%      SOUTH KOREA
A                    45    0.0%      AUSTRALIA
A A A                 6    0.0%      UNITED ARAB EMIRATES
A A, A                1    0.0%      VIRGIN ISLANDS, BRITISH
(empty)               1    0.0%
</code></pre>
<p>99.87% of records show <code>United Kingdom</code> in title case. The remaining 131 records use ALL-CAPS (<code>SOUTH KOREA</code>, <code>AUSTRALIA</code>, <code>UNITED ARAB EMIRATES</code>). This is the same field in the same dataset using two different casing conventions — title case for UK records, all-caps for foreign origins.</p>
<p>One record is completely empty — a company with no country of origin recorded.</p>
<p><strong>Treatment:</strong> Normalise casing. Consider mapping to ISO 3166 country codes for consistency.</p>
<h3 id="incorporation-date"><a class="header" href="#incorporation-date">Incorporation Date</a></h3>
<p><code>IncorporationDate</code></p>
<pre><code>Mask              Count      %       Example
9_9_9            99,947   99.9%      07/12/2016
(empty)              52    0.1%
</code></pre>
<p>99.95% of records have a date in <code>DD/MM/YYYY</code> format (which LU collapses to <code>9_9_9</code>, as in <code>07/12/2016</code>). But 52 companies have <strong>no incorporation date</strong>. How does a registered company not have an incorporation date? These are likely very old companies (pre-dating digital records) or special entity types where the concept does not apply. Worth investigating but not necessarily an error.</p>
<p><strong>Action:</strong> Flag for review. These 52 records are genuine edge cases in the domain, not data entry errors.</p>
<h3 id="accounts-category"><a class="header" href="#accounts-category">Accounts Category</a></h3>
<p><code>Accounts.AccountCategory</code></p>
<pre><code>Mask              Count      %       Example
A A A            54,633   54.6%      NO ACCOUNTS FILED
(empty)          24,534   24.5%
A                18,041   18.0%      GROUP
A A               2,751    2.8%      UNAUDITED ABRIDGED
A A A A              40    0.0%      ACCOUNTS TYPE NOT AVAILABLE
</code></pre>
<p>The dominant value is <code>NO ACCOUNTS FILED</code> (54.6%), followed by empty (24.5%) and single-word categories like <code>GROUP</code> (18.0%), then two-word categories like <code>UNAUDITED ABRIDGED</code> (2.8%). The 40 records matching <code>A A A A</code> are literally <code>ACCOUNTS TYPE NOT AVAILABLE</code> — a system-generated placeholder rather than a real category.</p>
<p>No structural data quality issues here — the patterns are all legitimate. But the 24.5% empty rate is worth noting: nearly a quarter of companies have no accounts category recorded. This could indicate recently incorporated companies that have not yet filed.</p>
<h3 id="sic-code"><a class="header" href="#sic-code">SIC Code</a></h3>
<p><code>SICCode.SicText_1</code></p>
<pre><code>Mask                                  Count      %       Example
9 - Aa a a a                        17,112   17.1%      59111 - Motion picture production activities
9 - Aa a a                          11,233   11.2%      93199 - Other sports activities
9 - Aa a                             8,558    8.6%      55900 - Other accommodation
9 - Aa a a a a a.a.a.                7,068    7.1%      94990 - Activities of other membership organisations n.e.c.
9 - Aa a a a a                       6,959    7.0%      46450 - Wholesale of perfume and cosmetics
Aa Aa                                 6,562    6.6%      None Supplied
9 - Aa a a a a a a                    5,875    5.9%      70229 - Management consultancy activities (other than financial management)
9 - Aa a a a a a a a a a              3,935    3.9%      68320 - Management of real estate on a fee or contract basis
9 - Aa a a a.a.a.                     3,064    3.1%      96090 - Other personal service activities n.e.c.
9 - Aa Aa                             2,896    2.9%      99999 - Dormant Company
</code></pre>
<p>...and 143 more masks (153 total).</p>
<p>The SIC code field combines a 5-digit code with a human-readable description: <code>59111 - Motion picture production activities</code>. The LU masks vary because the descriptions vary in word count, punctuation, and casing. There are 153 unique masks — high cardinality driven by the diversity of SIC code descriptions.</p>
<p>The outlier is <code>Aa Aa</code> (6,562 records): <code>None Supplied</code>. These are companies that registered without providing a SIC code. The mask tells us immediately that this value is structurally different from every other entry — it has no leading numeric code and no dash separator. A simple assertion rule could flag it: if the SIC code does not start with digits, it is not a valid code.</p>
<p><strong>Key finding:</strong> The SIC code field is a composite field — a code and a description packed into a single column. The profiler cannot separate these without domain logic, but it can tell you that the structure is consistent across 93.4% of records and that <code>None Supplied</code> is the primary exception.</p>
<h2 id="summary-of-findings"><a class="header" href="#summary-of-findings">Summary of Findings</a></h2>
<p>Issues discovered through mask-based profiling of 99,999 Companies House records:</p>
<p><strong>Postcodes:</strong></p>
<ul>
<li>Missing spaces in valid postcodes (12 records, e.g. <code>GU478QN</code>) → <strong>Treatment:</strong> insert space</li>
<li>Trailing punctuation (2 records, e.g. <code>BR7 5HF.</code>) → <strong>Treatment:</strong> strip trailing characters</li>
<li>Extra whitespace (2 records, e.g. <code>WR9 9 AY</code>) → <strong>Treatment:</strong> normalise whitespace</li>
<li>Typos/special characters (1 record: <code>L;N9 6NE</code> with semicolon) → <strong>Treatment:</strong> character substitution</li>
<li>Non-postcode data in postcode field (5 records, e.g. <code>BLOCK 3</code>, <code>2L ONE</code>) → <strong>Flag</strong> for review</li>
</ul>
<p><strong>Post Town:</strong></p>
<ul>
<li>Postcodes in town field (17+ records, e.g. <code>EH47 8PG</code>, <code>W1K 5SL</code>) → <strong>Flag:</strong> column misalignment</li>
<li>Street addresses in town field (42+ records, e.g. <code>150 HOLYWOOD ROAD</code>, <code>1-7 KING STREET</code>) → <strong>Flag:</strong> column misalignment</li>
<li>Trailing commas and punctuation (62+ records, e.g. <code>LONDON,</code>) → <strong>Treatment:</strong> strip trailing punctuation</li>
<li>Non-address data (1 record: <code>2ND FLOOR</code>) → <strong>Flag</strong> for review</li>
</ul>
<p><strong>County:</strong></p>
<ul>
<li>Trailing punctuation (84 records, e.g. <code>KENT.</code>, <code>WORCESTER,</code>) → <strong>Treatment:</strong> strip trailing characters</li>
<li>Postcodes in county field (11 records, e.g. <code>N3 2SB</code>) → <strong>Flag:</strong> column misalignment</li>
<li>Foreign address data (20+ records, e.g. <code>DELAWARE 19801</code>, <code>NEW YORK 10286</code>, <code>TOKYO 100-8051</code>) → <strong>Flag:</strong> non-UK addresses</li>
<li>Web form placeholders: <code>COUNTY (OPTIONAL)</code>, <code>--SELECT--</code>, <code>[OUTSIDE US, ENTER COUNTY HERE]</code> (10 records) → <strong>Treatment:</strong> replace with empty</li>
<li>Dash placeholders (4 records) → <strong>Treatment:</strong> replace with empty</li>
</ul>
<p><strong>Country:</strong></p>
<ul>
<li>Inconsistent representation: <code>ENGLAND</code> vs <code>UNITED KINGDOM</code> vs empty → <strong>Treatment:</strong> normalise to ISO country code</li>
<li>34.9% empty → <strong>Accept</strong> (empty is valid for this field)</li>
</ul>
<p><strong>Company Category:</strong></p>
<ul>
<li>Multiple encoding schemes (human-readable <code>Private Limited Company</code> vs coded <code>PRI/LTD BY GUAR/NSC</code> vs <code>PRIV LTD SECT. 30</code>) → <strong>Treatment:</strong> normalise to single format</li>
</ul>
<p><strong>Company Status:</strong></p>
<ul>
<li>Inconsistent casing: <code>RECEIVERSHIP</code> vs <code>Active</code> → <strong>Treatment:</strong> normalise to title case</li>
</ul>
<p><strong>Country of Origin:</strong></p>
<ul>
<li>Inconsistent casing: <code>United Kingdom</code> (title case) vs <code>SOUTH KOREA</code> (all-caps) → <strong>Treatment:</strong> normalise casing</li>
</ul>
<p><strong>Incorporation Date:</strong></p>
<ul>
<li>52 records with no date → <strong>Flag</strong> for investigation (likely pre-digital or special entity types)</li>
</ul>
<p><strong>SIC Code:</strong></p>
<ul>
<li>6,562 records with <code>None Supplied</code> instead of a code → <strong>Assertion rule:</strong> SIC code must start with digits</li>
</ul>
<h2 id="lessons-learned"><a class="header" href="#lessons-learned">Lessons Learned</a></h2>
<p><strong>1. Government data is not clean data.</strong> This is an official register maintained by a statutory body. It is well-structured by the standards of real-world data, and it still contains web form placeholders (<code>--SELECT--</code>, <code>COUNTY (OPTIONAL)</code>, <code>[OUTSIDE US, ENTER COUNTY HERE]</code>), column misalignment (postcodes in the town and county fields), inconsistent casing, trailing punctuation, and foreign address fragments. If Companies House data has these issues, every dataset you receive will have them.</p>
<p><strong>2. Mask profiling finds issues that schemas cannot.</strong> A schema tells you the postcode field is a string. Mask profiling tells you that 16 of the 99,999 records have structural anomalies — and shows you exactly what each one looks like. The postcode field has a single dominant pattern covering 88.3% of records, and every deviation from it is immediately visible in the mask frequency table.</p>
<p><strong>3. The cliff point works.</strong> In every field with more than a handful of masks, the frequency distribution showed a clear separation between expected patterns and exceptions. The postcode cliff (7,347 → 12), the county cliff (104 → 49), the post town cliff (151 → 79) — each one cleanly separates the normal from the exceptional.</p>
<p><strong>4. Column misalignment is a real and common problem.</strong> Postcodes appearing in the town field, street addresses appearing in the town field, postcodes appearing in the county field — these are not random errors. They indicate systematic problems in how data was entered, migrated, or mapped between systems. Mask profiling detects them instantly because the structural pattern of a postcode (<code>A9 9A</code>) is unmistakable when it appears in a field full of alphabetic town names (<code>A</code>).</p>
<p><strong>5. Real examples make the conversation possible.</strong> Every mask in the frequency table maps to a real value. When you can point to <code>--SELECT--</code> in the county field, or <code>150 HOLYWOOD ROAD</code> in the post town field, or <code>TOKYO 100-8051</code> as a UK county, the conversation with data owners moves from abstract ("there are quality issues") to concrete ("here are the specific records, here is what happened, here is how we fix it"). The examples are the evidence. Without them, you have statistics. With them, you have a story.</p>
<p><strong>6. One profiling run, twenty minutes, real insight.</strong> The entire analysis in this appendix was generated from a single <code>bytefreq</code> command that took seconds to run. The interpretation took longer, but the profiler did all the heavy lifting: it found the patterns, counted them, sorted them by frequency, and provided examples. Every issue catalogued above was visible in the raw output without writing a single validation rule.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="worked-example-profiling-japan-meteorological-agency-earthquake-data" class="unnumbered"><a class="header" href="#worked-example-profiling-japan-meteorological-agency-earthquake-data">Worked Example: Profiling Japan Meteorological Agency Earthquake Data</a></h1>
<p>This appendix is a second worked example, and it is deliberately different from the Companies House analysis that precedes it. Where that dataset was flat, tabular, and English, this one is deeply nested JSON, bilingual (Japanese and English), and sourced from a government agency on the other side of the world. The point is simple: mask-based profiling works on any data, in any language, from any structure, once you flatten it. The techniques described in this book are not limited to pipe-delimited CSV files from the UK — they apply universally, and this example proves it.</p>
<h2 id="the-dataset-1"><a class="header" href="#the-dataset-1">The Dataset</a></h2>
<p>The Japan Meteorological Agency (JMA) publishes open earthquake data through a public API. An index of recent seismic events is available at <a href="https://www.jma.go.jp/bosai/quake/data/list.json">https://www.jma.go.jp/bosai/quake/data/list.json</a>, and each event links to a detailed JSON document containing the earthquake's hypocenter location, magnitude, maximum intensity, and — crucially — a full breakdown of seismic intensity observations at every reporting station across the affected region.</p>
<p>The dataset used here comprises 80 earthquake events containing 2,433 individual seismic station observations. The data is freely available, requires no authentication, and is published in both Japanese (the <code>Name</code> field at every level) and English (the <code>enName</code> field). It is exactly the kind of rich, nested, non-English dataset that traditional profiling tools struggle with.</p>
<h2 id="flattening-nested-json-for-profiling"><a class="header" href="#flattening-nested-json-for-profiling">Flattening Nested JSON for Profiling</a></h2>
<p>The raw JSON has six or more levels of nesting. A single earthquake event contains a <code>Body.Intensity.Observation</code> object, which contains an array of <code>Pref</code> (prefecture) objects, each of which contains an array of <code>Area</code> objects, each of which contains an array of <code>City</code> objects, each of which contains an array of <code>IntensityStation</code> objects with fields like <code>Name</code>, <code>enName</code>, <code>Int</code> (intensity), <code>Lat</code>, <code>Lon</code>, and <code>Prm</code> (whether the station is official). The path from the root to a station's latitude looks like this:</p>
<pre><code>Body.Intensity.Observation.Pref[0].Area[0].City[0].IntensityStation[0].Lat
</code></pre>
<p>To profile this with bytefreq, we need to flatten it — to turn every leaf value in the nested structure into a key-value pair where the key is the full dot-path and the value is the leaf content. This is the flat enhanced format described in Chapter 9, and it handles nested data naturally because each record is simply a bag of key-value pairs rather than a fixed set of columns.</p>
<p>The flattening produces a striking result: 80 earthquake records generate 6,551 unique flattened key paths. This happens because different earthquakes affect different numbers of prefectures, areas, cities, and stations. One earthquake might trigger observations at 3 stations in 1 prefecture; another might light up 200 stations across 8 prefectures. When we preserve array indices in the key paths (e.g. <code>Pref[0].Area[0].City[0]</code> vs <code>Pref[0].Area[0].City[1]</code>), each unique combination of indices produces a unique key. This is the "ragged row" problem — and the flat enhanced format handles it without any special treatment, because there is no requirement that every record have the same set of keys.</p>
<p>When we collapse array indices (treating all <code>Pref[]</code> entries as equivalent, all <code>Area[]</code> entries as equivalent, and so on), the 6,551 unique paths reduce to 81 unique field paths. But these 81 fields have varying numbers of values: <code>Body.Earthquake.Hypocenter.Area.Name</code> has 80 values (one per earthquake), <code>Body.Intensity.Observation.Pref.Name</code> has 157 values (some earthquakes affect multiple prefectures), <code>Body.Intensity.Observation.Pref.Area.City.Name</code> has 1,546 values, and <code>Body.Intensity.Observation.Pref.Area.City.IntensityStation.Name</code> has 2,433 values at the deepest level. The deeper you go in the hierarchy, the more values you get — a one-to-many fan-out at every level of nesting.</p>
<h2 id="structure-discovery-field-population-analysis"><a class="header" href="#structure-discovery-field-population-analysis">Structure Discovery: Field Population Analysis</a></h2>
<p>Before examining individual field values, we profile the field paths themselves. For each dot-notation path (with array indices collapsed), we count how many of the 80 earthquake records contain that path and express it as a percentage. This is the structural discovery step — it tells us the shape of the data before we look at what is in it.</p>
<pre><code>Field Path                                                            Count  % Populated
-----------------------------------------------------------------------------------------
Control.DateTime                                                         80     100.0%
Control.EditorialOffice                                                  80     100.0%
Control.PublishingOffice                                                 80     100.0%
Control.Status                                                           80     100.0%
Control.Title                                                            80     100.0%
Head.EventID                                                             80     100.0%
Head.InfoKind                                                            80     100.0%
Head.InfoKindVersion                                                     80     100.0%
Head.InfoType                                                            80     100.0%
Head.ReportDateTime                                                      80     100.0%
Head.Serial                                                              80     100.0%
Head.TargetDateTime                                                      80     100.0%
Head.Title                                                               80     100.0%
Head.enTitle                                                             80     100.0%
Head.Headline.Text                                                       80     100.0%
Head.Headline.Information.Item.Kind.Name                                  8      10.0%
Head.Headline.Information.Item.Areas.Area.Code                            8      10.0%
Head.Headline.Information.Item.Areas.Area.Name                            8      10.0%
Body.Earthquake.ArrivalTime                                              80     100.0%
Body.Earthquake.Magnitude                                                80     100.0%
Body.Earthquake.OriginTime                                               80     100.0%
Body.Earthquake.Hypocenter.Area.Code                                     80     100.0%
Body.Earthquake.Hypocenter.Area.Coordinate                               80     100.0%
Body.Earthquake.Hypocenter.Area.Name                                     80     100.0%
Body.Earthquake.Hypocenter.Area.enName                                   80     100.0%
Body.Comments.ForecastComment.Code                                       80     100.0%
Body.Comments.ForecastComment.Text                                       80     100.0%
Body.Comments.ForecastComment.enText                                     80     100.0%
Body.Comments.VarComment.Code                                            75      93.8%
Body.Comments.VarComment.Text                                            75      93.8%
Body.Comments.VarComment.enText                                          75      93.8%
Body.Intensity.Observation.MaxInt                                        80     100.0%
Body.Intensity.Observation.Pref.Code                                     80     100.0%
Body.Intensity.Observation.Pref.MaxInt                                   80     100.0%
Body.Intensity.Observation.Pref.Name                                     80     100.0%
Body.Intensity.Observation.Pref.enName                                   80     100.0%
Body.Intensity.Observation.Pref.Area.Code                                80     100.0%
Body.Intensity.Observation.Pref.Area.MaxInt                              80     100.0%
Body.Intensity.Observation.Pref.Area.Name                                80     100.0%
Body.Intensity.Observation.Pref.Area.enName                              80     100.0%
Body.Intensity.Observation.Pref.Area.Revise                               1       1.2%
Body.Intensity.Observation.Pref.Area.City.Code                           80     100.0%
Body.Intensity.Observation.Pref.Area.City.MaxInt                         80     100.0%
Body.Intensity.Observation.Pref.Area.City.Name                           80     100.0%
Body.Intensity.Observation.Pref.Area.City.enName                         80     100.0%
Body.Intensity.Observation.Pref.Area.City.Revise                          1       1.2%
Body.Intensity.Observation.Pref.Area.City.IntensityStation.Code          80     100.0%
Body.Intensity.Observation.Pref.Area.City.IntensityStation.Int           80     100.0%
Body.Intensity.Observation.Pref.Area.City.IntensityStation.Name          80     100.0%
Body.Intensity.Observation.Pref.Area.City.IntensityStation.enName        80     100.0%
Body.Intensity.Observation.Pref.Area.City.IntensityStation.Revise         1       1.2%
Body.Intensity.Observation.Pref.Area.City.IntensityStation.latlon.lat    80     100.0%
Body.Intensity.Observation.Pref.Area.City.IntensityStation.latlon.lon    80     100.0%
</code></pre>
<p>The core earthquake structure — Control, Head, Body.Earthquake, Body.Intensity — is 100% populated across all 80 records. This is the spine of the data, the set of fields that every earthquake report shares regardless of magnitude or location. When we see 100% population at this scale, it tells us the schema is well-enforced for the core reporting obligation, which is exactly what we would expect from a national meteorological agency publishing structured seismic data.</p>
<p><code>Body.Comments.VarComment.*</code> drops to 93.8% — five earthquakes had no variable commentary. This is not a data quality issue; some events are too minor or too routine to warrant additional commentary. But the profiler flags it, and that is the point: the absence of a field in nested data is itself information. In a flat schema, these five records would have null values in the VarComment columns. In nested JSON, the key simply does not exist. The field population analysis treats both representations the same way, which is one of the advantages of profiling the flattened form.</p>
<p><code>Head.Headline.Information.*</code> appears in only 10% of records (8 earthquakes). This block contains detailed area-level intensity information in the headline — it is only populated for significant earthquakes where multiple areas experienced notable shaking. The other 90% of records have a simple text headline without the structured breakdown. This is a common pattern in operational data: optional sub-structures that are conditionally populated based on the severity or complexity of the event. The population percentage tells you immediately how common or rare the condition is.</p>
<p>The <code>Revise</code> field appears at three levels (Area, City, IntensityStation) but only in 1.2% of records — exactly one earthquake. This is a revision flag indicating that intensity observations were updated after initial publication. It is a rare operational flag that you would never discover by reading the API documentation, but the field population analysis surfaces it immediately. In a flat schema, this field would be a column that is 98.8% null. In nested JSON, it simply does not appear in most records. The profiler treats both the same way.</p>
<h2 id="field-by-field-analysis-1"><a class="header" href="#field-by-field-analysis-1">Field-by-Field Analysis</a></h2>
<p>The profile was generated using bytefreq in LU (Low-grain Unicode) mode, the same starting grain used for the Companies House example.</p>
<h3 id="hypocenter-name-japanese"><a class="header" href="#hypocenter-name-japanese">Hypocenter Name (Japanese)</a></h3>
<p><code>Body.Earthquake.Hypocenter.Area.Name</code></p>
<pre><code>Mask    Count   Example
a          78   福島県会津
a_a         1   (compound name with punctuation separator)
</code></pre>
<p>Every Japanese place name — regardless of length, kanji composition, or regional variation — collapses to a single <code>a</code> mask. This is a direct consequence of the LU character class rules: all CJK ideographs (kanji), hiragana, and katakana characters are classified as alphabetic, and the low-grain mode collapses consecutive characters of the same class. A four-character name like <code>福島県沖</code> and an eight-character name like <code>茨城県南部</code> both produce <code>a</code>.</p>
<p>This is correct behaviour. At low grain, we are asking "what is the structural shape of this field?" and the answer is: it is consistently alphabetic text with one exception that contains punctuation. The single <code>a_a</code> record has some kind of separator character (a middle dot or similar punctuation) within the name, making it structurally different from the other 78 records. That is worth investigating — but the overwhelming consistency of the field is the main finding.</p>
<p>For CJK text, if you need to distinguish between names of different lengths, you would switch to HU (High-grain Unicode) mode, which preserves character counts. But for discovery profiling, the LU result tells us exactly what we need to know: this field is structurally uniform.</p>
<h3 id="hypocenter-name-english"><a class="header" href="#hypocenter-name-english">Hypocenter Name (English)</a></h3>
<p><code>Body.Earthquake.Hypocenter.Area.enName</code></p>
<pre><code>Mask                                Count   Example
Aa Aa Aa                               18   Southern Ibaraki Prefecture
Aa a a Aa a Aa Aa                      12   Off the east Coast of Aomori Prefecture
Aa a Aa a Aa Aa                        10   Off the Coast of Ibaraki Prefecture
Aa Aa a Aa Aa                           8   Northern Inland Bay of Suruga
Aa Aa Aa, Aa                            7   Northern Nemuro District, Hokkaido
Aa, Aa Aa                               5   Chuetsu, Niigata Prefecture
Aa a a Aa a Aa                          4   Off the east Coast of Chiba
Aa Aa                                   3   Hyuganada Sea
Aa a Aa a Aa                            3   Off the Coast of Miyagi
Aa Aa a Aa-Aa Aa                        2   Adjacent Sea of Yonagunijima Island
Aa Aa a Aa Aa Aa                        2   Adjacent Sea of Tanegashima Island
Aa a a Aa a Aa-Aa Aa                    2   Off the northeast Coast of Miyako-jima Island
Aa a a Aa Aa, Aa                        1   Central and Southern Aichi Prefecture
Aa Aa _ Aa Aa Aa, Aa Aa                 1   Eastern Region · Off the Coast of Hokkaido
Aa Aa, Aa Aa                            1   Northern Tsugaru, Aomori Prefecture
</code></pre>
<p>The English names are far more structurally diverse than the Japanese names — 15 distinct masks for 80 values. This is because English uses spaces between words (each space creates a boundary in the mask) and distinguishes between uppercase and lowercase (the <code>Aa</code> vs <code>a</code> distinction captures title case vs lowercase words like "the", "of", "and").</p>
<p>The masks reveal a naming convention: locations use title case for significant words (<code>Southern</code>, <code>Ibaraki</code>, <code>Prefecture</code>) and lowercase for articles and prepositions (<code>the</code>, <code>of</code>, <code>a</code>). This is consistent across the dataset and explains why <code>Aa a a Aa a Aa Aa</code> (12 records, "Off the east Coast of Aomori Prefecture") and <code>Aa a Aa a Aa Aa</code> (10 records, "Off the Coast of Ibaraki Prefecture") are separate masks — the former has one extra lowercase word.</p>
<p>The <code>Aa Aa _ Aa Aa Aa, Aa Aa</code> mask (1 record) is interesting: the <code>_</code> in the mask indicates a punctuation character that is neither a letter, digit, nor space. The example value is <code>Eastern Region · Off the Coast of Hokkaido</code> — a middle dot (·) used as a separator. This is the only record that uses this compound naming format, making it a structural outlier.</p>
<p>The hyphens in masks like <code>Aa-Aa Aa</code> (e.g. <code>Yonagunijima Island</code>) reflect the romanisation conventions for Japanese place names, where compound words are sometimes hyphenated (<code>Miyako-jima</code>). The profiler treats hyphens as punctuation, which correctly separates them from the alphabetic text.</p>
<h3 id="coordinate"><a class="header" href="#coordinate">Coordinate</a></h3>
<p><code>Body.Earthquake.Hypocenter.Area.Coordinate</code></p>
<pre><code>Mask            Count   Example
_9.9_9.9-9_        72   +36.6+140.6-10000/
_9.9_9.9_9_         7   +45.0+142.2+0/
</code></pre>
<p>Two structural variants in a field of 80 values, and the masks make the difference immediately visible. The dominant format <code>_9.9_9.9-9_</code> (72 records) encodes latitude, longitude, and depth as <code>+lat+lon-depth/</code>, where the depth is negative (below sea level, as expected for earthquake hypocenters). The second format <code>_9.9_9.9_9_</code> (7 records) has a positive or zero third component — <code>+45.0+142.2+0/</code> — meaning the depth is zero or the value represents an elevation rather than a depth.</p>
<p>This is a JMA-specific coordinate encoding. A schema would describe this field as a string. A regex validator might check for numeric content. But the mask profiler instantly reveals that there are two structural variants, and the difference is the sign character before the third numeric component: <code>-</code> in 72 records, <code>+</code> in 7 records. An analyst seeing this for the first time would immediately ask: why do 7 earthquakes have a positive depth value? Are these shallow surface events? Is zero depth a default? The mask does not answer these questions, but it makes sure they get asked.</p>
<h3 id="magnitude"><a class="header" href="#magnitude">Magnitude</a></h3>
<p><code>Body.Earthquake.Magnitude</code></p>
<pre><code>Mask    Count   Example
9.9        80   3.6
</code></pre>
<p>Perfectly consistent. Every magnitude is a decimal number, collapsed to <code>9.9</code> by the low-grain mask. No exceptions, no missing values, no structural anomalies. This is what a well-controlled numeric field looks like under profiling.</p>
<h3 id="maximum-intensity"><a class="header" href="#maximum-intensity">Maximum Intensity</a></h3>
<p><code>Body.Intensity.Observation.MaxInt</code></p>
<pre><code>Mask    Count   Example
9          80   1
</code></pre>
<p>Single digit, perfectly consistent across all 80 records. The JMA seismic intensity scale runs from 0 to 7 (with sub-levels like 5-lower and 5-upper, though those would have different masks if present). In this dataset, all maximum intensities are single-digit values.</p>
<h3 id="prefecture-name-japanese"><a class="header" href="#prefecture-name-japanese">Prefecture Name (Japanese)</a></h3>
<p><code>Body.Intensity.Observation.Pref.Name</code></p>
<pre><code>Mask    Count   Example
a         157   沖縄県
</code></pre>
<p>All 157 prefecture name values collapse to <code>a</code> — the same pattern we saw with the hypocenter names. Japanese prefecture names are composed entirely of kanji characters, and the LU mask treats them all identically. The count of 157 (versus 80 earthquakes) tells us that earthquakes routinely affect multiple prefectures — on average, about two prefectures per event, though the distribution is certainly skewed.</p>
<h3 id="city-name-japanese"><a class="header" href="#city-name-japanese">City Name (Japanese)</a></h3>
<p><code>Body.Intensity.Observation.Pref.Area.City.Name</code></p>
<pre><code>Mask    Count   Example
a       1,545   錦江町
</code></pre>
<p>Again, near-total uniformity: 1,545 of 1,546 city names collapse to <code>a</code>. The one exception (not shown in this summary) likely contains a non-kanji character — a numeral, a Latin letter, or an unusual punctuation mark in the city name. At this level of consistency, a single exception in 1,546 values is exactly the kind of outlier the profiler is designed to surface.</p>
<h3 id="station-name-japanese"><a class="header" href="#station-name-japanese">Station Name (Japanese)</a></h3>
<p><code>Body.Intensity.Observation.Pref.Area.City.IntensityStation.Name</code></p>
<pre><code>Mask    Count   Example
a_      2,002   (station name with ＊ suffix)
a         413   (plain station name)
a9a_       12   (station name with digits and ＊ suffix)
a9a         6   (station name with digits, no ＊ suffix)
</code></pre>
<p>This is where the profiling gets genuinely interesting. The <code>a_</code> mask (2,002 of 2,433 values, 82.3%) indicates station names that end with a punctuation character. That character is ＊ — a full-width asterisk — and it is not decoration. In JMA data, the ＊ suffix marks stations that are not part of the official seismic network; they are supplementary observation points operated by local governments or other agencies. The <code>a</code> mask (413 values, 17.0%) represents official stations without the suffix.</p>
<p>The mask has discovered a structural encoding convention that carries semantic meaning. A schema would describe this field as a string. A data dictionary might (or might not) mention the ＊ convention. But the profiler finds it automatically, because the full-width asterisk is a punctuation character and the mask faithfully records its presence.</p>
<p>The <code>a9a_</code> and <code>a9a</code> masks (12 and 6 values respectively) indicate station names that contain digits — likely stations identified by number within a municipality, such as "第２観測点" (Observation Point 2). The digit creates a break in the alphabetic run, producing a three-segment mask instead of a single <code>a</code>.</p>
<h3 id="station-name-english"><a class="header" href="#station-name-english">Station Name (English)</a></h3>
<p><code>Body.Intensity.Observation.Pref.Area.City.IntensityStation.enName</code></p>
<pre><code>Mask                    Count   Example
Aa-a Aa_                1,225   Omitama-shi Koshin*
Aa Aa-a Aa_               331   Kawasaki Miyamae-ku Miyamae*
Aa-a Aa                    272   Yoron-cho Mugiya
Aa-a Aa-a_                 213   Hitachinaka-shi Ajigaura*
Aa Aa-a Aa-a_               93   Saitama Chuo-ku Sakuragi*
Aa-a-a Aa_                  74   Shin-hidaka-cho Mitsuishi*
Aa-a Aa-a                   54   Mishima-shi Shimokiyomizu
Aa Aa-a Aa                  43   Saitama Urawa-ku Tokiwa
Aa Aa_                      24   Neba Murayakuba*
Aa-a Aa-a Aa_               19   Tochigi-shi Nishikata-cho*
Aa-a-a Aa-a                 13   Shin-hidaka-cho Shizunai
Aa-a-a Aa-a_                13   Shin-hidaka-cho Shizunai*
Aa Aa-a Aa-a                11   Kawasaki Tama-ku Ishida
Aa-a-a                       7   (compound hyphenated name)
Aa-a Aa-a-a_                 7   Nikko-shi Arasawa-cho*
Aa-a-a Aa Aa_                4   Mo-oka-shi Shimokawaji*
Aa-a Aa Aa                   3   Mutsu-shi Wakinosawa Muraichi
Aa-a a-Aa_                   3   Kamagaya-shi c-Kamagaya*
Aa-a a_                      3   Kazo-shi c-Kazo*
Aa-a AaAa_                   2   Sammu-shi c-Sanbu*
</code></pre>
<p>The English station names produce 20 or more distinct masks for 2,433 values, and the mask distribution tells a rich story about Japanese geographic naming conventions in romanised form.</p>
<p>The dominant pattern <code>Aa-a Aa_</code> (1,225 values, 50.3%) represents the standard format: a municipality name with a hyphenated suffix (<code>-shi</code>, <code>-cho</code>, <code>-machi</code>, <code>-mura</code> indicating city, town, or village), followed by a district or station name, followed by the <code>*</code> marker for unofficial stations. The hyphen is structural — it separates the municipality type suffix from the name, and the mask faithfully captures it.</p>
<p>The <code>Aa Aa-a Aa_</code> pattern (331 values) adds an extra component: a prefecture or city name before the hyphenated municipality, as in <code>Kawasaki Miyamae-ku Miyamae*</code> where <code>Kawasaki</code> is the city and <code>Miyamae-ku</code> is the ward.</p>
<p>Two masks deserve special attention. The <code>Aa-a a-Aa_</code> pattern (3 values, e.g. <code>Kamagaya-shi c-Kamagaya*</code>) contains a lowercase single letter <code>a</code> followed by a hyphen and a capitalised name. The <code>c-Kamagaya</code> component suggests a coded prefix — perhaps a sub-station identifier. Similarly, <code>Aa-a AaAa_</code> (2 values, e.g. <code>Sammu-shi c-Sanbu*</code>) shows a run of mixed case with no space between components. These are minor inconsistencies in the romanisation scheme, and the profiler surfaces them without any prior knowledge of Japanese naming conventions.</p>
<p>The <code>_</code> at the end of many masks corresponds to the asterisk (<code>*</code>) in the English names — the same unofficial station marker we saw as ＊ in the Japanese names, but here rendered as a standard ASCII asterisk rather than the full-width variant. The bilingual data reveals an encoding inconsistency: Japanese names use ＊ (U+FF0A, full-width asterisk) while English names use * (U+002A, standard asterisk). Both carry the same meaning, but they are different characters.</p>
<h3 id="station-intensity"><a class="header" href="#station-intensity">Station Intensity</a></h3>
<p><code>Body.Intensity.Observation.Pref.Area.City.IntensityStation.Int</code></p>
<pre><code>Mask    Count   Example
9       2,433   1
</code></pre>
<p>Perfectly consistent across all 2,433 station observations. Every intensity value is a single digit.</p>
<h3 id="station-latitude"><a class="header" href="#station-latitude">Station Latitude</a></h3>
<p><code>Body.Intensity.Observation.Pref.Area.City.IntensityStation.latlon.lat</code></p>
<pre><code>Mask    Count   Example
9.9     2,433   36.26
</code></pre>
<p>Every latitude value is a decimal number, collapsed to <code>9.9</code> by the low-grain mask. No missing values, no formatting inconsistencies, no structural anomalies across 2,433 observations.</p>
<h3 id="station-longitude"><a class="header" href="#station-longitude">Station Longitude</a></h3>
<p><code>Body.Intensity.Observation.Pref.Area.City.IntensityStation.latlon.lon</code></p>
<pre><code>Mask    Count   Example
9.9     2,433   139.58
</code></pre>
<p>Same as latitude — perfectly consistent decimal numbers across all 2,433 values.</p>
<h3 id="headline-text-japanese"><a class="header" href="#headline-text-japanese">Headline Text (Japanese)</a></h3>
<p><code>Head.Headline.Text</code></p>
<pre><code>Mask        Count   Example
9a9a9a_a_      80   ２１日１３時０３分ころ、地震がありました。
</code></pre>
<p>A single mask covers all 80 values, and it is one of the most revealing results in the entire profile. The mask <code>9a9a9a_a_</code> tells us that the headline text alternates between digits and alphabetic characters, with punctuation at certain positions. The example makes it clear: <code>２１日１３時０３分ころ、地震がありました。</code> translates roughly to "An earthquake occurred at approximately 13:03 on the 21st."</p>
<p>The digits in the mask are Japanese full-width numerals — <code>２１</code> rather than <code>21</code>, <code>１３</code> rather than <code>13</code>. These are Unicode characters in the Fullwidth Forms block (U+FF10 through U+FF19), and they are classified as digits by the Unicode standard. The bytefreq profiler, because it uses Unicode character class rules, correctly identifies them as digits and masks them as <code>9</code>. This is a validation of the Unicode-aware approach: a byte-level profiler working with ASCII assumptions would either fail on this text entirely or misclassify the full-width digits as alphabetic or unknown characters.</p>
<p>The alphabetic runs in the mask correspond to kanji and hiragana: <code>日</code> (day), <code>時</code> (hour), <code>分</code> (minute), <code>ころ</code> (approximately), <code>地震がありました</code> (an earthquake occurred). The punctuation marks <code>、</code> (Japanese comma) and <code>。</code> (Japanese full stop) produce the <code>_</code> segments.</p>
<p>The remarkable thing is the total consistency: all 80 headlines follow the same structural template. This is clearly a machine-generated string — a template like "{day}日{hour}時{minute}分ころ、地震がありました。" filled in with the event's date and time. The profiler confirms what we might suspect: this field is auto-generated, not human-authored, and its structure is completely predictable.</p>
<h2 id="character-profiling-the-full-width-digit-discovery"><a class="header" href="#character-profiling-the-full-width-digit-discovery">Character Profiling: The Full-Width Digit Discovery</a></h2>
<p>The bytefreq profiler has a Character Profiling mode (<code>-r CP</code>) that goes beyond structural masks to count every distinct Unicode code point in the data. Where masking tells you the shape of a field, character profiling tells you the exact inventory of characters that compose it. We ran the headline text field through character profiling and the results are remarkable.</p>
<pre><code>Hex       Char   Count   Unicode Name
------    ----   -----   ----------------------------------
U+3001    、       80    IDEOGRAPHIC COMMA
U+3002    。       80    IDEOGRAPHIC FULL STOP
U+3042    あ       80    HIRAGANA LETTER A
U+304C    が       80    HIRAGANA LETTER GA
U+3053    こ       80    HIRAGANA LETTER KO
U+3057    し       80    HIRAGANA LETTER SI
U+305F    た       80    HIRAGANA LETTER TA
U+307E    ま       80    HIRAGANA LETTER MA
U+308A    り       80    HIRAGANA LETTER RI
U+308D    ろ       80    HIRAGANA LETTER RO
U+5206    分       80    CJK UNIFIED IDEOGRAPH (minute)
U+5730    地       80    CJK UNIFIED IDEOGRAPH (ground)
U+65E5    日       80    CJK UNIFIED IDEOGRAPH (day)
U+6642    時       80    CJK UNIFIED IDEOGRAPH (hour)
U+9707    震       80    CJK UNIFIED IDEOGRAPH (quake)
U+FF10    ０       80    FULLWIDTH DIGIT ZERO
U+FF11    １      108    FULLWIDTH DIGIT ONE
U+FF12    ２       48    FULLWIDTH DIGIT TWO
U+FF13    ３       42    FULLWIDTH DIGIT THREE
U+FF14    ４       39    FULLWIDTH DIGIT FOUR
U+FF15    ５       37    FULLWIDTH DIGIT FIVE
U+FF16    ６       23    FULLWIDTH DIGIT SIX
U+FF17    ７       20    FULLWIDTH DIGIT SEVEN
U+FF18    ８       20    FULLWIDTH DIGIT EIGHT
U+FF19    ９       26    FULLWIDTH DIGIT NINE
</code></pre>
<p>The first thing that jumps out is the clean division between fixed and variable characters. The fifteen non-digit characters — the ideographic comma and full stop, the five hiragana characters, and the five kanji — all appear exactly 80 times, once per earthquake record. These are the template characters, the scaffolding of the sentence <code>２１日１３時０３分ころ、地震がありました。</code> ("Around [day] [hour]:[minute], there was an earthquake."). The character profiler has reverse-engineered the template from the data alone, without reading any documentation. Every headline follows the same sentence structure, and the profiler has confirmed it by counting characters rather than by parsing grammar.</p>
<p>The full-width digits (U+FF10 through U+FF19) tell a different story — they vary in frequency because they encode the variable date and time components. <code>１</code> (FULLWIDTH DIGIT ONE) appears 108 times, which is more than the 80 records, because it occurs in both day numbers and hour numbers. <code>０</code> (FULLWIDTH DIGIT ZERO) appears exactly 80 times, suggesting it appears once per record — likely as padding in minutes or hours like <code>０３</code>. The digit distribution is not uniform; it reflects the actual times when earthquakes occurred during the sample period. <code>７</code> and <code>８</code> appear only 20 times each, while <code>９</code> appears 26 times, because the day-of-month and hour-of-day distributions in the sample period happen to favour certain digits over others.</p>
<p>The critical discovery, and the one with the most practical consequence, is that these are FULLWIDTH digits (U+FF10 through U+FF19), not ASCII digits (U+0030 through U+0039). Full-width characters occupy the same visual width as CJK ideographs, maintaining consistent column alignment in Japanese text — this is a deliberate formatting choice that is entirely standard in Japanese data systems. But it means that any downstream process expecting ASCII digits will fail silently. A <code>parseInt()</code> call will not parse them. A regex like <code>\d+</code> will not match them in most programming languages. A simple numeric comparison will return false. The character profiler surfaces this encoding choice immediately and unambiguously; a schema that defines the field as "string" would tell you nothing, and even the mask-based profiler, which correctly classified them as digits, did not distinguish between full-width and ASCII variants. This is the level of detail that character profiling provides: not just "there are digits here" but "there are <em>these specific digits</em>, in <em>this specific encoding</em>, and here is why that matters."</p>
<p>This is the kind of finding that justifies character-level profiling for any dataset containing non-Latin scripts. The mask-based profiler told us there was one structural pattern (<code>9a9a9a_a_</code>), and that finding was genuinely useful — it confirmed that all 80 headlines follow the same template. The character profiler tells us WHY that pattern exists and reveals that what looks like "digits" in the mask output are actually full-width Unicode variants that require specific handling in any extraction or transformation pipeline.</p>
<p>It is worth noting that the same character profiling technique, applied to the full station name data, separates the three Japanese writing systems cleanly. Hiragana characters (the phonetic syllabary used for grammatical particles and native Japanese words) cluster together, Katakana characters (the phonetic syllabary used for foreign loanwords and, in geographic data, for place name suffixes like ケ in 六ヶ所) appear as a distinct group, and CJK ideographs (kanji) dominate the frequency table. The most frequent kanji are <code>市</code> (city, 1,397 occurrences), <code>町</code> (town, 1,203), and <code>区</code> (ward, 396) — the administrative unit suffixes that appear in every station's municipality name. The character profiler has effectively performed a frequency analysis of Japanese place-name components, revealing the structural vocabulary of the geographic naming system without any external reference data. Where the mask told us "these are all alphabetic strings," the character profile tells us "these alphabetic strings are composed primarily of city, town, and ward designators, written in kanji, with occasional katakana suffixes" — a far richer understanding of the data.</p>
<h2 id="summary-of-findings-1"><a class="header" href="#summary-of-findings-1">Summary of Findings</a></h2>
<p>Issues and observations discovered through mask-based profiling of 80 JMA earthquake events (2,433 station observations):</p>
<p><strong>Coordinate encoding:</strong></p>
<ul>
<li>Two structural variants: negative depth (72 records) vs positive/zero depth (7 records) → <strong>Investigate:</strong> are zero-depth events genuinely surface-level, or is zero a default value?</li>
</ul>
<p><strong>Station names (Japanese):</strong></p>
<ul>
<li>＊ (full-width asterisk) suffix on 82.3% of stations marks unofficial observation points → <strong>Document:</strong> this is a semantic encoding convention, not an error</li>
<li>18 stations contain digits in their names → <strong>Accept:</strong> legitimate naming convention for numbered observation points</li>
</ul>
<p><strong>Station names (English):</strong></p>
<ul>
<li>Asterisk marker uses ASCII <code>*</code> (U+002A) while Japanese names use ＊ (U+FF0A) → <strong>Flag:</strong> encoding inconsistency between language variants</li>
<li>Lowercase prefixed components (<code>c-Kamagaya</code>, <code>c-Sanbu</code>) in some station names → <strong>Investigate:</strong> what does the <code>c-</code> prefix signify?</li>
<li>20+ distinct masks for station names → <strong>Accept:</strong> structural diversity driven by legitimate variation in Japanese geographic naming conventions</li>
</ul>
<p><strong>Hypocenter names (English):</strong></p>
<ul>
<li>One compound name using middle dot separator (<code>Eastern Region · Off the Coast of Hokkaido</code>) → <strong>Flag:</strong> unique formatting, may cause parsing issues if the middle dot is used as a delimiter elsewhere</li>
</ul>
<p><strong>CJK text fields:</strong></p>
<ul>
<li>All Japanese text fields collapse to <code>a</code> at low grain → <strong>Expected:</strong> this is correct LU behaviour for CJK text, not a limitation. Use HU grain if length differentiation is needed.</li>
</ul>
<p><strong>Headline text:</strong></p>
<ul>
<li>Full-width numerals (２１ instead of 21) correctly identified as digits by Unicode-aware masking → <strong>Validated:</strong> the profiler handles mixed-script text correctly</li>
</ul>
<p><strong>Structural consistency:</strong></p>
<ul>
<li>Magnitude, maximum intensity, station intensity, station latitude, and station longitude are all perfectly consistent — single masks with zero exceptions across their respective populations → <strong>No action required</strong></li>
</ul>
<h2 id="lessons-learned-1"><a class="header" href="#lessons-learned-1">Lessons Learned</a></h2>
<p><strong>1. CJK characters and mask granularity.</strong> At LU grain, all Japanese text — whether it is a two-character prefecture suffix or a twelve-character station name — collapses to a single <code>a</code>. This is not a limitation; it is the correct behaviour for a structural discovery tool. The question at low grain is "what kind of data is this?" and the answer for Japanese text is consistently "alphabetic." If you need to distinguish between short and long Japanese strings, switch to HU grain, which preserves character counts. But for finding structural anomalies — the ＊ suffix, the embedded digits, the punctuation separators — LU grain is exactly right, because those characters break the alphabetic run and create visible mask segments.</p>
<p><strong>2. Nested data works with the same techniques.</strong> Six levels of JSON nesting, arrays within arrays within arrays, one-to-many fan-outs at every level — and the profiler does not care. Once flattened to key-value pairs, every leaf value is just a string to be masked. The flat enhanced format described in Chapter 9 was designed for exactly this kind of data: variable-width records where different rows have different numbers of fields. The 6,551 unique key paths from 80 records would be a nightmare in a traditional columnar profiler that expects a fixed schema. In the flat format, they are just 6,551 key-value pairs, each profiled independently.</p>
<p><strong>3. Bilingual data reveals encoding conventions.</strong> The same semantic marker — "this is an unofficial station" — is encoded as ＊ (U+FF0A, full-width asterisk) in Japanese text and * (U+002A, standard ASCII asterisk) in English text. The profiler surfaces this automatically because the two characters belong to different Unicode blocks and produce different mask behaviours. A human reviewer looking at the English data alone might never notice the asterisk convention; looking at both languages through the profiler, the convention is unmistakable and the encoding inconsistency is immediately apparent.</p>
<p><strong>4. Structural conventions that are invisible to schemas are visible to masks.</strong> The ＊ suffix on station names is not described in any JSON schema. It is not a separate field. It is not flagged by a key name or an attribute. It is a character appended to the end of a string value, carrying semantic meaning through convention alone. A schema validator would pass it without comment. A mask profiler flags it instantly — because it changes the structural pattern of the value from <code>a</code> to <code>a_</code>. This is precisely the kind of embedded, undocumented encoding convention that DQOR techniques are designed to detect.</p>
<p><strong>5. The ragged row problem is real, and the flat enhanced format handles it.</strong> Eighty earthquake records produce 6,551 unique key paths because the array depths vary from record to record. In a traditional tabular format, you would have to either (a) create columns for the maximum possible number of stations, prefectures, areas, and cities — most of which would be empty in most records — or (b) normalise the data into multiple related tables before profiling. The flat enhanced format avoids both of these: each record is a bag of key-value pairs with no requirement for structural uniformity across records. This is not a theoretical advantage; with real nested data, it is the difference between profiling the data as-is and spending days on schema design before profiling can begin.</p>
<p><strong>6. Wildcard profiling across nested paths.</strong> When the same field name appears at multiple levels of a nested structure — or across multiple datasets — we can profile them collectively using a wildcard pattern. A query like <code>*.Name</code> would gather every <code>Name</code> field regardless of its position in the hierarchy: <code>Body.Earthquake.Hypocenter.Area.Name</code>, <code>Body.Intensity.Observation.Pref.Name</code>, <code>Body.Intensity.Observation.Pref.Area.City.Name</code>, and so on. This allows us to compare the same semantic field across different nesting contexts. In the Companies House example, <code>RegAddress.PostCode</code> is a single column. But if postcodes appeared in multiple nested structures — billing address, shipping address, registered office — we could profile <code>*.PostCode</code> to see all postcodes regardless of context, or drill into individual paths when the aggregate profile reveals anomalies. This wildcard approach works across files, fields, and datasets, making it a powerful tool for cross-cutting analysis.</p>
<p><strong>7. One profiling technique, any data source.</strong> The Companies House example in the preceding appendix profiles pipe-delimited CSV from a UK government register. This example profiles nested JSON from a Japanese government API. The data could not be more different in structure, language, encoding, or domain. The profiling technique is identical. Flatten, mask, count, sort, interpret. The masks change, the character classes change, the domain knowledge required for interpretation changes — but the method does not. That universality is the core claim of this book, and these two worked examples are the evidence.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="worked-example-profiling-the-french-lobbyist-registry-hatvp" class="unnumbered"><a class="header" href="#worked-example-profiling-the-french-lobbyist-registry-hatvp">Worked Example: Profiling the French Lobbyist Registry (HATVP)</a></h1>
<p>This appendix profiles a real French government transparency dataset — the lobbyist registry maintained by the Haute Autorité pour la transparence de la vie publique (HATVP). Where the Companies House example demonstrated mask-based profiling on tabular CSV data and the JMA earthquake example tackled nested JSON with mixed scripts, this dataset brings a different set of challenges: deeply nested JSON with French-language text, accented characters, text-encoded numeric ranges masquerading as quantitative fields, and casing inconsistencies rooted in French administrative conventions. The result is a worked example that shows how bytefreq profiling surfaces issues that neither schemas nor simple validation rules would catch.</p>
<h2 id="the-dataset-2"><a class="header" href="#the-dataset-2">The Dataset</a></h2>
<p>The HATVP publishes a consolidated JSON file of all organisations registered in the French lobbyist registry, updated nightly and freely available under the Licence Ouverte (Etalab) — France's standard open data licence. The file is available at <a href="https://www.hatvp.fr/agora/opendata/agora_repertoire_opendata.json">hatvp.fr/agora/opendata/agora_repertoire_opendata.json</a> and weighs in at approximately 116MB.</p>
<p>Each record represents a registered lobbying organisation and contains its denomination, address, national identifier, directors, collaborators, clients, sector classifications, multi-year exercise declarations with nested activity reports, expenditure bands, revenue bands, and contact information. The nesting is substantial: a single organisation record can contain arrays of directors (each with name, title, and role), arrays of collaborators, arrays of clients, and multiple annual exercise declarations each containing their own nested activity structures.</p>
<p>For this example we sampled 405 records from the full file. After flattening the nested JSON (collapsing array indices so that <code>dirigeants[0].nom</code> and <code>dirigeants[1].nom</code> both become <code>dirigeants.nom</code>), these 405 records produced 81 unique field paths — a reflection of the structural depth of the data. Key paths and their value counts illustrate the one-to-many relationships: <code>denomination</code> yields 405 values (one per organisation), <code>dirigeants.nom</code> yields 760 (multiple directors per organisation), <code>collaborateurs.nom</code> yields 946, <code>clients.denomination</code> yields 1,130, and <code>activites.listSecteursActivites.label</code> yields 2,119 sector tags spread across the sample.</p>
<h2 id="running-the-profile-1"><a class="header" href="#running-the-profile-1">Running the Profile</a></h2>
<p>Because this is nested JSON rather than flat tabular data, we use the same flatten-then-profile approach described in the JMA earthquake example. The JSON is first flattened into field-path/value pairs, collapsing array indices, and then profiled using bytefreq in LU (Low-grain Unicode) mode. The flattening preserves the hierarchical field names — <code>exercices.publicationCourante.montantDepense</code> rather than a generic column number — which makes the profile output immediately readable without needing to cross-reference a schema.</p>
<p>The LU grain is the right starting point here. It collapses consecutive characters of the same class (uppercase, lowercase, digit, punctuation) into single representative characters, giving us a compact set of structural masks for each field. Where we need finer discrimination — as we will see with the <code>dirigeants.civilite</code> field — we can drill into HU (High-grain Unicode) mode for specific fields.</p>
<h2 id="structure-discovery-field-population-analysis-1"><a class="header" href="#structure-discovery-field-population-analysis-1">Structure Discovery: Field Population Analysis</a></h2>
<p>Before examining individual field values, we profile the field paths themselves. For each dot-notation path (with array indices collapsed), we count how many of the 405 lobbyist records contain that path and express it as a percentage. This is the structural discovery step — it tells us the shape of the data before we look at what is in it.</p>
<pre><code>Field Path                                                            Count  % Populated
-----------------------------------------------------------------------------------------
denomination                                                            405     100.0%
typeIdentifiantNational                                                 405     100.0%
identifiantNational                                                     405     100.0%
codePostal                                                              405     100.0%
ville                                                                   405     100.0%
pays                                                                    405     100.0%
dateCreation                                                            405     100.0%
datePremierePublication                                                 405     100.0%
categorieOrganisation.code                                              405     100.0%
categorieOrganisation.label                                             405     100.0%
categorieOrganisation.categorie                                         405     100.0%
activites.listSecteursActivites.code                                    405     100.0%
activites.listSecteursActivites.label                                   405     100.0%
activites.listNiveauIntervention.code                                   405     100.0%
dirigeants.nom                                                          366      90.4%
dirigeants.prenom                                                       366      90.4%
dirigeants.civilite                                                     366      90.4%
dirigeants.fonction                                                     366      90.4%
collaborateurs.nom                                                      366      90.4%
collaborateurs.civilite                                                 366      90.4%
collaborateurs.fonction                                                 271      66.9%
exercices.publicationCourante.dateDebut                                 403      99.5%
exercices.publicationCourante.dateFin                                   403      99.5%
exercices.publicationCourante.nombreSalaries                            315      77.8%
exercices.publicationCourante.montantDepense                            315      77.8%
exercices.publicationCourante.chiffreAffaire                            163      40.2%
lienSiteWeb                                                             304      75.1%
adresse                                                                 306      75.6%
lienPageLinkedin                                                        196      48.4%
emailDeContact                                                          169      41.7%
lienPageTwitter                                                         140      34.6%
telephoneDeContact                                                      132      32.6%
lienPageFacebook                                                        116      28.6%
clients.denomination                                                     88      21.7%
nomUsage                                                                205      50.6%
dateDernierePublicationActivite                                         301      74.3%
lienListeTiers                                                           21       5.2%
nomUsageHatvp                                                            44      10.9%
sigleHatvp                                                               51      12.6%
dateCessation                                                            39       9.6%
motifDesinscription                                                      39       9.6%
ancienNomHatvp                                                            2       0.5%
exercices.publicationCourante.activites...actionsRepresentationInteret.observation   151  37.3%
</code></pre>
<p>The registration core — name, identifier, postal code, city, country, dates, category, sectors — is 100% populated across all 405 records. These are mandatory registration fields, the skeleton that every lobbyist record shares. When we see a block of fields all at 100%, it confirms that the registration system enforces these as required inputs, and it gives us a stable foundation to work from when we start profiling values.</p>
<p>Director and collaborator names are 90.4% populated — but <code>collaborateurs.fonction</code> drops to 66.9%. A third of collaborators have no declared role. This is a data completeness issue hiding inside the nesting: the person exists in the array, but their function field is missing. A flat schema would show this as a null column. In nested JSON, the key simply is not present in some array elements. The profiler treats both the same way, which is why the flatten-then-profile approach works so well for this kind of discovery.</p>
<p>Financial data tells a story of progressive disclosure. <code>exercices.publicationCourante.dateDebut</code> is 99.5% (nearly universal), but <code>nombreSalaries</code> and <code>montantDepense</code> drop to 77.8%, and <code>chiffreAffaire</code> (revenue) falls to just 40.2%. Organisations are required to declare exercise periods but increasingly opt out of financial detail. Revenue is the most sensitive field, and fewer than half disclose it. The field population percentages quantify this reluctance in a way that no amount of manual inspection could — you see the gradient from near-universal to minority compliance in a single column of numbers.</p>
<p>Contact and social media fields follow a clear hierarchy: website (75.1%) &gt; LinkedIn (48.4%) &gt; email (41.7%) &gt; Twitter (34.6%) &gt; phone (32.6%) &gt; Facebook (28.6%). This is not random — it reflects institutional communication preferences. Websites are near-universal for organisations, LinkedIn is the professional default, and Facebook has fallen out of favour for institutional lobbying. The field population percentages tell you this without reading a single value.</p>
<p>At the bottom of the table, operational fields appear: <code>dateCessation</code> and <code>motifDesinscription</code> (9.6%) mark organisations that have de-registered from the lobbying register, <code>ancienNomHatvp</code> (0.5%) records name changes — just 2 out of 405. These sparse fields are invisible in a casual inspection of the data but the population analysis surfaces them immediately. They are the kind of fields that cause edge-case bugs in downstream processing because developers never encounter them during testing.</p>
<h2 id="field-by-field-analysis-2"><a class="header" href="#field-by-field-analysis-2">Field-by-Field Analysis</a></h2>
<h3 id="organisation-name-denomination"><a class="header" href="#organisation-name-denomination">Organisation Name (denomination)</a></h3>
<p><code>denomination</code></p>
<pre><code>Mask              Count   Example
A A                  65   OTRE GIRONDE
A                    62   DOMISERVE
A A A                55   REUSABLE PACKAGING EUROPE
A A A A              31   BNP PARIBAS PERSONAL FINANCE
A A A A A A          24   OTRE DES PAYS DE LA LOIRE
A A A A A            23   UNION DES ENTREPRISES CORSES
A A A A A A A        12   NESTLE EXCELLENCE SAS PRODUITS PETI
A_A A                 3   MCDONALD'S FRANCE
A _                   2   TUKAZZA !
A 9                   2   FNSEA 17
</code></pre>
<p>The dominant masks are exactly what we would expect for organisation names in uppercase: one to seven words separated by spaces, all collapsing to <code>A</code> tokens. The interesting patterns are at the bottom. <code>A_A A</code> (3 records, e.g. <code>MCDONALD'S FRANCE</code>) — the apostrophe is a punctuation character, creating a distinct structural mask. <code>A _</code> (2 records, e.g. <code>TUKAZZA !</code>) — an exclamation mark, which bytefreq maps to the punctuation class. And <code>A 9</code> (2 records, e.g. <code>FNSEA 17</code>) — a numeric suffix, likely a regional chapter number.</p>
<p>None of these are errors per se — they are legitimate organisation names. But the masks tell us immediately that any downstream process relying on "organisation names are alphabetic words separated by spaces" will need to account for apostrophes, punctuation marks, and trailing numbers. The mask frequency table is the specification that the data never came with.</p>
<h3 id="address-adresse"><a class="header" href="#address-adresse">Address (adresse)</a></h3>
<p><code>adresse</code></p>
<pre><code>Mask              Count   Example
9 A A A              76   169 RUE D'ANJOU
9 A A                50   60 BOULEVARD VOLTAIRE
A A                  30   ZONE INDUSTRIELLE
A                    29   AMYNOS
A A A                27   ASSOCIATION DES CONSOMMATEURS
9 A A A A            21   49 RUE EVARISTE GALOIS
9 A                  17   75 BDVOLTAIRE
A A A A              17   CITE DE L INDUSTRIE
A 9                  13   CS 70044
9 a Aa                7   79 rue Perrier
9 a Aa Aa             6   2 avenue Tony Garnier
A 9 A A A             2   BP 123 CHERBOURG EN COTENTIN
</code></pre>
<p>306 of 405 records have an address; 99 are empty (a 24.4% null rate). The dominant patterns start with a street number followed by uppercase street names (<code>9 A A A</code>: <code>169 RUE D'ANJOU</code>), which is the standard French address format. But several things stand out.</p>
<p>First, mixed casing. The majority of addresses are in uppercase (<code>169 RUE D'ANJOU</code>, <code>60 BOULEVARD VOLTAIRE</code>), which is the traditional French postal convention for addresses. But 13 records use title case or mixed case (<code>79 rue Perrier</code>, <code>2 avenue Tony Garnier</code>). The masks <code>9 a Aa</code> and <code>9 a Aa Aa</code> are structurally different from <code>9 A A</code> precisely because of this casing inconsistency — the profiler is separating records that a human might gloss over as "same thing, different capitalisation."</p>
<p>Second, non-address content. The masks <code>A</code> (29 records, e.g. <code>AMYNOS</code>) and <code>A A A</code> (27 records, e.g. <code>ASSOCIATION DES CONSOMMATEURS</code>) contain organisation names rather than street addresses. The address field is being used to store building names or organisation references.</p>
<p>Third, postal box codes. <code>A 9</code> (13 records, e.g. <code>CS 70044</code>) represents CEDEX sorting codes — a French postal routing system. <code>A 9 A A A</code> (2 records, e.g. <code>BP 123 CHERBOURG EN COTENTIN</code>) combines a boîte postale (PO box) number with a city name, packing two logical fields into one.</p>
<h3 id="postal-code-codepostal"><a class="header" href="#postal-code-codepostal">Postal Code (codePostal)</a></h3>
<p><code>codePostal</code></p>
<pre><code>Mask        Count   Example
9             401   75019
 9              2   1000
A9A9A           1   EC1R4QB
</code></pre>
<p>Three masks, and each tells a different story. The dominant <code>9</code> (401 records, 99.0%) represents standard five-digit French postal codes like <code>75019</code>. Clean, consistent, no issues.</p>
<p>The <code> 9</code> mask (2 records, e.g. <code>1000</code>) has a leading space — note the space before the <code>9</code> in the mask. These are four-digit codes with space padding, likely Belgian postcodes (Belgium uses four-digit postal codes). Two Belgian organisations registered in the French lobbyist registry, and the source system padded their codes with a leading space rather than handling the shorter format.</p>
<p>And then there is <code>A9A9A</code> (1 record: <code>EC1R4QB</code>). That is a UK postcode — an alphanumeric format that is structurally unmistakable in a field of French five-digit codes. A British organisation registered in the French lobbyist registry, and the postal code field accepted whatever was submitted. The mask catches it instantly because the structural pattern is completely unlike the surrounding data.</p>
<h3 id="city-ville"><a class="header" href="#city-ville">City (ville)</a></h3>
<p><code>ville</code></p>
<pre><code>Mask              Count   Example
A                   211   BEAUNE
A 9                  52   PARIS 16
A A                  29   NANTERRE CEDEX
A-A                  24   LAMBALLE-ARMOR
Aa                   21   Paris
A-A-A                15   (various hyphenated)
A A A                10   LE BOURGET CEDEX
A A 9                10   PARIS CEDEX 07
Aa-a-Aa               3   Neuilly-sur-Seine
Aa a Aa               2   Neuilly sur Seine
A 9A                   2   LYON 3EME
a                      1   avignon
A - A A               1   COURBEVOIE - LA DEFENSE
A A_ A                1   VILLEBON S/ YVETTE
A A Aa 9              1   LE MANS Cedex 2
</code></pre>
<p>This field is a catalogue of French address conventions and casing inconsistency, all visible through the masks.</p>
<p>Casing: <code>A</code> (211 records, <code>BEAUNE</code>) is uppercase. <code>Aa</code> (21 records, <code>Paris</code>) is title case. <code>a</code> (1 record, <code>avignon</code>) is entirely lowercase. Three different casing conventions for the same type of data, in the same field, in the same dataset.</p>
<p>CEDEX variations: <code>A A</code> (29 records, <code>NANTERRE CEDEX</code>), <code>A A A</code> (10 records, <code>LE BOURGET CEDEX</code>), <code>A A 9</code> (10 records, <code>PARIS CEDEX 07</code>), <code>A A Aa 9</code> (1 record, <code>LE MANS Cedex 2</code>). The postal routing suffix CEDEX appears in uppercase (<code>CEDEX</code>) and in title case (<code>Cedex</code>) — and the numeric arrondissement that follows it is sometimes present, sometimes not.</p>
<p>Hyphenation: <code>A-A</code> (24 records, <code>LAMBALLE-ARMOR</code>) and <code>A-A-A</code> (15 records) are hyphenated town names in uppercase. <code>Aa-a-Aa</code> (3 records, <code>Neuilly-sur-Seine</code>) is hyphenated in title case. <code>Aa a Aa</code> (2 records, <code>Neuilly sur Seine</code>) is the same town name without hyphens. The profiler reveals that <code>Neuilly-sur-Seine</code> and <code>Neuilly sur Seine</code> coexist in the data — same place, different punctuation, different masks.</p>
<p>And then the distinctly French conventions: <code>A A_ A</code> (1 record, <code>VILLEBON S/ YVETTE</code>) uses <code>S/</code> as an abbreviation for "sur" (on/upon), a convention specific to French administrative addressing. <code>A 9A</code> (2 records, <code>LYON 3EME</code>) uses the arrondissement suffix <code>3EME</code> (3rd) — the ordinal marker <code>EME</code> being the French equivalent of English "rd" or "th."</p>
<h3 id="country-pays"><a class="header" href="#country-pays">Country (pays)</a></h3>
<p><code>pays</code></p>
<pre><code>Mask        Count   Example
A             375   FRANCE
Aa             22   France
A-A             1   ROYAUME-UNI
a               1   france
</code></pre>
<p>Four masks, essentially two country values. <code>FRANCE</code> appears in three casing variants: uppercase (375), title case (22), and lowercase (1). The fourth mask, <code>A-A</code>, is <code>ROYAUME-UNI</code> — the French name for the United Kingdom, hyphenated as is standard in French. This is the same British organisation whose UK postcode we found in the <code>codePostal</code> field.</p>
<p>The real issue here is not the lone UK record — it is the casing inconsistency. 375 records say <code>FRANCE</code>, 22 say <code>France</code>, 1 says <code>france</code>. These are not three different countries. A downstream join or group-by on this field will produce three separate buckets for the same value unless casing is normalised first. The profiler makes this immediately obvious because each casing variant produces a different mask.</p>
<h3 id="organisation-category-categorieorganisationlabel"><a class="header" href="#organisation-category-categorieorganisationlabel">Organisation Category (categorieOrganisation.label)</a></h3>
<p><code>categorieOrganisation.label</code></p>
<pre><code>Mask                                                          Count   Example
Aa a a a _a a a a_a a a a a_                                    128   Société commerciale et civile (autre que cabinet d'avocats et société de conseil)
Aa                                                               89   Association
Aa a                                                             83   Fédération professionnelle
Aa a a a                                                         58   Organisation non gouvernementale
Aa a a                                                           40   Cabinet de conseil
Aa a a _a a_                                                      2   Groupe de recherche (think tank)
Aa a a a a a a a                                                  2   Établissement public ou organisme consultatif
</code></pre>
<p>French category labels with accented characters (<code>Société</code>, <code>Fédération</code>, <code>Établissement</code>), apostrophes (<code>d'avocats</code>), and parenthetical qualifiers (<code>(autre que cabinet d'avocats et société de conseil)</code>, <code>(think tank)</code>). This is a controlled vocabulary — seven distinct values with consistent formatting. The masks here are doing their job: confirming that the reference data is clean and internally consistent.</p>
<p>Note that LU mode treats accented characters (é, è, ê) the same as their unaccented counterparts — they are all lowercase letters, collapsing to <code>a</code>. This is the correct behaviour for structural profiling: we care about the shape of the data, not the specific diacritics.</p>
<h3 id="directors-title-dirigeantscivilite"><a class="header" href="#directors-title-dirigeantscivilite">Directors: Title (dirigeants.civilite)</a></h3>
<p><code>dirigeants.civilite</code></p>
<pre><code>Mask    Count   Example
A         760   M
</code></pre>
<p>A single mask: <code>A</code>. Every value collapses to uppercase alpha. But this field contains two distinct values — <code>M</code> (Monsieur) and <code>MME</code> (Madame) — which LU mode cannot distinguish because both are uppercase alphabetic strings. The mask <code>A</code> covers both a one-character and a three-character value.</p>
<p>This is a case where you would drill into HU (High-grain Unicode) mode, which preserves character count, to separate <code>M</code> from <code>MME</code> and get the gender distribution. At LU grain, the field looks perfectly uniform. At HU grain, the two populations would separate cleanly. It is a useful reminder that profiling grain is a choice, and the right grain depends on the question you are asking.</p>
<h3 id="directors-surname-dirigeantsnom"><a class="header" href="#directors-surname-dirigeantsnom">Directors: Surname (dirigeants.nom)</a></h3>
<p><code>dirigeants.nom</code></p>
<pre><code>Mask        Count   Example
A             684   DENIZOT
A A            43   LE LETTY
A-A            22   VESQUE-JEANCARD
A_A             4   N'GOADMY
A A A           3   DUBARRY DE LASSALLE
A A A A         2   VAN LIDTH DE JEUDE
A A_A           1   TEYSSIER D'ORFEUIL
</code></pre>
<p>French surname patterns, each structurally distinct and all legitimate. Single surnames (<code>A</code>, 684 records) dominate. Compound surnames with particles appear in several forms: space-separated (<code>A A</code>: <code>LE LETTY</code>, <code>A A A</code>: <code>DUBARRY DE LASSALLE</code>, <code>A A A A</code>: <code>VAN LIDTH DE JEUDE</code>), hyphenated (<code>A-A</code>: <code>VESQUE-JEANCARD</code>), and apostrophe-linked (<code>A_A</code>: <code>N'GOADMY</code>, <code>A A_A</code>: <code>TEYSSIER D'ORFEUIL</code>).</p>
<p>The apostrophe in French surnames (as in <code>D'ORFEUIL</code>, <code>N'GOADMY</code>) is structurally significant — it creates a different mask from a space-separated particle. Any normalisation logic that strips apostrophes or treats them as word boundaries will mangle these names. The mask frequency table is essentially a specification for a surname parser: here are the seven structural patterns you need to handle.</p>
<h3 id="directors-first-name-dirigeantsprenom"><a class="header" href="#directors-first-name-dirigeantsprenom">Directors: First Name (dirigeants.prenom)</a></h3>
<p><code>dirigeants.prenom</code></p>
<pre><code>Mask        Count   Example
Aa            697   Carole
Aa-Aa          50   Marc-Antoine
Aa Aa          11   Marie Christine
Aa_a            1   Ro!and
</code></pre>
<p>The first three masks are expected: simple first names in title case (<code>Aa</code>, 697 records), hyphenated compound first names (<code>Aa-Aa</code>, 50 records — a very common French pattern, as in <code>Marc-Antoine</code>, <code>Jean-Pierre</code>), and space-separated compound first names (<code>Aa Aa</code>, 11 records — <code>Marie Christine</code>, where the hyphen was omitted).</p>
<p>The fourth mask is the standout of the entire dataset. <code>Aa_a</code> (1 record: <code>Ro!and</code>). An exclamation mark where the letter <code>l</code> should be. The intended name is <code>Roland</code>, but a data entry error — likely a mis-hit on an adjacent key — has replaced the lowercase <code>l</code> with <code>!</code>. The mask catches it instantly because <code>!</code> is a punctuation character, not a letter, so the structural pattern <code>Aa_a</code> (letter-class, letter-class, punctuation-class, letter-class) is fundamentally different from the expected <code>Aa</code> (letter-class, letter-class). One character wrong, and the mask is completely different.</p>
<p>This single record is worth the entire profiling exercise as a demonstration. No schema would catch it — the field is a valid string. No length check would catch it — <code>Ro!and</code> is six characters, perfectly reasonable for a first name. No lookup table would catch it unless you had an exhaustive dictionary of every possible French first name. But the structural profile catches it immediately, because the shape of the data is wrong. That is the core proposition of mask-based profiling, illustrated in a single record.</p>
<h3 id="directors-role-dirigeantsfonction"><a class="header" href="#directors-role-dirigeantsfonction">Directors: Role (dirigeants.fonction)</a></h3>
<p><code>dirigeants.fonction</code></p>
<pre><code>Mask                        Count   Example
Aa                            278   Secrétaire
Aa Aa                          92   Directeur Général
Aa a                           74   Directeur général
A                              44   PRESIDENT
A A                            29   DIRECTEUR GENERAL
Aa a Aa                        20   Président du Conseil
Aa-Aa                          20   Vice-Président
Aa a a                         19   Directeur exécutif
Aa Aa Aa                       18   Directeur Général Adjoint
Aa-a                           10   Vice-président
a                               6   président
Aa-Aa Aa                        6   Vice-Président Exécutif
A-A                             4   CO-PRÉSIDENT
4a Aa-Aa                        4   2ème Vice-Président
</code></pre>
<p>Three casing conventions coexist in a single field. Title case with all words capitalised (<code>Directeur Général</code>, mask <code>Aa Aa</code>, 92 records). Title case with French grammatical casing where articles and prepositions are lowercase (<code>Directeur général</code>, mask <code>Aa a</code>, 74 records). And all-caps (<code>PRESIDENT</code>, mask <code>A</code>, 44 records; <code>DIRECTEUR GENERAL</code>, mask <code>A A</code>, 29 records).</p>
<p>The mask pair <code>Aa-Aa</code> (20 records, <code>Vice-Président</code>) versus <code>Aa-a</code> (10 records, <code>Vice-président</code>) is particularly revealing: the same role, with the only difference being whether the second element after the hyphen is capitalised. The profiler separates them because <code>Aa-Aa</code> and <code>Aa-a</code> are structurally different — and this tells us that different data entry operators or different source systems applied different capitalisation rules.</p>
<p>The <code>4a</code> mask (4 records, <code>2ème Vice-Président</code>) captures the French ordinal suffix <code>ème</code> (equivalent to English "nd" or "th"), preceded by a digit. And the <code>a</code> mask (6 records, <code>président</code>) reveals entries in all lowercase — no initial capital at all.</p>
<p>A treatment function for this field would need to normalise casing (choosing one convention), handle hyphenated roles, and decide what to do with ordinal prefixes. The mask frequency table tells you exactly what rules to write.</p>
<h3 id="email-emaildecontact"><a class="header" href="#email-emaildecontact">Email (emailDeContact)</a></h3>
<p><code>emailDeContact</code></p>
<pre><code>Mask              Count   Example
a_a.a                66   contact@cdcf.com
a.a_a.a              23   jean.dupont@example.fr
a_a-a.a              23   contact@france-industrie.org
a_a.a.a               8   info@cabinet.avocat.fr
a_a9.a                6   contact@euro4t.fr
a-9_a.a               1   udtr-12@otre.fr
</code></pre>
<p>169 of 405 records have an email address; 236 are empty (58.3% null rate). The masks show the structural variation in email formats. In bytefreq output, the <code>@</code> symbol maps to the punctuation class and then collapses with adjacent punctuation or appears as <code>_</code> depending on surrounding characters. The dominant pattern <code>a_a.a</code> (66 records) represents the simplest form: <code>local@domain.tld</code>.</p>
<p>Variations include dots in the local part (<code>a.a_a.a</code>: <code>jean.dupont@example.fr</code>), hyphens in the domain (<code>a_a-a.a</code>: <code>contact@france-industrie.org</code>), multi-level domains (<code>a_a.a.a</code>: <code>info@cabinet.avocat.fr</code>), numbers in the domain (<code>a_a9.a</code>: <code>contact@euro4t.fr</code>), and numbers with hyphens in the local part (<code>a-9_a.a</code>: <code>udtr-12@otre.fr</code>).</p>
<p>No structural errors here — the patterns all represent valid email formats. The 58.3% null rate is the main finding: more than half of registered lobbying organisations have not provided a contact email.</p>
<h3 id="expenditure-exercicespublicationcourantemontantdepense"><a class="header" href="#expenditure-exercicespublicationcourantemontantdepense">Expenditure (exercices.publicationCourante.montantDepense)</a></h3>
<p><code>exercices.publicationCourante.montantDepense</code></p>
<pre><code>Mask                                  Count   Example
_ _ 9 9 a a _ 9 9 a                    580   &gt;= 75 000 euros et &lt; 100 000 euros
_ 9 9 a                                455   &lt; 10 000 euros
_ _ 9 9 9 a a _ 9 9 9 a                  8   &gt;= 3 250 000 euros et &lt; 5 000 000 euros
_ _ 9 9 a a _ 9 9 9 a                    2   &gt;= 900 000 euros et &lt; 1 000 000 euros
_ _ 9 9 9 a                              1   &gt;= 10 000 000 euros
</code></pre>
<p>This is one of the most instructive fields in the entire dataset. The expenditure column does not contain numbers. It contains French-language text descriptions of expenditure bands: <code>&gt;= 75 000 euros et &lt; 100 000 euros</code> — "greater than or equal to 75,000 euros and less than 100,000 euros."</p>
<p>A schema will tell you this field is a string. A null check will tell you it is populated. A length check will tell you nothing useful. But the mask tells you immediately that this is not a numeric field — the presence of <code>a</code> (lowercase alpha) characters in the mask means there are words mixed in with the numbers. You cannot sum this column, you cannot compute averages, you cannot do arithmetic of any kind without first parsing the range text.</p>
<p>The formatting follows French conventions: spaces as thousand separators (<code>75 000</code>, not <code>75,000</code>), <code>euros</code> as the currency word (not a symbol), and <code>et</code> (French for "and") as the conjunction between the lower and upper bounds. The five masks represent five expenditure bands, from <code>&lt; 10 000 euros</code> to <code>&gt;= 10 000 000 euros</code>.</p>
<p>This pattern — encoding quantitative information as text ranges — is not uncommon in government datasets where the exact figure is considered sensitive but the band is public. The profiler reveals it immediately because the structural pattern of a text range is fundamentally different from the structural pattern of a number. A column of actual euro amounts would produce masks like <code>9</code> or <code>9.9</code> — not <code>_ _ 9 9 a a _ 9 9 a</code>.</p>
<h3 id="revenue-band-exercicespublicationcourantechiffreaffaire"><a class="header" href="#revenue-band-exercicespublicationcourantechiffreaffaire">Revenue Band (exercices.publicationCourante.chiffreAffaire)</a></h3>
<p><code>exercices.publicationCourante.chiffreAffaire</code></p>
<pre><code>Mask                          Count   Example
_ _ 9 9 9 a                    225   &gt;= 1 000 000 euros
_ 9 9 a                        101   &lt; 100 000 euros
_ _ 9 9 a a _ 9 9 a             65   &gt;= 100 000 euros et &lt; 500 000 euros
_ _ 9 9 a a _ 9 9 9 a           41   &gt;= 500 000 euros et &lt; 1 000 000 euros
</code></pre>
<p>The same text-range pattern as expenditure. Four revenue bands rather than five, with the top band open-ended (<code>&gt;= 1 000 000 euros</code>). The same French formatting conventions apply: space thousands, text currency, <code>et</code> conjunction.</p>
<p>The consistency between this field and <code>montantDepense</code> suggests a systematic encoding choice by the HATVP, not a one-off formatting quirk. Both financial fields use the same text-range approach, and both would need the same parsing treatment to extract usable numeric bounds.</p>
<h3 id="employee-count-exercicespublicationcourantenombresalaries"><a class="header" href="#employee-count-exercicespublicationcourantenombresalaries">Employee Count (exercices.publicationCourante.nombreSalaries)</a></h3>
<p><code>exercices.publicationCourante.nombreSalaries</code></p>
<pre><code>Mask    Count   Example
9.9     1,046   1.0
</code></pre>
<p>A single mask: <code>9.9</code>. Every value is a number with a decimal point and trailing zero — <code>1.0</code>, <code>25.0</code>, <code>350.0</code>. These are integers that have been serialised as floating-point numbers by the JSON encoder. The source system stores employee count as an integer, but somewhere in the serialisation pipeline the values were converted to floats, and the JSON output faithfully records <code>1.0</code> instead of <code>1</code>.</p>
<p>This is a common issue with JSON data produced by systems that use loosely-typed numeric handling (Python's <code>json.dumps</code> with certain configurations, for example, or Java serialisers that map <code>Number</code> objects to <code>double</code>). The profiler catches it because the <code>.0</code> suffix creates a structural pattern (<code>9.9</code>) that is different from what we would expect for integer counts (<code>9</code>).</p>
<p>The treatment is straightforward: parse as float, cast to integer, validate that the decimal portion is always <code>.0</code>. But you need to know the issue exists before you can treat it, and the mask tells you on the first profiling run.</p>
<h3 id="website-liensiteweb"><a class="header" href="#website-liensiteweb">Website (lienSiteWeb)</a></h3>
<p><code>lienSiteWeb</code></p>
<pre><code>Mask              Count   Example
a_a.a.a_             80   https://www.example.com/fr
a_a.a.a              51   https://www.example.com
a_a.a_               26   https://lfde.com/
a_a.a-a.a_           23   https://www.france-industrie.org/
a_a.a                12   https://lfde.com
a_a-a.a_             12   http://france-biotech.fr/
a_a9.a_               6   http://cci47.fr/
</code></pre>
<p>304 of 405 records have a website; 101 are empty. The masks capture several URL structure variations: with and without <code>www</code> prefix, with and without trailing slash, <code>http</code> versus <code>https</code>, hyphens in domain names, numbers in domain names, and path suffixes (e.g. <code>/fr</code> for French-language landing pages).</p>
<p>The <code>a_a-a.a_</code> mask (12 records) represents <code>http://</code> (without TLS) — these organisations have not migrated to HTTPS. Not a data quality issue per se, but the mask separates them cleanly, which could feed a notification to affected organisations.</p>
<h3 id="dates-exercicespublicationcourantedatedebut"><a class="header" href="#dates-exercicespublicationcourantedatedebut">Dates (exercices.publicationCourante.dateDebut)</a></h3>
<p><code>exercices.publicationCourante.dateDebut</code></p>
<pre><code>Mask    Count   Example
9-9-9   1,953   01-04-2025
</code></pre>
<p>1,953 of 1,954 values share the same mask: <code>9-9-9</code>, representing the DD-MM-YYYY format with dashes. One value is presumably empty or structurally different — a single anomaly in nearly two thousand records. This is a well-controlled field with consistent formatting. The dash separator (rather than slash or dot) is the dominant French date convention in administrative systems.</p>
<h3 id="national-identifier-identifiantnational"><a class="header" href="#national-identifier-identifiantnational">National Identifier (identifiantNational)</a></h3>
<p><code>identifiantNational</code></p>
<pre><code>Mask    Count   Example
9         371   834715807
A9         33   H810503325
</code></pre>
<p>Two masks, two distinct identifier systems. <code>9</code> (371 records) represents SIREN numbers — the nine-digit identifiers assigned to French commercial entities by INSEE (the national statistics office). <code>A9</code> (33 records) represents RNA numbers — identifiers from the Répertoire National des Associations, France's national register of non-profit associations. RNA numbers have a letter prefix (typically <code>W</code>) followed by digits.</p>
<p>The mask separates commercial entities from non-profits instantly, without needing a lookup table or any domain knowledge beyond what the structural pattern reveals. A single character at the start of the identifier encodes the entity type, and the profiler surfaces it automatically.</p>
<h2 id="summary-of-findings-2"><a class="header" href="#summary-of-findings-2">Summary of Findings</a></h2>
<p>Issues discovered through mask-based profiling of 405 HATVP lobbyist registry records:</p>
<p><strong>Text-encoded numeric ranges:</strong></p>
<ul>
<li><code>montantDepense</code> (expenditure) and <code>chiffreAffaire</code> (revenue) store French-language band descriptions, not numbers → <strong>Treatment:</strong> parse range text to extract numeric bounds</li>
<li>Euro formatting uses French conventions: space thousands (<code>75 000</code>), text currency (<code>euros</code>), French conjunction (<code>et</code>) → any parser must handle these</li>
</ul>
<p><strong>Data entry errors:</strong></p>
<ul>
<li><code>Ro!and</code> in <code>dirigeants.prenom</code> — exclamation mark substituted for lowercase <code>l</code> → <strong>Treatment:</strong> manual correction to <code>Roland</code></li>
</ul>
<p><strong>Casing inconsistency:</strong></p>
<ul>
<li><code>pays</code>: three casings of <code>FRANCE</code> / <code>France</code> / <code>france</code> → <strong>Treatment:</strong> normalise to single form</li>
<li><code>ville</code>: uppercase (<code>BEAUNE</code>), title case (<code>Paris</code>), lowercase (<code>avignon</code>) → <strong>Treatment:</strong> normalise casing</li>
<li><code>dirigeants.fonction</code>: title case (<code>Directeur Général</code>), French grammatical case (<code>Directeur général</code>), all-caps (<code>PRESIDENT</code>), lowercase (<code>président</code>) → <strong>Treatment:</strong> normalise casing</li>
<li><code>adresse</code>: mixed uppercase and title case (<code>RUE D'ANJOU</code> vs <code>rue Perrier</code>) → <strong>Treatment:</strong> normalise casing</li>
</ul>
<p><strong>Float serialisation of integers:</strong></p>
<ul>
<li><code>nombreSalaries</code>: all values have <code>.0</code> suffix (<code>1.0</code>, <code>25.0</code>) → <strong>Treatment:</strong> cast to integer after validation</li>
</ul>
<p><strong>Foreign data in domestic fields:</strong></p>
<ul>
<li><code>codePostal</code>: one UK postcode (<code>EC1R4QB</code>) and two likely Belgian codes with leading spaces → <strong>Flag:</strong> legitimate foreign registrations, but may need special handling</li>
<li><code>pays</code>: one <code>ROYAUME-UNI</code> (United Kingdom) record → <strong>Accept:</strong> legitimate</li>
</ul>
<p><strong>French address conventions:</strong></p>
<ul>
<li>CEDEX postal routing suffixes in multiple forms (<code>NANTERRE CEDEX</code>, <code>PARIS CEDEX 07</code>, <code>LE MANS Cedex 2</code>)</li>
<li><code>S/</code> abbreviation for "sur" (<code>VILLEBON S/ YVETTE</code>)</li>
<li>Hyphenated vs unhyphenated town names (<code>Neuilly-sur-Seine</code> vs <code>Neuilly sur Seine</code>)</li>
<li>Arrondissement suffixes (<code>PARIS 16</code>, <code>LYON 3EME</code>)</li>
</ul>
<p><strong>High null rates:</strong></p>
<ul>
<li><code>emailDeContact</code>: 58.3% empty</li>
<li><code>adresse</code>: 24.4% empty</li>
</ul>
<p><strong>Structural consistency (no issues):</strong></p>
<ul>
<li><code>dateDebut</code>: near-perfect DD-MM-YYYY consistency (1,953 of 1,954 values)</li>
<li><code>identifiantNational</code>: clean separation of SIREN (numeric) and RNA (alphanumeric) identifiers</li>
<li><code>categorieOrganisation.label</code>: consistent controlled vocabulary</li>
</ul>
<h2 id="lessons-learned-2"><a class="header" href="#lessons-learned-2">Lessons Learned</a></h2>
<p><strong>1. Text-encoded numeric ranges are invisible to schemas but obvious to masks.</strong> The expenditure and revenue fields store French-language band descriptions — <code>&gt;= 75 000 euros et &lt; 100 000 euros</code> — that look like strings to any schema validator and pass every null or length check. But the mask <code>_ _ 9 9 a a _ 9 9 a</code> immediately reveals the presence of alphabetic characters mixed with digits, signalling that this is not a straightforward numeric field. Any team ingesting this data and attempting arithmetic on these columns would discover the problem only at query time, possibly after building dashboards on meaningless aggregations. The profiler surfaces it in the first pass.</p>
<p><strong>2. One character substitution, caught by structural profiling.</strong> <code>Ro!and</code> — a single exclamation mark where an <code>l</code> should be — produces the mask <code>Aa_a</code>, which is structurally different from every other first name in the dataset (all of which match <code>Aa</code>, <code>Aa-Aa</code>, or <code>Aa Aa</code>). No schema, no length check, no regex for "valid name characters" would catch this unless you explicitly excluded exclamation marks from names — and who thinks to do that? The mask catches it because the structural signature of the error is different from the structural signature of correct data. This is the essence of mask-based profiling: you do not need to know what errors to look for. You look at the structure, and the errors announce themselves.</p>
<p><strong>3. Casing inconsistency is pervasive in French administrative data.</strong> The dataset contains uppercase (<code>FRANCE</code>, <code>BEAUNE</code>, <code>PRESIDENT</code>), title case (<code>France</code>, <code>Paris</code>, <code>Directeur Général</code>), French grammatical case (<code>Directeur général</code>, where only the first word is capitalised), and lowercase (<code>france</code>, <code>avignon</code>, <code>président</code>). These are not random — they reflect different data entry conventions, different source systems, and different interpretations of French typographic rules. The profiler separates them all because each casing pattern produces a different mask, turning an invisible consistency problem into a visible, countable one.</p>
<p><strong>4. Float serialisation of integers is a silent data type issue.</strong> The <code>nombreSalaries</code> field contains values like <code>1.0</code> and <code>25.0</code> — integers that were serialised as floating-point numbers somewhere in the data pipeline. The JSON format does not distinguish between integer and float types in a way that survives most serialisation round-trips, so this kind of silent type promotion is common. The mask <code>9.9</code> (with a decimal point) is different from <code>9</code> (without), and that difference is the signal. Left undetected, these values might cause type errors in strongly-typed systems or produce unexpected results in aggregation queries that treat <code>1.0</code> as a float rather than an integer.</p>
<p><strong>5. A UK postcode in a French dataset is not an error — it is a fact.</strong> <code>EC1R4QB</code> in the <code>codePostal</code> field is a legitimate British postal code belonging to a UK organisation registered in the French lobbyist registry. The mask <code>A9A9A</code> is unmistakable against a background of five-digit numeric French codes. The profiler does not tell you whether this is right or wrong — it tells you that it is structurally different, and gives you the example so you can decide. In this case the decision is clear: the data is correct, and the system needs to accommodate foreign postal code formats.</p>
<p><strong>6. French address conventions create legitimate structural diversity.</strong> CEDEX postal routing suffixes, the <code>S/</code> abbreviation for "sur", hyphenated commune names, arrondissement numbers, and space-separated thousands in currency amounts are all standard French conventions. They are not errors, but they create structural variation that any downstream consumer needs to understand. The mask frequency table is an inventory of these conventions — a specification extracted from the data itself, rather than imposed by a schema that someone wrote based on what they thought the data looked like.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="worked-example-profiling-pubmed-xml--international-biomedical-literature" class="unnumbered"><a class="header" href="#worked-example-profiling-pubmed-xml--international-biomedical-literature">Worked Example: Profiling PubMed XML — International Biomedical Literature</a></h1>
<p>This appendix is the third worked example in this book, and it introduces something new: XML. The previous examples profiled pipe-delimited CSV (Companies House) and nested JSON (JMA earthquakes). This one profiles PubMed article metadata — a 3.4 MB XML document containing 200 biomedical research articles with 1,696 international authors from six continents. The point is not just to show that bytefreq handles XML. It is to show that the same mask-based profiling technique applies regardless of serialisation format, and that XML — with its attributes, mixed content, and namespace-qualified elements — presents its own data quality challenges that profiling surfaces automatically.</p>
<p>PubMed is the US National Library of Medicine's database of biomedical literature. It contains over 36 million citations. The data is available as bulk XML downloads and through APIs, and it is used by researchers, pharmaceutical companies, systematic review teams, and health informatics systems worldwide. If you work with biomedical data, you will encounter PubMed XML. And if you ingest it without profiling it first, you will discover its quirks the hard way.</p>
<h2 id="the-dataset-3"><a class="header" href="#the-dataset-3">The Dataset</a></h2>
<p>The dataset is a PubMed XML export containing 200 recent articles, selected specifically for international author diversity. It contains authors with Chinese, Korean, Vietnamese, Indian, Arabic, Turkish, Finnish, Estonian, Slovenian, Polish, Spanish, Portuguese, French, Dutch, and Irish names — the full spectrum of Latin-script diacritics, multi-part surnames, and naming conventions that real-world biomedical data contains.</p>
<p>The XML follows the NLM PubMed DTD, a well-documented and mature schema that has been in use for decades. Each <code>&lt;PubmedArticle&gt;</code> element contains two main blocks: <code>&lt;MedlineCitation&gt;</code> (the bibliographic metadata — title, authors, journal, abstract, MeSH headings) and <code>&lt;PubmedData&gt;</code> (publication history, article identifiers, references). The author information is nested several levels deep: <code>PubmedArticleSet.PubmedArticle.MedlineCitation.Article.AuthorList.Author</code>, with child elements for <code>LastName</code>, <code>ForeName</code>, <code>Initials</code>, <code>Identifier</code> (ORCID), and <code>AffiliationInfo.Affiliation</code>.</p>
<h2 id="xml-as-a-first-class-format"><a class="header" href="#xml-as-a-first-class-format">XML as a First-Class Format</a></h2>
<p>This is the first XML example in the book, so it is worth pausing to explain how bytefreq handles XML natively.</p>
<p>Bytefreq uses SAX (Simple API for XML) streaming to parse XML documents. It does not load the entire document into memory — it reads the XML as a stream of events (element open, element close, text content, attribute), building dot-notation paths as it descends and ascending as elements close. This means it can profile multi-gigabyte XML files with constant memory usage, just as it streams JSON and tabular data.</p>
<p>The path convention for XML is straightforward:</p>
<ul>
<li><strong>Elements</strong> become dot-separated path segments: <code>PubmedArticleSet.PubmedArticle.MedlineCitation.PMID</code></li>
<li><strong>Attributes</strong> are prefixed with <code>@</code>: <code>MedlineCitation.@Status</code>, <code>ISSN.@IssnType</code></li>
<li><strong>Repeated elements</strong> (arrays in JSON terms) are handled by the same array-collapsing logic used for JSON — all <code>&lt;Author&gt;</code> elements at the same level contribute values to the same field path</li>
</ul>
<p>The result is identical in structure to what you get from flattened JSON: a set of dot-notation field paths, each with a population count and a distribution of mask patterns. The profiling commands are:</p>
<pre><code class="language-bash">cat pubmed-international.xml | bytefreq --format xml --grain HU
cat pubmed-international.xml | bytefreq --format xml --grain LU
</code></pre>
<p>The <code>--format xml</code> flag activates the SAX parser. Everything else — grain selection, mask generation, report output — works exactly as it does for JSON and tabular data. One profiling technique, any serialisation format.</p>
<h2 id="structure-discovery-what-does-pubmed-xml-contain"><a class="header" href="#structure-discovery-what-does-pubmed-xml-contain">Structure Discovery: What Does PubMed XML Contain?</a></h2>
<p>The profiler discovers 126 unique field paths across the 200 articles. This is the structural inventory — the complete set of elements and attributes that appear anywhere in the dataset. Here are the key paths with their value counts (total values across all 200 articles):</p>
<pre><code>Field Path                                                      Values
-----------------------------------------------------------------------
MedlineCitation.@Status                                            200
MedlineCitation.@Owner                                             200
MedlineCitation.PMID                                               200
MedlineCitation.PMID.@Version                                      200
MedlineCitation.Article.@PubModel                                  200
MedlineCitation.Article.Journal.ISSN                               200
MedlineCitation.Article.Journal.ISSN.@IssnType                     200
MedlineCitation.Article.Journal.JournalIssue.PubDate.Year          200
MedlineCitation.Article.Journal.JournalIssue.PubDate.Month         200
MedlineCitation.Article.Journal.JournalIssue.PubDate.Day           200
MedlineCitation.Article.Journal.Title                               200
MedlineCitation.Article.ArticleTitle                                200
MedlineCitation.Article.AuthorList.@CompleteYN                      200
MedlineCitation.Article.AuthorList.Author.@ValidYN               1,699
MedlineCitation.Article.AuthorList.Author.LastName               1,696
MedlineCitation.Article.AuthorList.Author.ForeName               1,695
MedlineCitation.Article.AuthorList.Author.Initials               1,695
MedlineCitation.Article.AuthorList.Author.Identifier               353
MedlineCitation.Article.AuthorList.Author.Identifier.@Source       353
MedlineCitation.Article.AuthorList.Author.AffiliationInfo.Affil  2,059
MedlineCitation.Article.AuthorList.Author.@EqualContrib             72
MedlineCitation.Article.AuthorList.Author.CollectiveName             3
MedlineCitation.Article.AuthorList.Author.Suffix                     1
MedlineCitation.Article.Abstract.AbstractText                      604
MedlineCitation.Article.Abstract.AbstractText.@Label               253
MedlineCitation.Article.Abstract.AbstractText.@NlmCategory         247
MedlineCitation.Article.ELocationID                                316
MedlineCitation.Article.GrantList.Grant.GrantID                    258
MedlineCitation.Article.GrantList.Grant.Agency                     258
MedlineCitation.KeywordList.Keyword                                793
MedlineCitation.MeshHeadingList.MeshHeading.DescriptorName         341
PubmedData.ArticleIdList.ArticleId                                 616
PubmedData.ReferenceList.Reference.Citation                      6,356
</code></pre>
<p>Several things jump out immediately.</p>
<p><strong>Author counts reveal the fan-out.</strong> There are 200 articles but 1,696 author last names, 1,695 forenames, and 1,695 sets of initials. The one-name discrepancy (1,696 vs 1,695) is explained by the <code>@ValidYN</code> attribute count of 1,699 — three <code>Author</code> elements have a <code>CollectiveName</code> instead of <code>LastName</code>/<code>ForeName</code> (consortium or group authorships like "IMAGEN Consortium" or "SIREN study group"), and there is one author with a last name but no forename. The profiler surfaces these structural variants automatically: you do not need to know the PubMed DTD to discover that author representation is not uniform.</p>
<p><strong>Affiliations are sparse.</strong> 2,059 affiliation values for 1,696 authors means some authors have multiple affiliations — but it also means some authors have none. In a hierarchical XML structure, the absence of an <code>&lt;AffiliationInfo&gt;</code> child element is invisible unless you count. If every author had exactly one affiliation, we would expect 1,696 values. The 2,059 count tells us that multi-affiliation authors are common (joint appointments, visiting positions), but it does not tell us how many authors have zero affiliations. That requires comparing the author count to the number of distinct authors with at least one affiliation — a second-order analysis that the population counts prompt us to investigate.</p>
<p><strong>ORCID coverage is low.</strong> Only 353 of 1,696 authors (20.8%) have an <code>Identifier</code> element. Every one of those identifiers has <code>@Source</code> = "ORCID". Four out of five authors in this dataset have no persistent identifier — a significant data quality gap for anyone trying to disambiguate authors or link publications to researchers.</p>
<p><strong>Abstracts are structured.</strong> The 604 <code>AbstractText</code> values for 200 articles mean most articles have structured abstracts with labelled sections (Background, Methods, Results, Conclusions). The 253 <code>@Label</code> attributes confirm this — roughly half the abstract sections carry explicit labels. The 247 <code>@NlmCategory</code> values are the NLM's normalised category assignments, slightly fewer than the labels because some labels do not map to standard categories.</p>
<p><strong>One Suffix in the entire dataset.</strong> Exactly one author has a <code>Suffix</code> element, containing "Jr". This is not a data quality issue — suffixes are genuinely rare in international biomedical authorship — but the profiler surfaces it because a field that appears once in 1,696 records is structurally noteworthy.</p>
<h2 id="field-by-field-analysis-3"><a class="header" href="#field-by-field-analysis-3">Field-by-Field Analysis</a></h2>
<h3 id="citation-status"><a class="header" href="#citation-status">Citation Status</a></h3>
<p><code>MedlineCitation.@Status</code></p>
<pre><code>Mask                        Count   Example
Aaaaaaaaa                     114   Publisher
AaaAaa-aaa-AAAAAAA             49   PubMed-not-MEDLINE
AAAAAAA                        35   MEDLINE
Aa-Aaaaaaa                      2   In-Process
</code></pre>
<p>Four structural variants in an attribute that acts as a processing status flag. The dominant value "Publisher" (57%) indicates records supplied by publishers but not yet indexed by NLM. "PubMed-not-MEDLINE" (24.5%) means the article is in PubMed but not indexed with MeSH headings. "MEDLINE" (17.5%) indicates full NLM processing. "In-Process" (1%) means NLM indexing is underway.</p>
<p>The masks reveal the naming convention immediately: these are not simple codes but human-readable compound strings with mixed case, hyphens, and an abbreviation block (<code>MEDLINE</code>, <code>AAAAAAA</code>). Any downstream system that branches on this attribute needs to handle all four variants — and the mask distribution tells you exactly how common each one is.</p>
<h3 id="issn"><a class="header" href="#issn">ISSN</a></h3>
<p><code>Article.Journal.ISSN</code></p>
<pre><code>Mask        Count   Example
9999-9999     180   1756-5391
9999-999A      20   1476-928X
</code></pre>
<p>The classic ISSN format: four digits, a hyphen, then either four digits or three digits and a check character. The <code>X</code> check digit (representing the value 10) appears in 10% of ISSNs. This is well-known to anyone who works with serials data, but for a newcomer encountering ISSN for the first time, the mask immediately reveals the structural variant without requiring any domain knowledge.</p>
<h3 id="publication-model"><a class="header" href="#publication-model">Publication Model</a></h3>
<p><code>Article.@PubModel</code></p>
<pre><code>Mask                           Count   Example
Aaaaa-Aaaaaaaaaa                 126   Print-Electronic
Aaaaaaaaaa-aAaaaaaaaaa            32   Electronic-eCollection
Aaaaaaaaaa                        23   Electronic
Aaaaa                             19   Print
</code></pre>
<p>Four publication models, and the masks capture the compound naming convention: "Print-Electronic" (63%) means the article appeared in both print and electronic form. Note <code>Electronic-eCollection</code> with its internal lowercase-uppercase transition (<code>eCollection</code>), which the mask correctly renders as <code>aAaaaaaaaaa</code>. The <code>eCollection</code> capitalisation convention — lowercase <code>e</code> prefix on a capitalised word — is a common pattern in publishing metadata.</p>
<h3 id="author-last-names--the-international-name-challenge"><a class="header" href="#author-last-names--the-international-name-challenge">Author Last Names — The International Name Challenge</a></h3>
<p><code>AuthorList.Author.LastName</code> — High-Unicode (HU) grain</p>
<pre><code>Mask                    Count   Example
Aaaaa                     267   Lewis
Aaaaaa                    237   Nadein
Aaaa                      196   Tian
Aaaaaaa                   193   Daniels
Aaaaaaaa                  171   Fambirai
Aaa                       145   Lin
Aaaaaaaaa                  95   Attygalle
Aa                         82   Wu
Aaaaaaaaaa                 49   Wawrzaszek
Aaaaaaaaaaa                37   Sprikkelman
Aaaaaaaaaaaa               11   Banaschewski
AaAaaaa                     7   McQuaid
Aaaaaaaaaaaaa               6   Charuthamrong
Aaaaaaa-Aaaaaaa             4   Pallqui-Camacho
Aaaaaa-Aaaaa                4   Storck-Tonon
Aaaaaa-Aaaaaaa              4   Coello-Peralta
A                           3   M
aa Aaaaaaaa                 3   de Oliveira
Aa Aaaaaaa                  3   Di Lucente
Aa-Aaaaaaa                  3   Al-Shalabi
AaAaaaaa                    3   McCallum
</code></pre>
<p>The top ten masks are simple single-word surnames of varying lengths — five to twelve characters — covering 1,383 of 1,696 authors (81.5%). These are structurally unambiguous: one capitalised word composed entirely of ASCII Latin letters. Names like "Tian" (Chinese), "Lin" (Chinese/Vietnamese), "Wu" (Chinese), and "Fambirai" (Zimbabwean) all share the same simple mask as "Lewis" (English) and "Daniels" (English). The mask does not distinguish language of origin — nor should it at this level. These names are structurally identical.</p>
<p>The remaining 18.5% is where it gets interesting:</p>
<p><strong>Celtic prefixes:</strong> <code>AaAaaaa</code> (7 values) captures the <code>Mc</code>/<code>Mac</code> pattern — <code>McQuaid</code>, <code>McCallum</code>, <code>McNair</code>. The internal capitalisation creates a distinctive mask that separates these from simple surnames.</p>
<p><strong>Hispanic double-barrelled names:</strong> Hyphenated masks like <code>Aaaaaaa-Aaaaaaa</code> (4 values, e.g. <code>Pallqui-Camacho</code>), <code>Aaaaaa-Aaaaaaa</code> (4 values, e.g. <code>Coello-Peralta</code>) represent the Latin American convention of paternal-maternal surname compounds. There are 61 hyphenated surnames in the LU view — roughly one in every 28 authors.</p>
<p><strong>Dutch/Portuguese particles:</strong> <code>aa Aaaaaaaa</code> (3 values, <code>de Oliveira</code>), <code>aaa Aaaaaaa</code> (6 values in LU, <code>van der Deure</code>, <code>van Breugel</code>). Lowercase particles before the capitalised family name create multi-word masks with a distinctive lowercase-uppercase boundary. The profiler treats the space-separated components as distinct segments, making particle names instantly distinguishable from single-word names.</p>
<p><strong>Arabic prefixes:</strong> <code>Aa-Aaaaaaa</code> (3 values, <code>Al-Shalabi</code>) and <code>Aa Aaaaa</code> (1 value, <code>Al Sharie</code>). The same Arabic prefix "Al" appears both hyphenated and space-separated — a genuine data quality finding. Are these variant representations of the same naming convention, or do they reflect different transliteration standards? The profiler does not answer that question, but it ensures the question gets asked.</p>
<p><strong>Single-letter surnames:</strong> <code>A</code> (3 values, <code>M</code>, <code>K</code>). Three authors have a single-letter last name. These are almost certainly data quality issues — truncated names, initials entered in the wrong field, or authors from naming traditions where a single name is conventional but PubMed's schema forces it into the LastName field. The mask <code>A</code> (one uppercase letter) flags them unmistakably.</p>
<p><strong>The leading-hyphen anomaly:</strong> In the LU view, one surname has the mask <code>-Aa</code> with the value <code>-Akotet</code>. A surname that begins with a hyphen is a data entry error — likely a compound name where the first component was accidentally deleted, leaving the hyphen orphaned. This is exactly the kind of micro-anomaly that mask profiling is designed to catch: one record in 1,696, structurally unique, and almost certainly wrong.</p>
<h3 id="xml-entity-references-in-names--a-format-specific-finding"><a class="header" href="#xml-entity-references-in-names--a-format-specific-finding">XML Entity References in Names — A Format-Specific Finding</a></h3>
<p>The most striking finding in the author name analysis is visible only because we are profiling XML rather than JSON or CSV. Look at these mask patterns from the HU grain:</p>
<pre><code>Mask                        Count   Example
A__aa9_aa                       3   V&amp;#xe4;hi
Aaaaa__aa9_a                    3   Bostr&amp;#xf6;m
A__aa9_aaaaa                    2   M&amp;#xe4;rtson
Aaaaaaa__aa9_aaa                2   Desrivi&amp;#xe8;res
Aa__aa9_a                       1   Pe&amp;#xf1;a
A__aa9_a__aa9_aaa               1   K&amp;#xe4;h&amp;#xf6;nen
__aa9_aaaa Aaaaaaa              1   &amp;#xc7;elik Demirci
</code></pre>
<p>The <code>__aa9_</code> segments are XML numeric character references — <code>&amp;#xe4;</code> is ä, <code>&amp;#xf6;</code> is ö, <code>&amp;#xf1;</code> is ñ, <code>&amp;#xe8;</code> is è, <code>&amp;#xc7;</code> is Ç. These are diacritical characters encoded as XML entities rather than as raw UTF-8 bytes. The bytefreq profiler is seeing the raw XML text, and since <code>&amp;</code>, <code>#</code>, <code>x</code>, and <code>;</code> are punctuation/alphanumeric characters in ASCII, each entity reference produces a distinctive mask segment.</p>
<p>This is a critical data quality finding for XML processing. The same name — say, "Kähönen" (Finnish) — will have a different mask depending on whether the diacritics are stored as raw UTF-8 characters (producing <code>Aaaaaaaa</code>) or as XML entity references (producing <code>A__aa9_a__aa9_aaa</code>). The mask profiler reveals which encoding convention the data uses, and whether it is consistent.</p>
<p>In this dataset, names with diacritics consistently use XML numeric character references rather than raw UTF-8. This is a legitimate encoding choice — the PubMed DTD has historically preferred entity references for characters outside the ASCII range — but it has consequences for downstream processing. Any system that consumes this XML must resolve entity references before performing string operations like sorting, searching, or display. The mask profiler warns you about this before you write a single line of parsing code.</p>
<p>The LU (Low-grain Unicode) view collapses the entity references into more readable patterns:</p>
<pre><code>Mask            Count   Example
Aa               1494   Gurgone
Aa-Aa              61   Dantur-Juri
Aa Aa              29   Diaz Montes
Aa_a9_a            19   Pe&amp;#xf1;uela
AaAa               15   McBride
A_a9_a             11   M&amp;#xe4;rtson
a Aa                8   von Mutius
a a Aa              6   van der Deure
Aa_a_a-Aa           4   Ram&amp;#xed;rez-Angulo
A                   3   K
A_Aa                3   O'Grady
-Aa                 1   -Akotet
</code></pre>
<p>At LU grain, the entity references collapse to shorter patterns (<code>_a9_a</code> instead of <code>__aa9_a</code>) but remain visually distinct from pure alphabetic content. The 19 names matching <code>Aa_a9_a</code> all contain a single entity-encoded diacritic — Spanish ñ, French è, Swedish ö, Hungarian á. The 11 matching <code>A_a9_a</code> have the entity at the start of the name.</p>
<h3 id="author-first-names"><a class="header" href="#author-first-names">Author First Names</a></h3>
<p><code>AuthorList.Author.ForeName</code> — LU grain</p>
<pre><code>Mask            Count   Example
Aa               1076   Stephen
Aa A              180   Cornelis P
A                 146   L
Aa Aa              79   Ji Woong
A A                66   J A
Aa-Aa              53   Kim-Anh
Aa Aa Aa           17   Marcello Mihailenko Chaves
Aa A A             13   Michael J W
A Aa                9   J Guy
A A A               7   R S A
Aa_a9_a             7   Dearbh&amp;#xe1;ile
</code></pre>
<p>The forename field reveals the full range of naming conventions:</p>
<p><strong>Full first names</strong> (<code>Aa</code>, 1,076 values, 63.5%): The dominant pattern — a single capitalised word. This covers given names from every language represented in the dataset: "Stephen" (English), "Yong" (Chinese), "Priya" (Indian), "Ahmed" (Arabic), "Olga" (Russian).</p>
<p><strong>First name plus middle initial</strong> (<code>Aa A</code>, 180 values, 10.6%): A common Western convention — "Cornelis P", "David A". The single uppercase letter after a space is clearly an initial.</p>
<p><strong>Initials only</strong> (<code>A</code>, 146 values, 8.6%): A single letter. These are authors whose first name has been reduced to an initial. This is a data quality concern: it makes author disambiguation effectively impossible. One hundred and forty-six authors — nearly one in twelve — are represented by a single letter rather than a full given name.</p>
<p><strong>Double initials</strong> (<code>A A</code>, 66 values, 3.9%): Two separate initials — "J A", "P M". These authors have neither first nor middle name recorded, only initials for both.</p>
<p><strong>Korean/Vietnamese two-part given names</strong> (<code>Aa Aa</code>, 79 values, 4.7%): "Ji Woong", "Kim Anh" — given names from cultures where the given name is conventionally two words. The space-separated pattern is structurally identical to a Western "first name + middle name" pair, which creates ambiguity: is "Ji Woong" a two-part given name, or is "Ji" the first name and "Woong" a middle name? The mask cannot tell you — but it shows you the scale of the ambiguity.</p>
<p><strong>Hyphenated given names</strong> (<code>Aa-Aa</code>, 53 values, 3.1%): "Kim-Anh" (Vietnamese), "Ann-Marie" (English/French). The hyphen preserves the two-part structure as a single token. Some Vietnamese names appear both hyphenated (Kim-Anh → <code>Aa-Aa</code>) and space-separated (Ji Woong → <code>Aa Aa</code>), revealing inconsistent handling of the same naming convention.</p>
<p><strong>Triple initials</strong> (<code>A A A</code>, 7 values): "R S A" — three separate initials. These authors are even more opaque than the double-initial cases.</p>
<p><strong>Irish/Gaelic names</strong> (<code>Aa_a9_a</code>, 7 values): "Dearbháile" — Irish given names with entity-encoded fadas (acute accents). The entity reference creates a distinctive mask segment, just as it did in the surname field.</p>
<h3 id="orcid-identifiers"><a class="header" href="#orcid-identifiers">ORCID Identifiers</a></h3>
<p><code>AuthorList.Author.Identifier</code> (where <code>@Source</code> = "ORCID")</p>
<pre><code>Mask        Count   Example
9-9-9-9       319   0000-0002-9384-6341
9-9-9-9A       34   0000-0001-9815-200X
</code></pre>
<p>ORCID identifiers follow the ISNI format: four groups of four digits separated by hyphens, with the last character optionally being <code>X</code> (a check digit representing 10, identical to the ISSN convention). The mask distribution is clean: 90.4% pure numeric, 9.6% with an X check digit. No structural anomalies, no formatting inconsistencies. This is what well-governed identifier data looks like under profiling.</p>
<h3 id="affiliation-identifiers--mixed-standards"><a class="header" href="#affiliation-identifiers--mixed-standards">Affiliation Identifiers — Mixed Standards</a></h3>
<p><code>AuthorList.Author.AffiliationInfo.Identifier</code></p>
<pre><code>Mask                Count   Example
a_a.a_9a9a9            89   https://ror.org/03tqb8s11
a_a.a_9a9              63   https://ror.org/041akq887
9                      23   2281
9 9 9 9                22   0000 0000 9009 5680
a.9.9                  18   grid.411237.2
a.9.a                   5   grid.4800.c
</code></pre>
<p>This is one of the richest data quality findings in the entire profile. Affiliation identifiers use at least three different identifier schemes, mixed together in a single field:</p>
<ul>
<li><strong>ROR URLs</strong> (152 values, 69%): Research Organization Registry identifiers as full URLs — <code>https://ror.org/03tqb8s11</code>. Two mask variants because the alphanumeric suffix varies in structure.</li>
<li><strong>ISNI numbers</strong> (22 values, 10%): International Standard Name Identifiers in space-separated four-digit groups — <code>0000 0000 9009 5680</code>.</li>
<li><strong>GRID identifiers</strong> (23 values, 10.5%): Global Research Identifier Database IDs — <code>grid.411237.2</code>, <code>grid.4800.c</code>.</li>
<li><strong>Bare numeric IDs</strong> (23 values, 10.5%): Plain numbers like <code>2281</code> with no prefix or structure — possibly Ringgold identifiers.</li>
</ul>
<p>Four different identifier schemes in a single XML element. The <code>@Source</code> attribute for these identifiers is consistently "ROR" (222 values), which is incorrect — only 152 of 222 identifiers are actually ROR URLs. The GRID, ISNI, and numeric identifiers are mislabelled. This is a data quality error that the mask profiler catches by revealing structural diversity that a single <code>@Source</code> value claims does not exist.</p>
<h3 id="affiliation-text"><a class="header" href="#affiliation-text">Affiliation Text</a></h3>
<p><code>AuthorList.Author.AffiliationInfo.Affiliation</code> — The affiliation field produces the most structurally diverse output in the entire dataset: over 1,200 distinct masks for 2,059 values. This is expected — affiliation strings are semi-structured free text combining institution names, department names, cities, countries, and postal codes in no consistent order. A few representative patterns from the LU grain:</p>
<pre><code>Mask                                                    Count   Example
Aa Aa Aa Aa, Aa, Aa.                                      26   Central Public Health Laboratories, Kampala, Uganda.
Aa a Aa, Aa a Aa, Aa, A.                                  14   School of Geography, University of Leeds, Leeds, UK.
Aa Aa, Aa, Aa.                                             11   Makerere University, Kampala, Uganda.
Aa a Aa Aa, Aa Aa a Aa, Aa, Aa, Aa.                        8   Centre for Pathogen Genomics, The University of Melbourne, ...
</code></pre>
<p>The structural diversity is the finding. Affiliations are not standardised — they are free text entered by authors or publishers with varying conventions for ordering, punctuation, and abbreviation. Some end with a full stop, some do not. Some include postal codes, some do not. Country names appear variously as "UK", "United Kingdom", "U.K.", "China", "P.R. China". The mask profiler confirms what anyone who has worked with bibliographic data already knows: affiliation strings are the messiest field in any publication database. But it also quantifies the mess — 1,200+ structural variants for 2,059 values means almost no two affiliations have the same structure.</p>
<h3 id="publication-date--optional-components"><a class="header" href="#publication-date--optional-components">Publication Date — Optional Components</a></h3>
<p>The profiler reveals that publication date components have different population levels:</p>
<pre><code>Field Path                              Values
PubDate.Year                              200   (100%)
PubDate.Month                             200   (100%)
PubDate.Day                               200   (100%)
PubDate.Season                              2   (1%)
</code></pre>
<p>Year and Month are always present. Day is present for all 200 articles in this sample. But Season appears in 2 articles — a PubMed convention for journals that publish quarterly rather than on specific dates. The masks confirm the expected formats:</p>
<pre><code>PubDate.Year:   9999  (200 values, e.g. "2026")
PubDate.Month:  Aaa   (200 values, e.g. "Feb")
PubDate.Day:    99    (200 values, e.g. "22")
PubDate.Season: Aa-Aa   (2 values, e.g. "Jan-Mar")
</code></pre>
<p>Month is a three-letter abbreviation, not a number. Day is a zero-padded two-digit number. Season is a hyphenated month range. Any date-parsing logic needs to handle all three conventions — and the presence of Season means you cannot simply concatenate Year + Month + Day for every record.</p>
<h3 id="abstract-structure-labels"><a class="header" href="#abstract-structure-labels">Abstract Structure Labels</a></h3>
<p><code>Abstract.AbstractText.@Label</code></p>
<pre><code>Mask            Count   Example
AAAAAAA            50   METHODS
AAAAAAAAAA         43   BACKGROUND
AAAA               34   AIMS
AAAAAAA            33   RESULTS
</code></pre>
<p>All-uppercase labels — a consistent convention. But the <code>@NlmCategory</code> attribute (247 values vs 253 labels) shows that 6 labels lack an NLM category mapping. These are likely non-standard section labels that do not fit NLM's controlled vocabulary.</p>
<h2 id="summary-of-findings-3"><a class="header" href="#summary-of-findings-3">Summary of Findings</a></h2>
<p>Issues and observations discovered through mask-based profiling of 200 PubMed articles (1,696 authors):</p>
<p><strong>Author name diversity:</strong></p>
<ul>
<li>45+ distinct mask patterns for last names — single-word ASCII names dominate (81.5%) but hyphenated (3.6%), multi-part (1.7%), and particle-prefixed names (1.1%) are significant minorities</li>
<li>3 single-letter surnames (<code>M</code>, <code>K</code>) → <strong>Investigate:</strong> likely data entry errors or mono-name authors forced into a two-field schema</li>
<li>1 leading-hyphen surname (<code>-Akotet</code>) → <strong>Flag:</strong> data entry error, missing first component of compound name</li>
<li>146 single-initial forenames (8.6%) → <strong>Flag:</strong> significant loss of identity information</li>
</ul>
<p><strong>XML entity encoding:</strong></p>
<ul>
<li>Diacritical characters consistently encoded as XML numeric character references (<code>&amp;#xe4;</code> rather than raw <code>ä</code>) → <strong>Document:</strong> downstream systems must resolve entities before string operations</li>
<li>Entity-encoded names produce distinctive mask patterns that cleanly separate them from ASCII-only names</li>
<li>Affects ~19 surnames and ~7 forenames in this sample — Finnish, Swedish, French, Spanish, Polish, Slovenian, Turkish, and Irish names</li>
</ul>
<p><strong>Identifier data quality:</strong></p>
<ul>
<li>ORCID coverage: 20.8% of authors (353 of 1,696) → <strong>Flag:</strong> low coverage limits author disambiguation</li>
<li>Affiliation identifiers: 4 different schemes (ROR, GRID, ISNI, numeric) mixed in a single field, all mislabelled as <code>@Source="ROR"</code> → <strong>Flag:</strong> metadata quality error</li>
<li>ORCID format: clean, two structural variants (numeric and X-check), no anomalies</li>
</ul>
<p><strong>Structural sparsity:</strong></p>
<ul>
<li>CollectiveName (3 records): group/consortium authorships that lack LastName/ForeName → <strong>Handle:</strong> different code path required</li>
<li>Suffix (1 record): "Jr" — rare but must be accommodated</li>
<li>EqualContrib (72 authors): annotation for equal contribution, present on ~4% of authors</li>
<li>PubDate.Season (2 records): quarterly publication dates in a different format from Month+Day</li>
</ul>
<p><strong>Affiliation strings:</strong></p>
<ul>
<li>1,200+ structural variants for 2,059 values → <strong>Accept:</strong> free-text field, not amenable to structural standardisation</li>
<li>Missing affiliations: some authors have zero affiliation elements → <strong>Investigate:</strong> count authors with no AffiliationInfo child</li>
</ul>
<h2 id="lessons-learned-3"><a class="header" href="#lessons-learned-3">Lessons Learned</a></h2>
<p><strong>1. XML is just another serialisation format.</strong> The SAX streaming parser flattens XML into dot-notation paths exactly as the JSON parser flattens nested objects. Attributes become <code>@</code>-prefixed fields. Repeated elements become multiple values at the same path. The profiling output is structurally identical to what you would get from the same data encoded in JSON. If you know how to read a bytefreq profile of JSON, you know how to read one of XML.</p>
<p><strong>2. Entity references are a format-specific data quality concern.</strong> JSON escapes non-ASCII characters with <code>\uXXXX</code> sequences. XML uses numeric character references (<code>&amp;#xNN;</code>) or named entities (<code>&amp;amp;</code>). In both cases, the profiler sees the encoded form, not the resolved character — and the mask reveals the encoding. This is a feature, not a limitation: you need to know whether your data contains raw UTF-8 or entity-encoded characters before you can process it correctly. The mask profiler tells you which you have, and whether the encoding is consistent.</p>
<p><strong>3. Population analysis across nested elements requires care.</strong> In flat tabular data, "field X has 180 values out of 200 rows" is unambiguous. In XML with repeated elements, "AuthorList.Author.Identifier has 353 values" must be interpreted against the total author count (1,696), not the article count (200). The profiler gives you value counts per path; you must bring the structural context — the knowledge that Author is a repeating element within each article — to calculate meaningful percentages.</p>
<p><strong>4. International names break simple assumptions.</strong> Any system that assumes a last name is a single ASCII word will fail on 18.5% of the authors in this dataset. Hyphenated names, particle prefixes (<code>de</code>, <code>van der</code>, <code>Al-</code>), Celtic prefixes (<code>Mc</code>, <code>Mac</code>), diacritical characters, and multi-word surnames are not edge cases — they are a structural feature of international biomedical authorship. The mask profiler quantifies their prevalence and classifies them by structural type, providing the specification for a name-handling system that actually works.</p>
<p><strong>5. Mixed identifier schemes in a single field are discoverable through masks.</strong> The affiliation identifier field contains ROR URLs, GRID IDs, ISNI numbers, and bare numeric codes — four structurally distinct identifier schemes — all tagged with <code>@Source="ROR"</code>. Without mask profiling, you would discover this only when your ROR lookup fails for 30% of the identifiers. With profiling, the four structural patterns are visible before you write any processing code.</p>
<p><strong>6. The same technique, three formats, three languages.</strong> This book has now profiled pipe-delimited CSV from a UK company register (English), nested JSON from a Japanese earthquake API (Japanese and English), and XML from a US biomedical literature database (international names in Latin script with diacritics). The masking technique, the grain levels, the field population analysis, and the interpretation approach are identical across all three. The data changes. The method does not.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-the-author" class="unnumbered"><a class="header" href="#about-the-author">About the Author</a></h1>
<p><strong>Andrew Morgan</strong> is a data engineer, architect, and consultant with nearly two decades of experience building data platforms and data quality tools across financial services, government, and telecoms.</p>
<p>He is the author of <em>Mastering Spark for Data Science</em> (Packt Publishing, 2017), a 542-page reference covering exploratory data analysis, data quality profiling, graph analytics, natural language processing, and large-scale machine learning with Apache Spark. Chapter 4 of that book introduced the mask-based profiling techniques that form the foundation of the DQOR framework described here.</p>
<p>Andrew is the creator of <strong>bytefreq</strong>, originally written in awk in 2007 and now reimplemented in Rust, and <strong>DataRadar</strong>, a browser-based WASM profiler for locked-down environments where installing software is not possible. His current work at <strong>Gamakon</strong> focuses on data quality tooling, data platform architecture, and consulting.</p>
<p>He believes that data quality should not require a PhD or an enterprise licence — just a clear idea and a good tool.</p>
<ul>
<li>GitHub: <a href="https://github.com/minkymorgan">github.com/minkymorgan</a></li>
<li>DataRadar: <a href="https://dataradar.co.uk">dataradar.co.uk</a></li>
<li>Contact: <a href="mailto:andrew@gamakon.ai">andrew@gamakon.ai</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
