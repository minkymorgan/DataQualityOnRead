<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Assertion Rules Engine: Inside bytefreq - Data Quality on Read</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A practical guide to mask-based data profiling with bytefreq and dataradar">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Data Quality on Read</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/minkymorgan/DataQualityOnRead" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/minkymorgan/DataQualityOnRead/edit/main/src/src/en/12-assertion-rules-engine.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-assertion-rules-engine-inside-bytefreq"><a class="header" href="#the-assertion-rules-engine-inside-bytefreq">The Assertion Rules Engine: Inside bytefreq</a></h1>
<p>The preceding chapters described the DQOR framework conceptually — masks, population analysis, error codes, treatment functions, and the flat enhanced format. This chapter opens the bonnet. We will walk through the actual Rust code that implements assertion rules in bytefreq, show how the rules engine works, and explain how to add a new rule. If you are not a Rust programmer, do not worry — the patterns are straightforward and the logic reads more like pseudocode than systems programming. The important thing is the <em>design patterns</em>, not the language syntax.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The rules engine in bytefreq is deliberately simple. It consists of two files in the <code>src/rules/</code> directory:</p>
<ul>
<li><strong><code>assertions.rs</code></strong> — a library of assertion functions, each of which examines a (field_name, raw, HU, LU) tuple and returns zero or more assertions about the value.</li>
<li><strong><code>enhancer.rs</code></strong> — a thin orchestration layer that calls <code>execute_assertions</code> and returns the results.</li>
</ul>
<p>When bytefreq runs in enhanced mode (<code>-e</code> or <code>-E</code>), every value in the input is processed through a pipeline:</p>
<ol>
<li>The raw value is read from the input (CSV column, JSON field, etc.).</li>
<li>The HU (high-grain Unicode) and LU (low-grain Unicode) masks are generated.</li>
<li>The triple <code>(raw, HU, LU)</code> is passed to the rules engine along with the field name.</li>
<li>The rules engine runs all applicable assertions and returns a JSON object.</li>
<li>The output is written in the flat enhanced format: <code>{ "raw": ..., "HU": ..., "LU": ..., "Rules": ... }</code>.</li>
</ol>
<p>The processing is parallelised across columns using Rayon, so on a multi-core machine the assertion checks run concurrently for each field in a row:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_tabular_line_as_json(
    processed_fields: &amp;Vec&lt;(String, String)&gt;
) -&gt; serde_json::Value {
    let json_line: HashMap&lt;String, serde_json::Value&gt; = processed_fields
        .par_iter()
        .map(|(column_name, value)| {
            let hu_masked_value = mask_value(value, "HU", column_name);
            let lu_masked_value = mask_value(value, "LU", column_name);

            let data = json!({
                "raw": value,
                "LU": lu_masked_value,
                "HU": hu_masked_value
            });

            let assertions = process_data(&amp;column_name, &amp;data);

            let enhanced_value = json!({
                "raw": value,
                "HU": hu_masked_value,
                "LU": lu_masked_value,
                "Rules": assertions
            });

            (column_name.clone(), enhanced_value)
        })
        .collect();

    serde_json::Value::Object(json_line.into_iter().collect())
}
<span class="boring">}</span></code></pre></pre>
<p>The key thing to notice is that the assertion rules receive the mask as well as the raw value. This is the design pattern that makes the engine efficient: the mask acts as a fast structural filter, allowing rules to skip values that are structurally irrelevant without parsing or interpreting them.</p>
<h2 id="the-enhancer"><a class="header" href="#the-enhancer">The Enhancer</a></h2>
<p>The enhancer (<code>src/rules/enhancer.rs</code>) is intentionally minimal:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::rules::assertions::execute_assertions;

pub fn process_data(
    field_name: &amp;str,
    data: &amp;serde_json::Value
) -&gt; Option&lt;serde_json::Value&gt; {
    let lu = data["LU"].as_str().unwrap_or("");
    let hu = data["HU"].as_str().unwrap_or("");
    let raw = data["raw"].as_str().unwrap_or("");

    let assertions = execute_assertions(field_name, raw, lu, hu);

    if assertions.as_object().unwrap().is_empty() {
        None
    } else {
        Some(assertions)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It extracts the triple from the JSON structure, calls <code>execute_assertions</code>, and returns <code>None</code> if no rules matched (keeping the output sparse — fields with no applicable rules produce no Rules column, which saves space in the flat enhanced output).</p>
<h2 id="the-assertions-library"><a class="header" href="#the-assertions-library">The Assertions Library</a></h2>
<p>The core of the engine is <code>execute_assertions</code> in <code>src/rules/assertions.rs</code>. This function takes the field name, raw value, LU mask, and HU mask, and builds up a JSON object of assertions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn execute_assertions(
    field_name: &amp;str,
    raw: &amp;str,
    lu: &amp;str,
    hu: &amp;str
) -&gt; serde_json::Value {
    let mut assertions: serde_json::Map&lt;String, serde_json::Value&gt; =
        serde_json::Map::new();

    // Always compute string length
    assertions.insert(
        "string_length".to_string(),
        json!(string_length(raw))
    );

    // Postal code country detection — only if field name contains "post"
    if field_name.to_lowercase().contains("post") {
        let possible_countries = get_possible_countries(
            field_name, raw, hu, lu
        );
        if !possible_countries.is_empty() {
            assertions.insert(
                "poss_postal_country".to_string(),
                json!(possible_countries)
            );
        }
    }

    // Country name standardisation
    if field_name.to_lowercase().contains("country")
        &amp;&amp; !lu.chars().any(|c| c.is_numeric())
    {
        if let Some((iso3, region_code)) = country_name_to_iso3(raw)
            .map(|iso3| (iso3.clone(), format!("{}-{}", iso3, raw)))
            .or_else(|| handle_country_name_variations(raw))
        {
            assertions.insert("std_country_iso3".to_string(), json!(iso3));
            assertions.insert("std_region_code".to_string(), json!(region_code));
        }
    }

    // Numeric detection
    if lu == "9" || lu == "9.9" {
        assertions.insert(
            "is_numeric".to_string(),
            json!(is_numeric(raw))
        );
    }

    // UK postcode validation
    if lu == "A9 9A" || hu == "A9A 9A" {
        assertions.insert(
            "is_uk_postcode".to_string(),
            json!(is_uk_postcode(raw))
        );
    }

    // Date parsing
    if lu == "9_9_9" {
        assertions.insert(
            "std_date".to_string(),
            json!(parse_date(raw))
        );
    }

    // Date of birth sensibility check
    if hu == "99_99_9999" &amp;&amp; field_name.to_lowercase().contains("dob") {
        assertions.insert(
            "is_sensible_dob".to_string(),
            json!(is_sensible_dob(raw))
        );
    }

    serde_json::Value::Object(assertions)
}
<span class="boring">}</span></code></pre></pre>
<p>There are several design patterns worth noting here.</p>
<h2 id="pattern-1-mask-gated-rules"><a class="header" href="#pattern-1-mask-gated-rules">Pattern 1: Mask-Gated Rules</a></h2>
<p>Most rules are gated by the LU or HU mask. The UK postcode check only fires when <code>lu == "A9 9A"</code> — meaning the value structurally looks like a postcode (letters, digits, space, digits, letters). The date parser only fires when <code>lu == "9_9_9"</code> — meaning the value has three groups of digits separated by a non-digit character. The numeric check only fires when <code>lu == "9"</code> or <code>lu == "9.9"</code>.</p>
<p>This is efficient. Rather than running every assertion against every value (which would be wasteful for a million-row file with dozens of columns), the mask pre-filters. A name column with mask <code>Aaaa Aaaaa</code> will skip the postcode check, the numeric check, and the date parser entirely. Only rules whose structural precondition matches the mask will execute.</p>
<p>This is the same principle introduced in Chapter 7 (Masks as Error Codes), but applied in reverse: instead of using masks to <em>detect</em> problems, we use them to <em>select</em> which enhancement rules are applicable.</p>
<h2 id="pattern-2-field-name-aware-rules"><a class="header" href="#pattern-2-field-name-aware-rules">Pattern 2: Field-Name-Aware Rules</a></h2>
<p>Some rules use the field name as additional context. The postal country detection only runs when the field name contains <code>"post"</code>. The country name standardisation only runs when the field name contains <code>"country"</code>. The date-of-birth sensibility check only runs when the field name contains <code>"dob"</code>.</p>
<p>This is a pragmatic heuristic. A value of <code>SW1A 1AA</code> in a field called <code>postcode</code> should be checked as a UK postcode. The same value in a field called <code>reference_code</code> probably should not. The field name provides domain context that the mask alone cannot.</p>
<p>The heuristic is deliberately loose — <code>contains("post")</code> will match <code>postcode</code>, <code>postal_code</code>, <code>home_postcode</code>, <code>post_code</code>, and even <code>post_office_box</code>. This is intentional: it is better to over-match and produce an assertion that the consumer can ignore, than to under-match and miss a useful suggestion.</p>
<h2 id="pattern-3-standardisation-suggestions"><a class="header" href="#pattern-3-standardisation-suggestions">Pattern 3: Standardisation Suggestions</a></h2>
<p>Several rules do not just detect a property but suggest a standardised form. The country name rule maps free-text country names to ISO 3166-1 alpha-3 codes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn country_name_to_iso3(value: &amp;str) -&gt; Option&lt;String&gt; {
    let name_to_iso3 = country(|c| (
        c.name.to_lowercase(),
        c.iso3
    ));
    name_to_iso3
        .get(&amp;value.to_lowercase())
        .map(|s| s.to_string())
}
<span class="boring">}</span></code></pre></pre>
<p>The function uses the <code>geonamescache</code> crate to look up country names against a known dictionary, returning the ISO3 code if a match is found. It also handles common variations that the standard dictionary misses — <code>"England"</code>, <code>"Scotland"</code>, <code>"Wales"</code>, and <code>"Northern Ireland"</code> are mapped to their ISO codes with region suffixes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_country_name_variations(country_name: &amp;str) -&gt; Option&lt;(String, String)&gt; {
    match country_name.to_lowercase().as_str() {
        "england"          =&gt; Some(("GBR".to_string(), "GB-ENG".to_string())),
        "scotland"         =&gt; Some(("GBR".to_string(), "GB-SCT".to_string())),
        "northern ireland" =&gt; Some(("GBR".to_string(), "GB-NIR".to_string())),
        "wales" | "cymru"  =&gt; Some(("GBR".to_string(), "GB-WLS".to_string())),
        _ =&gt; None,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The output in the Rules column would look like:</p>
<pre><code class="language-json">{
  "std_country_iso3": "GBR",
  "std_region_code": "GBR-England"
}
</code></pre>
<p>This is a <em>suggestion</em>, not a correction. The raw value <code>"England"</code> is preserved in the <code>.raw</code> column. The consumer can choose to use the ISO3 code, or keep the original, or apply their own mapping. The engine surfaces the assertion; the consumer decides what to do with it.</p>
<h2 id="pattern-4-postal-code-country-detection"><a class="header" href="#pattern-4-postal-code-country-detection">Pattern 4: Postal Code Country Detection</a></h2>
<p>The <code>get_possible_countries</code> function is a particularly good example of mask-driven inference. It uses the HU mask of a postal code to determine which countries could have produced that format:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_possible_countries(
    _column_name: &amp;str, raw: &amp;str, hu: &amp;str, lu: &amp;str
) -&gt; Vec&lt;String&gt; {
    let mut possible_countries: Vec&lt;String&gt; = Vec::new();

    match hu {
        "9999" =&gt; {
            possible_countries.extend(vec![
                "AT", "BE", "BG", "CH", "CY", "CZ", "DK", "EE",
                "FI", "GR", "HU", "IE", "LT", "LU", "LV", "MT",
                "NL", "NO", "PL", "PT", "RO", "SE", "SI", "SK"
            ].into_iter().map(|s| s.to_string()));
        }
        "99999" =&gt; {
            possible_countries.extend(vec![
                "DE", "ES", "FR", "HR", "IT"
            ].into_iter().map(|s| s.to_string()));
        }
        "999-99" =&gt; {
            possible_countries.push("SE".to_string());
        }
        "AAA-9999" =&gt; {
            possible_countries.push("IE".to_string());
        }
        _ =&gt; {}
    }

    // Refine using value-level checks
    if lu == "9-9999" &amp;&amp; raw.starts_with("1") {
        possible_countries.retain(|c| c == "DE");
    }

    // UK postal code patterns
    let uk_patterns = vec!["A9 9A", "A9A 9A", "A9A"];
    if uk_patterns.contains(&amp;lu) {
        possible_countries.push("UK".to_string());
    }

    possible_countries
}
<span class="boring">}</span></code></pre></pre>
<p>Notice the two-level logic. First, the HU mask narrows the field to a set of possible countries (a 4-digit postal code could be Austrian, Belgian, Swiss, etc.). Then, value-level checks refine the set further (a 4-digit code starting with <code>0</code> is likely Dutch; a 5-digit code starting with <code>9</code> is likely French). The result is a list of <em>possible</em> countries, not a definitive answer — again, a suggestion that the consumer can use to inform their own logic.</p>
<h2 id="implementing-a-new-rule"><a class="header" href="#implementing-a-new-rule">Implementing a New Rule</a></h2>
<p>Adding a new assertion rule to bytefreq involves three steps.</p>
<h3 id="step-1-write-the-detection-function"><a class="header" href="#step-1-write-the-detection-function">Step 1: Write the Detection Function</a></h3>
<p>Create a function in <code>assertions.rs</code> that takes a raw value (and optionally the masks or field name) and returns the assertion result. For example, a rule to detect email addresses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is_email(value: &amp;str) -&gt; bool {
    let re = Regex::new(
        r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    ).unwrap();
    re.is_match(value)
}

pub fn extract_email_domain(value: &amp;str) -&gt; Option&lt;String&gt; {
    value.split('@').nth(1).map(|s| s.to_lowercase())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="step-2-wire-it-into-execute_assertions"><a class="header" href="#step-2-wire-it-into-execute_assertions">Step 2: Wire It Into execute_assertions</a></h3>
<p>Add a conditional block in the <code>execute_assertions</code> function, gated by the appropriate mask pattern:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Email detection — LU mask "a@a.a" covers most email patterns
if lu.contains("@") &amp;&amp; lu.contains(".") {
    assertions.insert(
        "is_email".to_string(),
        json!(is_email(raw))
    );
    if let Some(domain) = extract_email_domain(raw) {
        assertions.insert(
            "email_domain".to_string(),
            json!(domain)
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The mask gate here is simple: if the LU mask contains both <code>@</code> and <code>.</code>, the value <em>might</em> be an email address (since those punctuation characters are preserved in the mask). The <code>is_email</code> function then performs the definitive check, and <code>extract_email_domain</code> provides a standardised extraction.</p>
<h3 id="step-3-build-and-test"><a class="header" href="#step-3-build-and-test">Step 3: Build and Test</a></h3>
<pre><code class="language-bash">cargo build
echo 'name,email,postcode
John Smith,john@example.com,SW1A 1AA
Jane Doe,jane.doe@company.co.uk,EC2R 8AH' | cargo run -- -E
</code></pre>
<p>The output for the email column would include:</p>
<pre><code class="language-json">{
  "email": {
    "raw": "john@example.com",
    "HU": "aaaa@aaaaaaa.aaa",
    "LU": "a@a.a",
    "Rules": {
      "string_length": 16,
      "is_email": true,
      "email_domain": "example.com"
    }
  }
}
</code></pre>
<h3 id="design-guidelines-for-new-rules"><a class="header" href="#design-guidelines-for-new-rules">Design Guidelines for New Rules</a></h3>
<p>When writing a new assertion rule, several principles from the existing codebase are worth following:</p>
<p><strong>Gate by mask first.</strong> The mask check should be the outer conditional, because it is essentially free (a string comparison) and filters out the majority of values that cannot possibly match. Only values that pass the mask gate should incur the cost of the full assertion logic (regex matching, parsing, dictionary lookup, etc.).</p>
<p><strong>Use the field name as a hint, not a requirement.</strong> Field-name matching (<code>field_name.contains("post")</code>) is useful for disambiguation but should not be the only gate. Some datasets have opaque field names (<code>col_7</code>, <code>field_12</code>), and the rule should still fire for structurally matching values even when the field name provides no context.</p>
<p><strong>Return suggestions, not corrections.</strong> The assertion should describe what the value <em>is</em> or what it <em>could be</em>, not what it <em>should be changed to</em>. The consumer decides whether to act on the suggestion. This keeps the rules engine non-destructive and maintains the DQOR principle of preserving the raw value.</p>
<p><strong>Cache expensive lookups.</strong> The country name lookup uses a <code>RwLock&lt;HashMap&gt;</code> cache to avoid repeated dictionary scans. Any rule that performs an expensive operation (network call, large dictionary lookup, complex regex compilation) should cache results for values it has seen before. The <code>lazy_static</code> pattern used for the country cache is a good template:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>lazy_static! {
    pub static ref COUNTRY_NAME_TO_ISO3_CACHE:
        RwLock&lt;HashMap&lt;String, Option&lt;String&gt;&gt;&gt; =
            RwLock::new(HashMap::new());
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Keep rules independent.</strong> Each rule should be self-contained. Rules should not depend on the output of other rules, and the order in which they execute should not matter. This allows the engine to run rules in parallel (which it does via Rayon) and makes it safe to add, remove, or modify rules without side effects.</p>
<h2 id="the-rules-as-a-living-library"><a class="header" href="#the-rules-as-a-living-library">The Rules as a Living Library</a></h2>
<p>The assertion rules in bytefreq are not a closed set. They are a starting point — a library of common patterns that cover postal codes, country names, dates, numeric values, and basic structural properties. As the tool encounters new types of data, new rules are added.</p>
<p>This is the same continuous improvement loop described in Chapter 8 (treatment functions): profile the data, discover new patterns, write rules to detect and characterise them, and add the rules to the library. Over time, the library grows to reflect the kinds of data that bytefreq's users actually encounter, making the flat enhanced output increasingly useful with each release.</p>
<p>The rules are also an invitation. Because the engine is open source and the pattern for adding a new rule is straightforward — write a function, gate it by mask, wire it into <code>execute_assertions</code> — users with domain-specific knowledge can contribute rules for their own data types. The mask-gated architecture means domain-specific rules coexist with the general-purpose ones without interference, and the flat enhanced format ensures that all assertions — general and domain-specific — are delivered to consumers in a consistent structure.</p>
<p>To make this concrete, here are sketches for three domain-specific rules that follow the same patterns described above.</p>
<h3 id="example-nhs-number-validation-healthcare"><a class="header" href="#example-nhs-number-validation-healthcare">Example: NHS Number Validation (Healthcare)</a></h3>
<p>An NHS number is a 10-digit identifier with a modulus 11 check digit. The mask gate is simple: <code>hu == "9999999999"</code> (exactly 10 digits). The validation function computes the weighted sum and checks the remainder:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Gate: hu == "9999999999"
pub fn is_nhs_number(value: &amp;str) -&gt; bool {
    let digits: Vec&lt;u32&gt; = value.chars().filter_map(|c| c.to_digit(10)).collect();
    if digits.len() != 10 { return false; }
    let weighted_sum: u32 = digits[..9].iter()
        .enumerate()
        .map(|(i, &amp;d)| d * (10 - i as u32))
        .sum();
    let remainder = weighted_sum % 11;
    let check = if remainder == 0 { 0 } else { 11 - remainder };
    check != 10 &amp;&amp; check == digits[9]
}
<span class="boring">}</span></code></pre></pre>
<p>The mask gate ensures this function never fires on phone numbers, postcodes, or other 10-digit values in columns that are not plausibly NHS numbers. A field-name hint (<code>field_name.contains("nhs")</code> or <code>field_name.contains("patient")</code>) could narrow it further.</p>
<h3 id="example-iban-detection-financial-services"><a class="header" href="#example-iban-detection-financial-services">Example: IBAN Detection (Financial Services)</a></h3>
<p>An IBAN starts with a two-letter country code, followed by two check digits, followed by a country-specific Basic Bank Account Number (BBAN). The HU mask for a GB IBAN looks like <code>AA99AAAA99999999999999</code> — 22 characters, letters then digits. The mask gate targets this family of patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Gate: hu starts with "AA99" and length matches known IBAN lengths
pub fn is_valid_iban(value: &amp;str) -&gt; bool {
    let clean: String = value.chars().filter(|c| !c.is_whitespace()).collect();
    if clean.len() &lt; 15 || clean.len() &gt; 34 { return false; }
    // Move first 4 chars to end, convert letters to digits (A=10..Z=35)
    let rearranged = format!("{}{}", &amp;clean[4..], &amp;clean[..4]);
    let numeric: String = rearranged.chars().map(|c| {
        if c.is_alphabetic() {
            format!("{}", c.to_ascii_uppercase() as u32 - 55)
        } else {
            c.to_string()
        }
    }).collect();
    // Modulus 97 check
    numeric.chars().fold(0u64, |acc, c| {
        (acc * 10 + c.to_digit(10).unwrap() as u64) % 97
    }) == 1
}
<span class="boring">}</span></code></pre></pre>
<p>The output might include both validation and decomposition:</p>
<pre><code class="language-json">{
  "is_iban": true,
  "iban_country": "GB",
  "iban_bban": "NWBK60161331926819"
}
</code></pre>
<h3 id="example-email-address-detection"><a class="header" href="#example-email-address-detection">Example: Email Address Detection</a></h3>
<p>The email rule shown in the "Implementing a New Rule" section above is another example of the pattern. The mask gate (<code>lu.contains("@") &amp;&amp; lu.contains(".")</code>) is structural, the validation is semantic, and the extraction (<code>email_domain</code>) provides a useful standardisation suggestion. Together, these three examples — healthcare, financial services, and general-purpose — illustrate how the same mask-gate-then-validate pattern extends to any domain.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="13-using-bytefreq.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="conclusion.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="13-using-bytefreq.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="conclusion.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
