<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Using DataRadar: A Walkthrough - Data Quality on Read</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A practical guide to mask-based data profiling with bytefreq and dataradar">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Data Quality on Read</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/minkymorgan/DataQualityOnRead" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/minkymorgan/DataQualityOnRead/edit/main/src/src/en/11-using-dataradar.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="using-dataradar-a-walkthrough"><a class="header" href="#using-dataradar-a-walkthrough">Using DataRadar: A Walkthrough</a></h1>
<p>The previous chapters described the theory: masks, grain levels, population analysis, error codes, treatment functions, and the flat enhanced format. This chapter puts it into practice using DataRadar, the browser-based profiling tool. We will walk through a complete profiling session, from uploading a file to interpreting the output and exporting the results.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Open <a href="https://dataradar.co.uk">dataradar.co.uk</a> in any modern browser. There is nothing to install, no account to create, and no data leaves your machine — all processing happens client-side using WebAssembly.</p>
<p>The interface presents a file upload area at the top. You can either click to browse for a file, or drag and drop one onto the page. DataRadar supports four input formats:</p>
<ul>
<li><strong>CSV / Tabular</strong> — comma, pipe, tab, semicolon, or custom delimited files</li>
<li><strong>Excel</strong> — .xlsx, .xls, .xlsb, and .ods spreadsheets (with sheet selection)</li>
<li><strong>JSON / NDJSON</strong> — newline-delimited JSON (one record per line), or standard JSON arrays</li>
<li><strong>URLs</strong> — paste a URL to a JSON API endpoint and DataRadar will fetch and profile the response directly</li>
</ul>
<p>For CSV files, the delimiter is auto-detected but can be overridden. For Excel files, you can select which sheet to profile and whether the first row contains headers.</p>
<h2 id="the-report-options"><a class="header" href="#the-report-options">The Report Options</a></h2>
<p>Before running the profiler, three settings control what output you get:</p>
<h3 id="report-type"><a class="header" href="#report-type">Report Type</a></h3>
<ul>
<li><strong>Data Quality (DQ)</strong> — the default. Generates mask-based frequency profiles for each column, showing the structural patterns and their counts. This is what you want for the workflow described in this book.</li>
<li><strong>Character Profiling (CP)</strong> — generates byte-level or code-point-level frequency analysis of the file content. This is the forensic mode described in Chapter 5, useful for diagnosing encoding issues, identifying unexpected control characters, or determining the character sets present in the data.</li>
</ul>
<h3 id="masking-level"><a class="header" href="#masking-level">Masking Level</a></h3>
<p>Four grain levels are available:</p>
<ul>
<li><strong>High Unicode (HU)</strong> — detailed masks with full Unicode character class support. Every character maps individually. This is the default and the most generally useful mode.</li>
<li><strong>Low Unicode (LU)</strong> — compressed masks where consecutive characters of the same class are collapsed. Use this for initial discovery when you want to see structural families rather than exact formats.</li>
<li><strong>High ASCII (H)</strong> — the classic A/a/9 mask at full resolution, treating all non-ASCII bytes as "other." Useful for legacy data or when you specifically want ASCII-only profiling.</li>
<li><strong>Low ASCII (L)</strong> — compressed ASCII masks. The original bytefreq mode, equivalent to the <code>sed</code> one-liner described in Chapter 4.</li>
</ul>
<p>For most work, start with <strong>LU</strong> (Low Unicode) to get the broad structural picture, then switch to <strong>HU</strong> (High Unicode) to examine specific columns in detail.</p>
<h3 id="output-format"><a class="header" href="#output-format">Output Format</a></h3>
<p>The profiling results can be displayed and exported in several formats:</p>
<ul>
<li><strong>Human-readable Text</strong> — a formatted report suitable for reading in the browser or pasting into a document.</li>
<li><strong>JSON</strong> — structured output for programmatic consumption.</li>
<li><strong>Markdown</strong> — formatted for inclusion in documentation or GitHub README files.</li>
</ul>
<h2 id="running-a-profile"><a class="header" href="#running-a-profile">Running a Profile</a></h2>
<p>With a file loaded and the options set, click <strong>Analyze Data</strong>. The profiler runs in the browser and results appear below the controls.</p>
<p>The output is organised by column. For each column in the input data, the profiler shows:</p>
<ul>
<li>The <strong>column name</strong> (or column number for headerless files).</li>
<li>The <strong>total count</strong> of values profiled.</li>
<li>A <strong>frequency table</strong> of masks, sorted by count descending.</li>
</ul>
<p>For example, profiling a CSV with a <code>phone_number</code> column at High Unicode grain might produce:</p>
<pre><code>=== phone_number (1,000 values) ===

Mask                    Count    %
99999 999999              812   81.2%
+99 9999 999999            95    9.5%
9999 999 9999              42    4.2%
(999) 999-9999             31    3.1%
aaaa                       12    1.2%
99999999999                 4    0.4%
Aaaa aaa Aaaa               2    0.2%
                             2    0.2%
</code></pre>
<p>This is the population profile described in Chapter 6. The dominant mask (<code>99999 999999</code>) represents UK mobile numbers. The long tail reveals international formats, US formats, placeholders (<code>aaaa</code> — probably <code>null</code> or <code>none</code>), names in the wrong field (<code>Aaaa aaa Aaaa</code>), and empty strings.</p>
<h2 id="inspecting-the-data"><a class="header" href="#inspecting-the-data">Inspecting the Data</a></h2>
<p>Before running the full profile, DataRadar offers a <strong>data preview</strong> that shows the first rows of the parsed file. This is worth checking — it confirms that the delimiter was detected correctly, that headers were identified, and that the columns are aligned. If the preview looks wrong (columns misaligned, headers appearing as data rows, or delimiter issues), adjust the format settings and re-check before profiling.</p>
<p>For JSON input, the preview shows the flattened field paths, which is useful for understanding the structure of nested data before profiling it.</p>
<h2 id="the-flat-enhanced-export"><a class="header" href="#the-flat-enhanced-export">The Flat Enhanced Export</a></h2>
<p>The most powerful output mode is the <strong>Flat Enhanced JSON</strong> export, selected from the Output Format dropdown. This produces the flat enhanced format described in Chapter 9: for every field in every record, the output includes the parallel column families:</p>
<pre><code class="language-json">{
  "phone_number.raw": "+44 7700 900123",
  "phone_number.HU": "+99 9999 999999",
  "phone_number.LU": "+9 9 9",
  "phone_number.Rules": {
    "string_length": 15,
    "poss_postal_country": null
  },
  "postcode.raw": "SW1A 1AA",
  "postcode.HU": "AA9A 9AA",
  "postcode.LU": "A9A 9A",
  "postcode.Rules": {
    "string_length": 8,
    "is_uk_postcode": true,
    "poss_postal_country": ["UK"]
  }
}
</code></pre>
<p>Each record in the input becomes a single JSON line in the output, with every field expanded into its <code>.raw</code>, <code>.HU</code>, <code>.LU</code>, and <code>.Rules</code> sub-columns. This is the file you would load into Pandas, Polars, DuckDB, or any other analytical tool for downstream processing.</p>
<h3 id="loading-flat-enhanced-output-in-python"><a class="header" href="#loading-flat-enhanced-output-in-python">Loading Flat Enhanced Output in Python</a></h3>
<pre><code class="language-python">import pandas as pd

df = pd.read_json('output.ndjson', lines=True)

# Use the raw values
df['postcode.raw']

# Use the mask for quality checks
df['postcode.HU']

# Use the Rules suggestions
df['postcode.Rules'].apply(lambda r: r.get('is_uk_postcode') if r else None)
</code></pre>
<h3 id="loading-in-duckdb"><a class="header" href="#loading-in-duckdb">Loading in DuckDB</a></h3>
<pre><code class="language-sql">SELECT
    "postcode.raw" AS postcode,
    "postcode.HU" AS mask,
    "postcode.Rules"-&gt;&gt;'is_uk_postcode' AS is_valid
FROM read_ndjson_auto('output.ndjson');
</code></pre>
<p>The real trick comes at scale. In practice, you pool hundreds of small enhanced output files into a single directory — one per source file, one per batch, one per day — and use DuckDB's file glob to query across all of them in one shot:</p>
<pre><code class="language-sql">SELECT
    "postcode.raw" AS postcode,
    "postcode.HU" AS mask,
    "postcode.Rules"-&gt;&gt;'is_uk_postcode' AS is_valid,
    filename
FROM read_ndjson_auto('exports/*.ndjson', filename=true)
WHERE "postcode.Rules"-&gt;&gt;'is_uk_postcode' = 'false';
</code></pre>
<p>This is the pattern that makes mask-based profiling operational. You do not need to merge files, build a database, or maintain an ingestion pipeline. You just drop enhanced exports into a directory and query the lot. DuckDB handles the file glob, schema unification, and columnar scanning — and because the flat enhanced format is regular NDJSON with consistent column names, it all just works. A directory of exports becomes a queryable quality lake with zero infrastructure.</p>
<h2 id="working-with-json-and-api-data"><a class="header" href="#working-with-json-and-api-data">Working With JSON and API Data</a></h2>
<p>One of DataRadar's distinguishing features is its ability to profile JSON data directly, including data fetched from API endpoints. This is particularly useful for open data projects where the data arrives as GeoJSON, REST API responses, or NDJSON feeds.</p>
<p>To profile an API endpoint, paste the URL into the URL field and click fetch. DataRadar will retrieve the response, detect the format, and present it for profiling. If the response is a paginated API response (a single JSON object containing an array), DataRadar detects this and offers to extract and convert the array to NDJSON format automatically.</p>
<p>For example, profiling the USGS earthquake feed:</p>
<pre><code>https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson
</code></pre>
<p>DataRadar will detect the nested GeoJSON structure, flatten the <code>properties</code> and <code>geometry</code> objects into dot-notation field paths (<code>properties.time</code>, <code>properties.mag</code>, <code>geometry.coordinates.0</code>), and profile each flattened field. The flat enhanced export then produces output like:</p>
<pre><code class="language-json">{
  "properties.time.raw": "1766181640870",
  "properties.time.HU": "9999999999999",
  "properties.time.LU": "9",
  "properties.time.Rules": {
    "string_length": 13,
    "is_numeric": true
  }
}
</code></pre>
<p>From this output, it is immediately clear that the <code>time</code> field contains 13-digit numeric values — Unix timestamps in milliseconds. A downstream consumer can parse these into datetimes with confidence, knowing that the mask confirms structural consistency across all records.</p>
<h2 id="multilingual-data"><a class="header" href="#multilingual-data">Multilingual Data</a></h2>
<p>DataRadar handles international data without configuration. When profiling a dataset containing names, addresses, or descriptions in non-Latin scripts, the Unicode-aware masking produces structurally meaningful masks for every script:</p>
<ul>
<li>Chinese characters (Lo category) mask to <code>a</code>, so 北京饭店 becomes <code>aaaa</code></li>
<li>Arabic text with spaces preserves word boundaries: <code>a a a</code></li>
<li>Cyrillic names follow the same uppercase/lowercase distinction as Latin: <code>Aaaaaaa</code></li>
<li>Mixed-script fields (Latin + CJK, Arabic + digits) reveal the mixing in the mask</li>
</ul>
<p>The profiler also reports detected scripts per field, flagging columns that contain mixed scripts — which may indicate encoding issues, data from multiple sources, or legitimate multilingual content.</p>
<h2 id="the-workflow-in-practice"><a class="header" href="#the-workflow-in-practice">The Workflow in Practice</a></h2>
<p>A typical DataRadar session follows the two-pass workflow described in Chapter 6:</p>
<ol>
<li><strong>Load the file</strong> and check the data preview to confirm correct parsing.</li>
<li><strong>Run a Low Unicode (LU) profile</strong> to survey the structural landscape. Scan each column's masks to understand the dominant patterns and spot obvious anomalies.</li>
<li><strong>Switch to High Unicode (HU)</strong> and re-profile to examine specific columns where format precision matters (postcodes, phone numbers, dates, identifiers).</li>
<li><strong>Export Flat Enhanced JSON</strong> for any data you want to process further — the export preserves raw values, masks, and rule suggestions for every record.</li>
<li><strong>Load the export</strong> into your analytical tool of choice (Pandas, DuckDB, Excel) and proceed with your analysis, using the mask and Rules columns to guide quality decisions.</li>
</ol>
<p>The entire process — from opening the browser to having a flat enhanced export loaded in a notebook — typically takes less than five minutes. No installation, no configuration, no data leaving your machine.</p>
<p>For larger datasets — anything beyond roughly 50,000 rows — the browser's memory constraints become the limiting factor. If you hit this ceiling, switch to bytefreq on the command line (see Chapter 13), which handles millions of rows with the same profiling engine and the same output format. DataRadar is for exploration and quick checks; bytefreq is for scale.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="11-quality-monitoring.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="13-using-bytefreq.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="11-quality-monitoring.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="13-using-bytefreq.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
